var tipuesearch = {"pages":[{"title":" Example Project ","text":"Example Project Hi, my name is bikashtimalsina. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. linalg Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like or math on its own line\nlike or You can even use LaTeX environments!\nSo you can get numbered equations like this: So let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info John Doe I program stuff in Fortran.","tags":"home","loc":"index.html"},{"title":"test.f90 – Example Project","text":"Contents Source Code test.f90 Source Code ihello","tags":"","loc":"sourcefile/test.f90.html"},{"title":"force_constants.f90 – Example Project","text":"initialize data\nget force constants\nbring a force constant to a unique form: atoms\nbring a point into the unit cell at the origin get force constants for a given rank out to a given nearest neighbor shell This file depends on sourcefile~~force_constants.f90~~EfferentGraph sourcefile~force_constants.f90 force_constants.f90 sourcefile~modules9.f90 modules9.f90 sourcefile~force_constants.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions ncmp vlength ndet ifactorial Subroutines force_constants_init force_constants unique_force_constant findatom findatom2 xmatinv ludcmp lubksb xmatmlt xvmlt unitcell dlatmat2 xvsub xvadd bomb permutations xrowop2 getstar collect_force_constants Source Code force_constants.f90 Source Code !****************************************************************************** !! initialize data subroutine force_constants_init ( lattparams , primlatt , natoms_in , & & iatomtype , atompos_in ) ! arguments: !     lattparams(i) (input), lattice parameters a,b,c,alpha,beta,gamma !     primlatt(i,j) (input), ith dimensionless coordinate of jth basis vector !          of the primitive lattice !     natoms_in (input), number of atoms in the primitive unit cell !     iatomtype(i) (input), type of ith atom, numbered 1,2,3,etc. !     atompos_in(j,i) (input), jth dimensionless coordinate of the ith atom use lattice use force_constants_module implicit none integer maxshell !      parameter(maxshell=10) integer , intent ( in ) :: natoms_in , iatomtype ( natoms_in ) real ( 8 ), intent ( in ) :: lattparams ( 6 ), primlatt ( 3 , 3 ), atompos_in ( 3 , natoms_in ) integer i , j , k , m , n , i1 , i2 , i3 , i6 , nd2save , ncmp , nshell , & & ier , iatom , iatom2 , itype2 , iatom3 , ipntop , & & itype , isg , iatom0 , icell ( 3 ), iop_matrix ( 3 , 3 , 48 ) logical foundone real ( 8 ) d2save ( maxneighbors ), r ( 3 ), d2 , d2r , & & conv_to_cart ( 3 , 3 ), prim_to_cart ( 3 , 3 ), cart_to_prim ( 3 , 3 ), & & prim_to_conv ( 3 , 3 ), conv_to_prim ( 3 , 3 ), tempi ( 3 , 3 ), latp ( 6 ), & & atomposconv ( 3 , natoms_in ), fract ( 3 ), v ( 3 ), v2 ( 3 ), temp ( 3 , 3 ) !k1 maxshell = maxneighbors d2r = 4 d0 * datan ( 1 d0 ) / 180 d0 ! 3.1415926535897932384626/180d0 !k1 !------------------------------------------------------------------------------- ! some preliminary stuff ! copy input arguments into global variables natoms0 = natoms_in atomposconv ( 1 : 3 , 1 : natoms0 ) = atompos_in ( 1 : 3 , 1 : natoms0 ) write ( * , * ) 'atompos_in= ' , atompos_in ! allocate memory if ( allocated ( iatomneighbor )) deallocate ( iatomneighbor ) if ( allocated ( atomopfract )) deallocate ( atomopfract ) if ( allocated ( iatomop )) deallocate ( iatomop ) allocate ( iatomneighbor ( natoms0 , maxatoms )) allocate ( iatomop ( natoms0 , natoms0 ), atomopfract ( 3 , natoms0 , natoms0 )) iatomneighbor = maxneighbors + 1 iatomop = 0 write ( * , * ) 'primlatt=' , primlatt ! get primitive lattice vectors in terms of conventional lattice vectors prim_to_conv ( 1 : 3 , 1 : 3 ) = primlatt ( 1 : 3 , 1 : 3 ) call xmatinv ( prim_to_conv , conv_to_prim , ier ) if ( ier . ne . 0 ) then write ( 6 , * ) 'Error in force_constants_init: primitive_lattice ' & & // 'is singular' stop endif ! get conventional lattice parameters in cartesian coordinates conv_to_cart = 0 latp = lattparams !     latp(4:6) = latp(4:6)*d2r   ! convert angles from degree to radian conv_to_cart ( 1 , 1 ) = latp ( 1 ) conv_to_cart ( 1 , 2 ) = latp ( 2 ) * dcosd ( latp ( 6 )) conv_to_cart ( 2 , 2 ) = latp ( 2 ) * dsind ( latp ( 6 )) conv_to_cart ( 1 , 3 ) = latp ( 3 ) * dcosd ( latp ( 5 )) conv_to_cart ( 2 , 3 ) = latp ( 3 ) * ( dcosd ( latp ( 4 )) & & - dcosd ( latp ( 6 )) * dcosd ( latp ( 5 ))) / dsind ( latp ( 6 )) conv_to_cart ( 3 , 3 ) = sqrt ( latp ( 3 ) ** 2 - conv_to_cart ( 1 , 3 ) ** 2 & & - conv_to_cart ( 2 , 3 ) ** 2 ) write ( * , * ) 'conv_to_cart=' , conv_to_cart ! get primitive lattice parameters in cartesian coordinates call xmatmlt ( conv_to_cart , prim_to_conv , prim_to_cart , 3 , 3 , 3 , 3 , 3 , 3 ) call xmatinv ( prim_to_cart , cart_to_prim , ier ) if ( ier . ne . 0 ) then write ( 6 , * ) 'Error in force_constants_init: primitive_lattice ' & & // 'is singular' stop endif write ( * , * ) 'cart_to_prim=' , cart_to_prim ! added by k1 -------- ! prim_to_cart(i,j) is the ith cartesian coordinate of the jth translation ! vector of the primitive lattice. !     call write_out(ulog,'translationc ',3,3,prim_to_cart) r01 = prim_to_cart (:, 1 ) r02 = prim_to_cart (:, 2 ) r03 = prim_to_cart (:, 3 ) !     call write_out(ulog,'transpose(g) ',3,3,cart_to_prim) write ( * , * ) 'transpose(g) ' , cart_to_prim ! added by k1 -------- ! get atomic positions in cartesian coordinates natoms = natoms0 iatomcell ( 1 : 3 , 1 : natoms ) = 0 do i = 1 , natoms0 write ( * , * ) 'before xvmlt ' , i call xvmlt ( conv_to_cart , atomposconv ( 1 , i ), atompos ( 1 , i ), 3 , 3 , 3 ) write ( * , * ) 'before unitcell ' , i call unitcell ( cart_to_prim , prim_to_cart , atompos ( 1 , i ), atompos ( 1 , i )) iatomcell0 ( i ) = i iatomneighbor ( i , i ) = 0 enddo write ( * , * ) 'before dlatmat2' !------------------------------------------------------------------------------- ! find symmetry of crystal. ! find point group of lattice !k1   call dlatmat2(prim_to_cart,1d-6,lattpgcount,iop_matrix) call dlatmat2 ( prim_to_cart , 1 d - 5 , lattpgcount , iop_matrix ) do i = 1 , lattpgcount do j = 1 , 3 do k = 1 , 3 temp ( k , j ) = iop_matrix ( k , j , i ) enddo enddo call xmatmlt ( temp , cart_to_prim , temp , 3 , 3 , 3 , 3 , 3 , 3 ) call xmatmlt ( prim_to_cart , temp , op_matrix ( 1 , 1 , i ), 3 , 3 , 3 , 3 , 3 , 3 ) write ( 30 , * ) 'Symmetry operation (op_matrix) #' , i write ( 30 , '(3(1x,f9.5))' ) op_matrix (:, 1 , i ) write ( 30 , '(3(1x,f9.5))' ) op_matrix (:, 2 , i ) write ( 30 , '(3(1x,f9.5))' ) op_matrix (:, 3 , i ) enddo write ( * , * ) 'after lattpgcount loop' ! find transformation matrices for k vectors do i = 1 , lattpgcount do j = 1 , 3 do k = 1 , 3 temp ( k , j ) = iop_matrix ( k , j , i ) enddo enddo call xmatmlt ( temp , conv_to_prim , temp , 3 , 3 , 3 , 3 , 3 , 3 ) call xmatmlt ( prim_to_conv , temp , temp , 3 , 3 , 3 , 3 , 3 , 3 ) call xmatinv ( temp , tempi , ier ) temp = tempi if ( ier . ne . 0 ) then write ( * , * ) 'After xmatinv in line 125: ier=' , ier call bomb endif write ( * , * ) ' NOW GENERATING THE STARS OF K; lattpgcount=' , i do j = 1 , 3 do k = 1 , 3 op_kmatrix ( k , j , i ) = nint ( temp ( j , k )) if ( ncmp ( temp ( j , k ) - op_kmatrix ( k , j , i )). ne . 0 ) then write ( 30 , * ) 'Op_kmatrix' , temp ( j , k ), op_kmatrix ( k , j , i ) !           call bomb write ( 30 , * ) '****************************************************' write ( 30 , * ) 'WARNING!! SOMETHNG WRONG IN EVALUATION OF Op_kmatrix' write ( 30 , * ) '****************************************************' endif enddo enddo write ( 30 , * ) 'Symmetry operation (op_kmatrix) #' , i write ( 30 , '(3(1x,f9.5))' ) op_kmatrix (:, 1 , i ) write ( 30 , '(3(1x,f9.5))' ) op_kmatrix (:, 2 , i ) write ( 30 , '(3(1x,f9.5))' ) op_kmatrix (:, 3 , i ) enddo ! find elements of space group ! count them isgopcount = 0 ! try each element of point group of lattice ipntoploop : do ipntop = 1 , lattpgcount ! operate on atom 1.  v contains the coordinates of the atom after ! the operation call xvmlt ( op_matrix ( 1 , 1 , ipntop ), atompos ( 1 , 1 ), v , 3 , 3 , 3 ) ! try to map the rotated atom 1 onto every other atom of the same type iatomloop2 : do iatom = 1 , natoms0 if ( iatomtype ( iatom ). eq . iatomtype ( 1 )) then ! find the fractional translation required in the space group element call xvsub ( atompos ( 1 , iatom ), v , fract , 3 ) call unitcell ( cart_to_prim , prim_to_cart , fract , fract ) ! now try this space group element on every other atom iatom2loop2 : do iatom2 = 1 , natoms0 itype2 = iatomtype ( iatom2 ) ! operate on the atom: rotation followed by a fractional translation ! v contains the coordinates of the atom after the operation by the space ! group element. call xvmlt ( op_matrix ( 1 , 1 , ipntop ), atompos ( 1 , iatom2 ), v2 , 3 , 3 , 3 ) v2 = v2 + fract !call xvadd(fract,v2,v2,3) call unitcell ( cart_to_prim , prim_to_cart , v2 , v2 ) ! try to find another atom of the same type with these coordinates iatom3loop2 : do iatom3 = 1 , natoms0 if ( iatomtype ( iatom3 ). eq . itype2 ) then do i = 1 , 3 ! this one isn't it, try another one if ( ncmp ( v2 ( i ) - atompos ( i , iatom3 )). ne . 0 ) cycle iatom3loop2 enddo ! we found it, try the space group element on another atom cycle iatom2loop2 endif ! try to find another atom (iatom3) enddo iatom3loop2 ! did not find it, try mapping atom 1 onto another atom cycle iatomloop2 ! try the space group element on the next atom (iatom2) enddo iatom2loop2 ! space group element was successful for every atom, save it ! count them isgopcount = isgopcount + 1 ! save rotation part of element isgop ( isgopcount ) = ipntop ! save translational part of element do i = 1 , 3 sgfract ( i , isgopcount ) = fract ( i ) enddo ! do next element of point group cycle ipntoploop ! try mapping atom 1 onto another atom endif enddo iatomloop2 ! this element is not in space group ! do next element of point group (ipg) enddo ipntoploop !---------------------------------------------------------------------------- ! find operators that take atoms into atoms in the primitive unit cell ! do each atom do iatom = 1 , natoms0 itype = iatomtype ( iatom ) ! do each element of space group do isg = 1 , isgopcount ipntop = isgop ( isg ) ! operate on position of atom iatom call xvmlt ( op_matrix ( 1 , 1 , ipntop ), atompos ( 1 , iatom ), v , 3 , 3 , 3 ) v2 = v + sgfract (:, isg ) !call xvadd(sgfract(1,isg),v,v2,3) call unitcell ( cart_to_prim , prim_to_cart , v2 , v2 ) ! look for atom iatom2loop3 : do iatom2 = 1 , natoms0 if ( iatomtype ( iatom2 ). eq . itype ) then do i = 1 , 3 if ( ncmp ( v2 ( i ) - atompos ( i , iatom2 )). ne . 0 ) cycle iatom2loop3 enddo ! found it.  save it if not already previously found if ( iatomop ( iatom , iatom2 ). eq . 0 ) then iatomop ( iatom , iatom2 ) = ipntop call xvsub ( atompos ( 1 , iatom ), v , atomopfract ( 1 , iatom , iatom2 ), 3 ) exit iatom2loop3 endif ! try to match another atom (iatom2) endif enddo iatom2loop3 ! next space group element enddo ! next atom (iatom) enddo !------------------------------------------------------------------------------- ! collect nearest neighbor atoms ! do each atom in primitive unit cell do iatom0 = 1 , natoms0 nd2save = 0 m = 0 ! collect distances to nearest neighbors ! do one shell of unit cells at a time do n = 0 , maxshell foundone = . false . do i1 =- n , n do i2 =- n , n do i3 =- n , n if ( iabs ( i1 ). ne . n . and . iabs ( i2 ). ne . n . and . iabs ( i3 ). ne . n ) cycle ! only 8 terms in the sum ! do each atom in unit cell iloop : do i = 1 , natoms0 ! skip the atom at the origin if ( n . eq . 0. and . i . eq . iatom0 ) cycle ! position of atom and distance squared r ( 1 : 3 ) = atompos ( 1 : 3 , i ) d2 = 0 ! d2 = Ri+tau_i-tau_j do j = 1 , 3 r ( j ) = atompos ( j , i ) + i1 * prim_to_cart ( j , 1 ) & & + i2 * prim_to_cart ( j , 2 ) + i3 * prim_to_cart ( j , 3 ) - atompos ( j , iatom0 ) d2 = d2 + r ( j ) ** 2 enddo ! did we find any new ones in this shell? if ( m . eq . 0 ) then foundone = . true . else if ( ncmp ( d2 - d2save ( nd2save )). eq . 0. or . d2 . lt . d2save ( nd2save )) then foundone = . true . endif ! compare distance to atom with previously found distances do j = 1 , nd2save ! same distance: do another atom if ( ncmp ( d2 - d2save ( j )). eq . 0 ) cycle iloop ! new distance: insert into list if ( d2 . lt . d2save ( j )) then do k = maxneighbors , j + 1 , - 1 d2save ( k ) = d2save ( k - 1 ) enddo if ( nd2save . lt . maxneighbors ) nd2save = nd2save + 1 d2save ( j ) = d2 cycle iloop endif enddo ! new distance: insert at end of list if list is not already full if ( nd2save . lt . maxneighbors ) then nd2save = nd2save + 1 d2save ( nd2save ) = d2 endif enddo iloop enddo enddo enddo ! no new atom found in shell:  save previous shell and exit loop if (. not . foundone . and . nd2save . eq . maxneighbors ) then nshell = n - 1 exit endif ! list is filled if ( nd2save . eq . maxneighbors . and . m . eq . 0 ) m = 1 ! we reached the last shell before we finished the list if ( n . eq . maxshell ) then write ( 6 , * ) 'Error:  maxshell is not large enough ' , maxshell close ( 20 ) stop endif enddo !----------------------------------------------------------------------------- ! generate positions of neighbors ! do each shell of unit cells do n = 0 , nshell do i1 =- n , n icell ( 1 ) = i1 do i2 =- n , n icell ( 2 ) = i2 do i3 =- n , n icell ( 3 ) = i3 if ( iabs ( i1 ). ne . n . and . iabs ( i2 ). ne . n . and . iabs ( i3 ). ne . n ) cycle ! do each atom in unit cell do i = 1 , natoms0 ! skip atom at origin if ( n . eq . 0. and . i . eq . iatom0 ) cycle ! position of atom r ( 1 : 3 ) = atompos ( 1 : 3 , i ) d2 = 0 do j = 1 , 3 r ( j ) = atompos ( j , i ) + i1 * prim_to_cart ( j , 1 ) & & + i2 * prim_to_cart ( j , 2 ) + i3 * prim_to_cart ( j , 3 ) d2 = d2 + ( r ( j ) - atompos ( j , iatom0 )) ** 2 enddo ! find in list do m = 1 , nd2save if ( ncmp ( d2 - d2save ( m )). eq . 0 ) then call findatom ( icell , i , iatom ) if ( iatom . eq . 0 ) then natoms = natoms + 1 if ( natoms . gt . maxatoms ) then write ( 6 , * ) 'Warning: in force_constants_init:  ' & & // 'the value of maxatoms needs to be larger.' imaxat = 1 !                      do i6=1,3 !                         atompos(i6,:)=[atompos(i6,:),r(i6)] !                         iatomcell(i6,:)=[iatomcell(i6,:),icell(i6)] !                      enddo !                      iatomcell0=[iatomcell0,i] !                      iatomneighbor(iatom0,:)=[iatomneighbor(iatom0,:),m] return endif atompos ( 1 : 3 , natoms ) = r ( 1 : 3 ) iatomcell ( 1 : 3 , natoms ) = icell ( 1 : 3 ) iatomcell0 ( natoms ) = i iatomneighbor ( iatom0 , natoms ) = m else iatomneighbor ( iatom0 , iatom ) = m endif endif enddo enddo enddo enddo enddo enddo ! next inequivalent atom enddo imaxat = 0 end subroutine force_constants_init !****************************************************************************** !! get force constants subroutine force_constants ( nrank , iatomd , ixyzd , & & ntermsindep , iatomtermindep , ixyztermindep , & & nterm5 , iatomtermall , ixyztermall , amat , ntermszero , & & iatomtermzero , ixyztermzero , & & maxrank , maxterms , maxtermsindep , maxtermszero , ierz , iert , ieri ) ! find relationships between terms of the form d&#94;nU/dxidxjdxk... ! where U is the total energy of the crystal and xi is a coordinate (x=x,y,z) ! of the ith atom. ! arguments: !     nrank (input), order of derivative !     iatomd(i) (input), atom at ith location in denominator !     ixyzd(i) (input), coordinate (1,2,3=x,y,z) at ith location in denominator !     ntermsindep (output), number of independent terms !     iatomtermindep(i,j) (output), atom at ith location in denominator of !          jth independent term !     ixyztermindep(i,j) (output), coordinate at ith location in denomonitor !          of jth independent term !     nterm5 (output), total number of nonzero terms !     iatomtermall(i,j) (output), atom at ith location in denominator of !          jth nonzero term !     ixyztermall(i,j) (output), coordinate at ith location in denomonitor of !          jth nonzero term !     amat(i,j) (output), coefficient of jth independent term in equation for !          kth nonzero term !     ntermszero (output), number of zero terms generated !     iatomtermzero(i,j) (output), atom at ith location in denominator of !          jth zero term !     ixyztermzero(i,j) (output), coordinate at ith location in denomonitor !          of jth zero term !     maxrank (input), number of rows in arrays iatomtermindep, ixyztermindep, !          iatomtermall, ixyztermall, iatomtermzero and ixyztermzero !     maxterms (input), number of columns in arrays iatomtermall and !          ixyztermall !     maxtermsindep (input), number of columns in arrays iatomtermindep and !          ixyztermindep !     maxtermszero (input), number columns in arrays iatomtermzero and !          ixyztermzero use force_constants_module implicit none integer , intent ( in ) :: nrank , maxrank , maxterms , maxtermsindep , maxtermszero integer , intent ( out ) :: ierz , iert , ieri , ntermsindep , nterm5 , ntermszero integer , intent ( in ) :: iatomd ( nrank ), ixyzd ( nrank ) integer , intent ( out ) :: iatomtermindep ( maxrank , maxterms ), & & ixyztermindep ( maxrank , maxterms ), & & iatomtermall ( maxrank , maxterms ), ixyztermall ( maxrank , maxterms ), & & iatomtermzero ( maxrank , maxtermszero ), & & ixyztermzero ( maxrank , maxtermszero ) integer i , j , k , m , n , iatom ( nrank ), ncmp , ixyz ( nrank ), & & iatomterm ( maxrank , maxterms ), ixyzterm ( maxrank , maxterms ), jterm , & & icell ( 3 ), iv ( 3 ), isg , msave , nn , & & irank , k2 , neqs , ifactorial , msave2 , j2 , & & npermute , ixyzfirst ( nrank ), ixyz4 ( nrank ), & & mapdep ( maxterms ), mapterms ( maxterms ), & & maptermsindep ( maxterms ), mapindepterms ( maxterms ) logical foundit ( maxterms ), firstone , zero ( maxterms ) double precision v ( 3 ), amp real ( 8 ), intent ( out ) :: amat ( maxterms , maxtermsindep ) integer , allocatable :: ipermute (:,:) real ( 8 ), allocatable :: eqs (:,:), eqs2 (:,:) allocate ( eqs ( maxterms , maxterms ), eqs2 ( maxterms , maxterms )) ! check if input values are valid if ( nrank . gt . maxrank ) then write ( 6 , * ) 'Error in force_constants: nrank > maxrank' stop endif do i = 1 , nrank if ( ixyzd ( i ). lt . 1. or . ixyzd ( i ). gt . 3 ) then write ( 6 , * ) 'Error in force_constants:  invalid value in ixyzd' stop endif if ( iatomd ( i ). lt . 1. or . iatomd ( i ). gt . natoms ) then write ( 6 , * ) 'Error in force_constants:  invalid value in iatomd' stop endif enddo ! get permutations of nrank items npermute = ifactorial ( nrank ) n = 1 do i = 2 , nrank n = n * i enddo allocate ( ipermute ( nrank , n )) call permutations ( nrank , ipermute , nrank , n ) eqs = 0 nterm5 = 1 call unique_force_constant ( nrank , iatomd , ixyzd , iatomterm , ixyzterm ) jterm = 1 neqs = 0 ntermszero = 0 do while ( jterm . le . nterm5 ) !        write(6,*)jterm,nterm5 ! do each space-group operator do isg = 1 , isgopcount neqs = neqs + 1 if ( neqs . gt . maxterms ) then write ( 6 , * ) 'Warning: in force_constants: maxterms too small' iert = iert + 1 deallocate ( ipermute , eqs , eqs2 ) return endif eqs ( neqs : maxterms , 1 : nterm5 ) = 0 eqs ( neqs , jterm ) = 1 ! operate on each item in denominator do irank = 1 , nrank call xvmlt ( op_matrix ( 1 , 1 , isgop ( isg )), & & atompos ( 1 , iatomterm ( irank , jterm )), v , 3 , 3 , 3 ) v = v + sgfract (:, isg ) !call xvadd(sgfract(1,isg),v,v,3) ! find atom call findatom2 ( v , iatom ( irank )) if ( iatom ( irank ). eq . 0 ) then write ( 6 , * ) 'Error in force_constants: atom not found' write ( 6 , * ) 'Increase the # of NN shells or check POSCAR-OUTCAR' write ( 6 , * ) 'noncorresponding vector=' , v stop endif enddo ! rotate coordinates do k = 1 , nrank do i = 1 , 3 if ( ncmp ( op_matrix ( i , ixyzterm ( k , jterm ), isgop ( isg ))). ne . 0 ) then ixyz4 ( k ) = i ixyzfirst ( k ) = i exit endif if ( i . eq . 3 ) stop 'This cannot happen!' enddo enddo ixyz4 ( nrank ) = ixyz4 ( nrank ) - 1 whileloop : do while (. true .) kloop : do k = nrank , 1 , - 1 do while (. true .) ixyz4 ( k ) = ixyz4 ( k ) + 1 if ( ixyz4 ( k ). gt . 3 ) then if ( k . eq . 1 ) then exit whileloop else cycle kloop endif endif if ( ncmp ( op_matrix ( ixyz4 ( k ), ixyzterm ( k , jterm ), isgop ( isg ))) . ne . 0 ) exit enddo do k2 = k + 1 , nrank ixyz4 ( k2 ) = ixyzfirst ( k2 ) enddo exit enddo kloop ! amplitude amp = 1 do k = 1 , nrank amp = amp * op_matrix ( ixyz4 ( k ), ixyzterm ( k , jterm ), isgop ( isg )) enddo if ( ncmp ( amp ). eq . 0 ) stop 'This cannot happen!' ! get unique denominator call unique_force_constant ( nrank , iatom , ixyz4 , iatom , ixyz ) ! look for variable iloop : do i = 1 , nterm5 do k = 1 , nrank if ( iatomterm ( k , i ). ne . iatom ( k ). or . ixyzterm ( k , i ). ne . ixyz ( k )) exit ! foundit: add in amp if ( k . eq . nrank ) then eqs ( neqs , i ) = eqs ( neqs , i ) - amp exit iloop endif enddo ! did not find it: add it and add in amp if ( i . eq . nterm5 ) then nterm5 = nterm5 + 1 if ( nterm5 . gt . maxterms ) then write ( 6 , * ) 'Warning: in force_constants: maxterms too small' , maxterms iert = iert + 1 deallocate ( ipermute , eqs , eqs2 ) return endif iatomterm ( 1 : nrank , nterm5 ) = iatom ( 1 : nrank ) ixyzterm ( 1 : nrank , nterm5 ) = ixyz ( 1 : nrank ) eqs ( neqs , nterm5 ) = eqs ( neqs , nterm5 ) - amp endif enddo iloop enddo whileloop ! next space-group operator enddo ! solve simultaneous equations call xrowop2 ( eqs , neqs , nterm5 , maxterms , maxterms ) ! find number of equations iloop2 : do i = 1 , neqs do j = 1 , nterm5 if ( ncmp ( eqs ( i , j )). ne . 0 ) exit if ( j . eq . nterm5 ) then neqs = i - 1 exit iloop2 endif enddo enddo iloop2 ! next seed jterm = jterm + 1 enddo ! put terms in order foundit = . false . eqs2 = 0 do i = 1 , nterm5 firstone = . true . do j = 1 , nterm5 if ( foundit ( j )) cycle if ( firstone ) then n = j firstone = . false . else do k = 1 , nrank if ( iatomterm ( k , j ). gt . iatomterm ( k , n )) then n = j exit else if ( iatomterm ( k , j ). lt . iatomterm ( k , n )) then exit endif if ( k . eq . nrank ) then do m = 1 , nrank if ( ixyzterm ( m , j ). gt . ixyzterm ( m , n )) then n = j exit else if ( ixyzterm ( m , j ). lt . ixyzterm ( m , n )) then exit endif enddo endif enddo endif enddo foundit ( n ) = . true . mapterms ( i ) = n eqs2 ( 1 : neqs , i ) = eqs ( 1 : neqs , n ) enddo call xrowop2 ( eqs2 , neqs , nterm5 , maxterms , maxterms ) ! find independent and dependent terms mapdep = 0 do i = 1 , neqs do j = 1 , nterm5 if ( ncmp ( eqs2 ( i , j )). ne . 0 ) then mapdep ( j ) = i exit endif if ( j . eq . nterm5 ) then write ( 6 , * ) 'Error in force_constants: zero equation' stop endif enddo enddo ! save independent terms ntermsindep = 0 do i = nterm5 , 1 , - 1 if ( mapdep ( i ). eq . 0 ) then ntermsindep = ntermsindep + 1 if ( ntermsindep . gt . maxtermsindep ) then write ( 6 , * ) 'Warning: in force_constants: maxtermsindep too small' ieri = ieri + 1 deallocate ( ipermute , eqs , eqs2 ) return !stop endif mapindepterms ( ntermsindep ) = i maptermsindep ( i ) = ntermsindep iatomtermindep ( 1 : nrank , ntermsindep ) = iatomterm ( 1 : nrank , mapterms ( i )) ixyztermindep ( 1 : nrank , ntermsindep ) = ixyzterm ( 1 : nrank , mapterms ( i )) endif enddo ! no independent terms: all terms are zero if ( ntermsindep . eq . 0 ) then if ( nterm5 . gt . maxtermszero ) then write ( 6 , * ) 'Warning: in force_constants: maxtermszero too small' ierz = ierz + 1 deallocate ( ipermute , eqs , eqs2 ) return !stop endif ntermszero = nterm5 iatomtermzero ( 1 : nrank , 1 : nterm5 ) = iatomterm ( 1 : nrank , 1 : nterm5 ) ixyztermzero ( 1 : nrank , 1 : nterm5 ) = ixyzterm ( 1 : nrank , 1 : nterm5 ) nterm5 = 0 deallocate ( eqs , eqs2 ) return endif ! look for zero terms zero = . false . do i = 1 , nterm5 if ( mapdep ( i ). ne . 0 ) then do j = 1 , ntermsindep if ( ncmp ( eqs2 ( mapdep ( i ), mapindepterms ( j ))). ne . 0 ) exit if ( j . eq . ntermsindep ) then zero ( i ) = . true . endif enddo endif enddo ! do each term m = 0 do n = nterm5 , 1 , - 1 nn = mapterms ( n ) ! find all permutations msave = m permuteloop : do i = 1 , npermute do j = 1 , nrank iatomtermall ( j , m + 1 ) = iatomterm ( ipermute ( j , i ), nn ) ixyztermall ( j , m + 1 ) = ixyzterm ( ipermute ( j , i ), nn ) enddo ! look for it do k = msave + 1 , m do j = 1 , nrank if ( iatomtermall ( j , k ). ne . iatomtermall ( j , m + 1 )) exit if ( ixyztermall ( j , k ). ne . ixyztermall ( j , m + 1 )) exit if ( j . eq . nrank ) cycle permuteloop enddo enddo ! new term: add it m = m + 1 if ( m . eq . maxterms ) then write ( 6 , * ) 'Warning: in fcs: maxterms too small' , maxterms iert = iert + 1 deallocate ( ipermute , eqs , eqs2 ) return !            call bomb endif enddo permuteloop ! find all translations msave2 = m translateloop : do i = msave + 1 , msave2 do j2 = 1 , nrank if ( iatomcell0 ( iatomtermall ( j2 , i )). eq . iatomtermall ( j2 , i )) cycle iv ( 1 : 3 ) = iatomcell ( 1 : 3 , iatomtermall ( j2 , i )) ! move atoms and identify them do k = 1 , nrank do k2 = 1 , 3 icell ( k2 ) = iatomcell ( k2 , iatomtermall ( k , i )) - iv ( k2 ) enddo call findatom ( icell , iatomcell0 ( iatomtermall ( k , i )), iatomtermall ( k , m + 1 )) if ( iatomtermall ( k , m + 1 ). eq . 0 ) then write ( 6 , * ) 'Error in force_constants: atom not found' stop endif ixyztermall ( k , m + 1 ) = ixyztermall ( k , i ) enddo ! look for it do k = msave + 1 , m do j = 1 , nrank if ( iatomtermall ( j , k ). ne . iatomtermall ( j , m + 1 )) exit if ( ixyztermall ( j , k ). ne . ixyztermall ( j , m + 1 )) exit if ( j . eq . nrank ) cycle translateloop enddo enddo ! new term: add it m = m + 1 if ( m . eq . maxterms ) then write ( 6 , * ) 'Warning: in fcs: maxterms too small' , maxterms iert = iert + 1 deallocate ( ipermute , eqs , eqs2 ) return !              call bomb endif enddo enddo translateloop ! zero terms if ( zero ( n )) then if ( ntermszero + m - msave . gt . maxtermszero ) then write ( 6 , * ) 'Warning: in force_constants: maxtermszero too small' ierz = ierz + 1 deallocate ( ipermute , eqs , eqs2 ) return !       stop endif iatomtermzero ( 1 : nrank , ntermszero + 1 : ntermszero + m - msave ) = & & iatomtermall ( 1 : nrank , msave + 1 : m ) ixyztermzero ( 1 : nrank , ntermszero + 1 : ntermszero + m - msave ) = & & ixyztermall ( 1 : nrank , msave + 1 : m ) ntermszero = ntermszero + m - msave m = msave ! independent terms else if ( mapdep ( n ). eq . 0 ) then amat ( msave + 1 : m , maptermsindep ( n )) = 1 ! dependent terms else do i = 1 , ntermsindep amat ( msave + 1 : m , i ) =- eqs2 ( mapdep ( n ), mapindepterms ( i )) enddo endif enddo nterm5 = m deallocate ( ipermute , eqs , eqs2 ) ierz = 0 iert = 0 ieri = 0 end subroutine force_constants !**************************************************************************** !! bring a force constant to a unique form: atoms subroutine unique_force_constant ( nrank , iatomin , ixyzin , iatomout , ixyzout ) ! arguments: !     nrank (input), order of derivative !     iatomin(i) (input), atom at ith location in denominator !     ixyzin(i) (input), x,y,z coordinate of atom !     iatomout(i) (output), atom at ith location in denominator !     ixyzout(i) (output), x,y,z coordinate of atom use force_constants_module implicit none integer , intent ( in ) :: nrank , iatomin ( nrank ), ixyzin ( nrank ) integer , intent ( out ) :: iatomout ( nrank ), ixyzout ( nrank ) integer k , m , iatomtemp ( nrank ), irank , iv ( 3 ), icell ( 3 ), iatom , k2 , k3 , & & iatomtemp2 ( nrank ), ixyztemp ( nrank ), ixyztemp2 ( nrank ), ixyz logical firsttime firsttime = . true . ! bring atom in each item to unit cell at origin irankloop : do irank = 1 , nrank iv ( 1 : 3 ) = iatomcell ( 1 : 3 , iatomin ( irank )) ! move atoms and identify them do k = 1 , nrank do m = 1 , 3 icell ( m ) = iatomcell ( m , iatomin ( k )) - iv ( m ) enddo call findatom ( icell , iatomcell0 ( iatomin ( k )), iatomtemp ( k )) if ( iatomtemp ( k ). eq . 0 ) then write ( 6 , * ) 'Error in force_constants: atom not found' stop endif ixyztemp ( k ) = ixyzin ( k ) ! put atoms in order do k2 = 1 , k - 1 if ( iatomtemp ( k ). lt . iatomtemp ( k2 ). or . & & ( iatomtemp ( k ). eq . iatomtemp ( k2 ). and . & & ixyztemp ( k ). lt . ixyztemp ( k2 ))) then iatom = iatomtemp ( k ) ixyz = ixyztemp ( k ) do k3 = k , k2 + 1 , - 1 iatomtemp ( k3 ) = iatomtemp ( k3 - 1 ) ixyztemp ( k3 ) = ixyztemp ( k3 - 1 ) enddo iatomtemp ( k2 ) = iatom ixyztemp ( k2 ) = ixyz exit endif enddo enddo !compared with saved term if ( firsttime ) then firsttime = . false . iatomtemp2 ( 1 : nrank ) = iatomtemp ( 1 : nrank ) ixyztemp2 ( 1 : nrank ) = ixyztemp ( 1 : nrank ) else do k = 1 , nrank if ( iatomtemp ( k ). lt . iatomtemp2 ( k )) then iatomtemp2 ( 1 : nrank ) = iatomtemp ( 1 : nrank ) ixyztemp2 ( 1 : nrank ) = ixyztemp ( 1 : nrank ) cycle irankloop else if ( iatomtemp ( k ). gt . iatomtemp2 ( k )) then cycle irankloop endif if ( k . eq . nrank ) then do m = 1 , nrank if ( ixyztemp ( m ). lt . ixyztemp2 ( m )) then iatomtemp2 ( 1 : nrank ) = iatomtemp ( 1 : nrank ) ixyztemp2 ( 1 : nrank ) = ixyztemp ( 1 : nrank ) cycle irankloop else if ( ixyztemp ( m ). gt . ixyztemp2 ( m )) then cycle irankloop endif enddo endif enddo endif enddo irankloop iatomout ( 1 : nrank ) = iatomtemp2 ( 1 : nrank ) ixyzout ( 1 : nrank ) = ixyztemp2 ( 1 : nrank ) end subroutine unique_force_constant !**************************************************************************** ! routines subroutine findatom ( icell , icell0 , iatom ) !! find atom in data base ! arguments: !     icell(i) (input), linear combination of basis vectors of the primitive !          lattice that takes us to the unit cell containing the ith atom !     icell0 (input), identity of equivalent atom in unit cell at origin !     iatom (output), location of atom in data base.  Returns zero if not found !          in data base use force_constants_module implicit none integer , intent ( in ) :: icell ( 3 ), icell0 integer , intent ( out ) :: iatom integer i , j do i = 1 , natoms if ( icell0 . ne . iatomcell0 ( i )) cycle do j = 1 , 3 if ( icell ( j ). ne . iatomcell ( j , i )) exit if ( j . eq . 3 ) then iatom = i return endif enddo enddo iatom = 0 end subroutine findatom !-------------------------------------------------------------------------------- subroutine findatom2 ( pos , iatom ) !! find atom in data base ! arguments: !     pos(i) (input), ith cartesian coordinate of atomic position !     iatom (output), location of atom in data base.  Returns zero if not found !          in data base use force_constants_module implicit none integer iatom , i , j , ncmp double precision pos ( 3 ) do i = 1 , natoms do j = 1 , 3 if ( ncmp ( atompos ( j , i ) - pos ( j )). ne . 0 ) exit if ( j . eq . 3 ) then iatom = i return endif enddo enddo iatom = 0 end subroutine findatom2 !-------------------------------------------------------------------------------- function ncmp ( x ) implicit none ! !\tCOMPARE X WITH ZERO !\tNCMP=0 IF X IS CLOSE ENOUGH TO ZERO !\tNCMP=1 OTHERWISE !\tX IS REAL ! integer ncmp real ( 8 ) x !,delta !     data delta/1.e-3/ ncmp = 0 !     if(abs(x).gt.delta)ncmp=1 if ( abs ( x ). gt . 1 d - 6 ) ncmp = 1 return end function ncmp !-------------------------------------------------------------------------------- subroutine xmatinv ( xmatin , xmatout , ier ) implicit none !! invert a 3 by 3 matrix double precision xmatin ( 3 , 3 ), xmatout ( 3 , 3 ), buffer ( 3 , 3 ), x integer indx ( 3 ), ier , n , i , j ! dimension of matrix n = 3 ! clear error flag ier = 0 do i = 1 , n do j = 1 , n xmatout ( i , j ) = 0 buffer ( i , j ) = xmatin ( i , j ) enddo xmatout ( i , i ) = 1 enddo ! decomposition call ludcmp ( buffer , n , n , indx , x ) ! singular matrix if ( x . eq . 0.0d0 ) then ier = 1 return endif ! inverse matrix do j = 1 , n call lubksb ( buffer , n , n , indx , xmatout ( 1 , j )) enddo end subroutine xmatinv !------------------------------------------------------------------ ! The following routines are from Numerical Recipes subroutine ludcmp ( a , n , np , indx , d ) implicit none integer nmax , np , n double precision tiny parameter ( nmax = 3 , tiny = 1.0d-20 ) double precision a ( np , np ), vv ( nmax ), d , aamax , dum , sum integer indx ( n ), i , j , k , imax , ncmp d = 1 do i = 1 , n aamax = 0 do j = 1 , n if ( dabs ( a ( i , j )). gt . aamax ) aamax = dabs ( a ( i , j )) enddo if ( ncmp ( aamax ). eq . 0 ) then ! singular matrix d = 0 return endif vv ( i ) = 1 / aamax enddo do j = 1 , n do i = 1 , j - 1 sum = a ( i , j ) do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) enddo a ( i , j ) = sum enddo aamax = 0 do i = j , n sum = a ( i , j ) do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) enddo a ( i , j ) = sum dum = vv ( i ) * dabs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum endif enddo if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum enddo d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ). eq . 0.0d0 ) a ( j , j ) = tiny if ( j . ne . n ) then dum = 1 / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum enddo endif enddo end subroutine ludcmp !----------------------------------------------- subroutine lubksb ( a , n , np , indx , b ) implicit none integer n , np double precision a ( np , np ), b ( n ), sum integer indx ( n ), ii , i , j , ll ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) enddo else if ( sum . ne . 0.0d0 ) then ii = i endif b ( i ) = sum enddo do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) enddo endif b ( i ) = sum / a ( i , i ) enddo end subroutine lubksb !------------------------------------------------------------------------------ subroutine xmatmlt ( x1 , x2 , x3 , nrow1 , ncol1 , ncol2 , nr1 , nr2 , nr3 ) !! multiply two real matrices, x3=x1*x2 ! double precision version ! arguments: !     x1,x2 (input), first and second matrix !     x3 (output), product x1*x2 !     nrow1 (input), number of rows in x1, also the number of rows in x3 !     ncol1 (input), number of columns in x1, also the number of !          rows in x2 !     ncol2 (input), number of columns in x2, also the number of !          columns in x3 !     nr1 (input), number of rows in the physical array x1 !     nr2 (input), number of rows in the physical array x2 !     nr3 (input), number of rows in the physical array x3 implicit none integer i , j , k , nrow1 , ncol1 , ncol2 , nr1 , nr2 , nr3 double precision x1 ( nr1 , ncol1 ), x2 ( nr2 , ncol2 ), x3 ( nr3 , ncol2 ) real ( 8 ), allocatable :: x (:,:) allocate ( x ( nrow1 , ncol2 )) do i = 1 , ncol2 do j = 1 , nrow1 x ( j , i ) = 0 do k = 1 , ncol1 x ( j , i ) = x ( j , i ) + x1 ( j , k ) * x2 ( k , i ) enddo enddo enddo do i = 1 , ncol2 do j = 1 , nrow1 x3 ( j , i ) = x ( j , i ) enddo enddo deallocate ( x ) end subroutine xmatmlt !------------------------------------------------------------------------------- subroutine xvmlt ( x , v1 , v2 , nrow , ncol , nr ) !! multiply a double precision vector by a double precision matrix, v2=x*v1 ! arguments: !     x (input), matrix !     v1 (input), vector !     v2 (output), product x*v1 !     nrow (input), number of rows in x, also the number of rows in v2 !     ncol (input), number of columns in x, also the number of rows in v1 !     nr (input), number of rows in the physical array x implicit none integer nrow , ncol , nr , i , j double precision x ( nr , ncol ), v1 ( ncol ), v2 ( nrow ) real ( 8 ), allocatable :: v (:) allocate ( v ( nrow )) do i = 1 , nrow v ( i ) = 0 do j = 1 , ncol v ( i ) = v ( i ) + x ( i , j ) * v1 ( j ) enddo enddo v2 ( 1 : nrow ) = v ( 1 : nrow ) deallocate ( v ) end subroutine xvmlt !------------------------------------------------------------------------------ !! bring a point into the unit cell at the origin subroutine unitcell ( cart_to_prim , prim_to_cart , v1 , v2 ) implicit none double precision cart_to_prim ( 3 , 3 ), prim_to_cart ( 3 , 3 ), v1 ( 3 ), & & v2 ( 3 ), buff ( 3 ) integer i , ncmp ! change coordinates of point to linear combination of basis vectors of the ! primitive lattice call xmatmlt ( cart_to_prim , v1 , buff , 3 , 3 , 1 , 3 , 3 , 3 ) ! in the unit cell at the origin, the coefficient must be greater than or ! equal to zero and less than one. do i = 1 , 3 do while ( buff ( i ). gt . 1.0d0 . or . ncmp ( buff ( i ) - 1 ). eq . 0 ) buff ( i ) = buff ( i ) - 1 enddo do while ( buff ( i ). lt . 0.0d0 . and . ncmp ( buff ( i )). ne . 0 ) buff ( i ) = buff ( i ) + 1 enddo enddo ! return to cartesian coordinates call xmatmlt ( prim_to_cart , buff , v2 , 3 , 3 , 1 , 3 , 3 , 3 ) end subroutine unitcell !---------------------------------------------------------------------------- subroutine dlatmat2 ( cart , eps , nmatrices , matrices ) !! find symmetry matrices for a given lattice ! arguments: !     cart(i,j) (input), ith cartesian component of jth basis vector !     eps (input), tolerance for length !     nmatrices (output), number of matrices !     matrices(i,j,k) (output), kth matrix implicit none integer nmax parameter ( nmax = 400 ) real ( 8 ), intent ( in ) :: cart ( 3 , 3 ), eps integer , intent ( out ) :: nmatrices , matrices ( 3 , 3 , 48 ) integer n , i , j , j1 , j2 , j3 , k , m , i1 , i2 , i3 , nshort ( 3 ), ndet , itrans ( 3 , 3 ), & & ichoose ( 3 ), ishort ( 3 , nmax , 3 ) real ( 8 ) vshort ( 3 , nmax , 3 ), v ( 3 ), xmax , vlength , x , d , abc ( 3 , 3 ), dshort ( nmax , 3 ) logical foundone , tried ( 48 , 48 ) ! some initialization dshort = 0 ishort = 0 vshort = 0 nshort = 0 do i = 1 , 3 abc ( i , i ) = vlength ( 3 , cart ( 1 , i )) enddo do i = 2 , 3 do j = 1 , i - 1 call xvsub ( cart ( 1 , i ), cart ( 1 , j ), v , 3 ) abc ( i , j ) = vlength ( 3 , v ) abc ( j , i ) = abc ( i , j ) enddo enddo i = 0 foundone = . true . ! longest lattice parameter xmax = dmax1 ( abc ( 1 , 1 ), abc ( 2 , 2 ), abc ( 3 , 3 )) + eps ! try each shell until every vector in a shell is longer than the longest ! lattice parameter do while ( foundone ) i = i + 1 foundone = . false . ! find all lattice vectors in shell do j1 =- i , i do j2 =- i , i do j3 =- i , i if ( iabs ( j1 ). eq . i . or . iabs ( j2 ). eq . i . or . iabs ( j3 ). eq . i ) then ! length of lattice vector v = 0 do k = 1 , 3 v ( k ) = v ( k ) + j1 * cart ( k , 1 ) v ( k ) = v ( k ) + j2 * cart ( k , 2 ) v ( k ) = v ( k ) + j3 * cart ( k , 3 ) enddo d = vlength ( 3 , v ) ! if shorter than longest lattice parameter, then do next shell too if ( d . lt . xmax ) foundone = . true . ! check each lattice parameter a,b,c do k = 1 , 3 ! equal to length of lattice parameter to within tolerance if ( dabs ( d - abc ( k , k )). lt . eps ) then ! count them nshort ( k ) = nshort ( k ) + 1 if ( nshort ( k ). gt . nmax ) then write ( 6 , * ) 'Error in dlatmat:  nmax too small' call bomb endif ! length dshort ( nshort ( k ), k ) = d ! dimensionless coordinates ishort ( 1 , nshort ( k ), k ) = j1 ishort ( 2 , nshort ( k ), k ) = j2 ishort ( 3 , nshort ( k ), k ) = j3 ! cartesian coordinates vshort ( 1 , nshort ( k ), k ) = v ( 1 ) vshort ( 2 , nshort ( k ), k ) = v ( 2 ) vshort ( 3 , nshort ( k ), k ) = v ( 3 ) endif enddo ! next vector in shell endif enddo enddo enddo ! next shell enddo ! try mappings of basis vectors onto vectors the \"same\" length nmatrices = 1 do i1 = 1 , nshort ( 1 ) ichoose ( 1 ) = i1 itrans ( 1 : 3 , 1 ) = ishort ( 1 : 3 , i1 , 1 ) do i2 = 1 , nshort ( 2 ) ichoose ( 2 ) = i2 itrans ( 1 : 3 , 2 ) = ishort ( 1 : 3 , i2 , 2 ) i3loop : do i3 = 1 , nshort ( 3 ) ichoose ( 3 ) = i3 itrans ( 1 : 3 , 3 ) = ishort ( 1 : 3 , i3 , 3 ) ! determinant of the transformation matrix must be equal to 1 if ( iabs ( ndet ( itrans )). ne . 1 ) cycle ! lengths of differences of lattice vectors must match to within tolerance do i = 2 , 3 do j = 1 , i - 1 call xvsub ( vshort ( 1 , ichoose ( i ), i ), vshort ( 1 , ichoose ( j ), j ), v , 3 ) x = vlength ( 3 , v ) if ( dabs ( x - abc ( i , j )). gt . eps ) cycle i3loop enddo enddo ! found a transformation:  count them and save it ! if this is the identity op, just put it into the first matrix where we ! have reserved a place for it if ( itrans ( 1 , 1 ) + itrans ( 2 , 2 ) + itrans ( 3 , 3 ). eq . 3 ) then matrices ( 1 : 3 , 1 : 3 , 1 ) = itrans ( 1 : 3 , 1 : 3 ) else nmatrices = nmatrices + 1 if ( nmatrices . gt . 48 ) then write ( 6 , * ) 'Error in dlatmat2: more than 48 point operators' call bomb endif matrices ( 1 : 3 , 1 : 3 , nmatrices ) = itrans ( 1 : 3 , 1 : 3 ) endif ! next mapping enddo i3loop enddo enddo ! find any additional matrices by multiplication foundone = . true . tried = . false . do while ( foundone ) foundone = . false . do i = 1 , nmatrices do j = 1 , nmatrices if (. not . tried ( i , j )) then tried ( i , j ) = . true . !             call matmlt(matrices(1,1,i),matrices(1,1,j),itrans) itrans = matmul ( matrices (:,:, i ), matrices (:,:, j )) kloop : do k = 1 , nmatrices mloop : do m = 1 , 3 do n = 1 , 3 if ( matrices ( n , m , k ). ne . itrans ( n , m )) exit mloop if ( m . eq . 3. and . n . eq . 3 ) exit kloop enddo enddo mloop if ( k . eq . nmatrices ) then foundone = . true . nmatrices = nmatrices + 1 if ( nmatrices . gt . 48 ) then write ( 6 , * ) 'Error in dlatmat2: ' // & & 'more than 48 point operators' call bomb endif matrices ( 1 : 3 , 1 : 3 , nmatrices ) = itrans ( 1 : 3 , 1 : 3 ) endif enddo kloop endif enddo enddo enddo end subroutine dlatmat2 !-------------------------------------------------------------------------------- subroutine xvsub ( v1 , v2 , v3 , nrow ) !! subtract two real vectors: v3=v1-v2 ! double precision version ! arguments: !     v1,v2 (input), vectors !     v3 (output), vector v1-v2 !     nrow (input), number of rows in each vector implicit none integer i , nrow double precision v1 ( nrow ), v2 ( nrow ), v3 ( nrow ) do i = 1 , nrow v3 ( i ) = v1 ( i ) - v2 ( i ) enddo end subroutine xvsub !------------------------------------------------------------------------------ subroutine xvadd ( v1 , v2 , v3 , nrow ) !! add two real vectors: v3=v1+v2 ! double precision version ! arguments: !     v1,v2 (input), vectors !     v3 (output), vector v1+v2 !     nrow (input), number of rows in each vector implicit none integer i , nrow double precision v1 ( nrow ), v2 ( nrow ), v3 ( nrow ) do i = 1 , nrow v3 ( i ) = v1 ( i ) + v2 ( i ) enddo end subroutine xvadd !------------------------------------------------------------------------------- function vlength ( n , v ) implicit none integer n double precision v ( n ), vlength , x integer i x = 0 do i = 1 , n x = x + v ( i ) ** 2 enddo vlength = dsqrt ( x ) end function vlength !------------------------------------------------------------------------------- subroutine bomb implicit none write ( 6 , '(a)' ) 'This program has bombed.' write ( 6 , '(a)' ) 'exit' stop end subroutine bomb !------------------------------------------------------------------------------ function ndet ( mat ) implicit none ! !\tFIND THE DETERMINANT OF A 3X3 MATRIX MAT ! integer ndet , mat ( 3 , 3 ) ndet = mat ( 1 , 1 ) * ( mat ( 2 , 2 ) * mat ( 3 , 3 ) - mat ( 2 , 3 ) * mat ( 3 , 2 )) & & - mat ( 1 , 2 ) * ( mat ( 2 , 1 ) * mat ( 3 , 3 ) - mat ( 2 , 3 ) * mat ( 3 , 1 )) & & + mat ( 1 , 3 ) * ( mat ( 2 , 1 ) * mat ( 3 , 2 ) - mat ( 2 , 2 ) * mat ( 3 , 1 )) end function ndet !------------------------------------------------------------------------------ subroutine permutations ( n , ipermutations , nr , nc ) ! find all permutations of n objects ! arguments: !     n (input), number of objects !     ipermutations(i,j) (output), object in ith location of jth permutation !     nr (input), number of rows in ipermutations !     nc (input), number of columns in ipermutations implicit none integer nr , nc integer n , ipermutations ( nr , nc ), ip ( 10 ), np , ifactorial , i , j , k , m !,mm,nexc !,ip2(10) logical used ( 10 ) ! check for valid input if ( n . gt . 10 ) then write ( 6 , * ) 'error in permutations: n is too large' call bomb endif if ( n . gt . nr ) then write ( 6 , * ) 'error in permutations: nr is too small' call bomb endif np = ifactorial ( n ) if ( np . gt . nc ) then write ( 6 , * ) 'error in permutations: nc is too small' call bomb endif ! first permutation do i = 1 , n ip ( i ) = i enddo ipermutations ( 1 : n , 1 ) = ip ( 1 : n ) ! done if only one object if ( n . eq . 1 ) return ! mark which objects are used in the first n-1 locations used ( 1 : n - 1 ) = . true . used ( n ) = . false . ! count permutations np = 1 ! try changing the object in a location, starting at location n-1 loop1 : do while ( np . lt . nc ) do i = n - 1 , 1 , - 1 ! moving this object: not at this location anymore used ( ip ( i )) = . false . ! look for a vacant location do j = ip ( i ) + 1 , n ! found one if (. not . used ( j )) then ! put object in that location ip ( i ) = j used ( j ) = . true . ! put the remaining objects in the remaining locations do k = i + 1 , n do m = 1 , n if (. not . used ( m )) then ip ( k ) = m if ( k . ne . n ) used ( m ) = . true . exit endif if ( m . eq . n ) then write ( * , * ) 'ERROR in rearranging: m=n ' , m call bomb endif enddo enddo ! count permutations and save it np = np + 1 ipermutations ( 1 : n , np ) = ip ( 1 : n ) cycle loop1 !goto 1 endif enddo enddo enddo loop1 end subroutine permutations !------------------------------------------------------------------------------- ! factorial:  ifactorial = n! function ifactorial ( n ) implicit none integer ifactorial , n , i , m if ( n . lt . 0 ) then call bomb else if ( n . eq . 0 ) then ifactorial = 1 else m = 1 do i = 2 , n m = m * i enddo ifactorial = m endif end function ifactorial !------------------------------------------------------------------------------- subroutine xrowop2 ( zna , nrow , ncol , nnrow , nncol ) implicit none ! !\tDO ROW OPERATIONS ON MATRIX ZNA TO BRING IT TO UPPER TRIANGULAR FORM !\tDOUBLE PRECISION NUMBERS ! integer nnrow , nncol double precision zna ( nnrow , nncol ), zntemp integer nrow , ncol , nout , j , k , l , ncmp ! !\tTRANSFORM MATRIX BY ROWS nout = 0 do j = 1 , nrow 5 if ( j + nout . gt . ncol ) return !\tPUT NON-ZERO ELEMENTS ON DIAGONAL if ( ncmp ( zna ( j , j + nout )). ne . 0 ) goto 4 do k = j + 1 , nrow if ( ncmp ( zna ( k , j + nout )). ne . 0 ) goto 3 enddo !\tIF COLUMN HAS ALL ZEROES, GO TO NEXT COLUMN nout = nout + 1 goto 5 !\tINTERCHANGE ROWS 3 do l = 1 , ncol zntemp = zna ( j , l ) zna ( j , l ) = zna ( k , l ) zna ( k , l ) = zntemp enddo !\tNORMALIZE ELEMENTS IN ROW 4 zntemp = zna ( j , j + nout ) do k = j + nout , ncol zna ( j , k ) = zna ( j , k ) / zntemp enddo !\tREDUCE ALL OTHER ROWS do k = 1 , nrow if ( k . eq . j ) cycle if ( ncmp ( zna ( k , j + nout )). eq . 0 ) cycle do l = 1 , ncol if ( l . eq . j + nout ) cycle zna ( k , l ) = zna ( k , l ) - zna ( j , l ) * zna ( k , j + nout ) enddo zna ( k , j + nout ) = 0. enddo enddo end subroutine xrowop2 !------------------------------------------------------------------------------- subroutine getstar ( kvec , primlatt , narms , kvecstar , kvecop ) ! find atom in data base ! arguments: !     kvec(i) (input), ith dimensionless component of k vector !     narms (output), number of star vectors associated with kvec !     kvecstar(3,1:narms), all the stars of kvec !     kvecop(i), the symmetry operation number for the star vecor i use force_constants_module implicit none integer , intent ( out ) :: narms , kvecop ( 48 ) real ( 8 ), intent ( in ) :: kvec ( 3 ), primlatt ( 3 , 3 ) real ( 8 ), intent ( out ) :: kvecstar ( 3 , 48 ) integer i , j , k , n , ncmp real ( 8 ) v ( 3 ), v2 ( 3 ), v3 ( 3 ), kvecstarp ( 3 , 48 ) narms = 0 !      print*,'lattpgcount=',lattpgcount iloop : do i = 1 , lattpgcount ! apply symmetry operation to k to get v=kstar call xvmlt ( op_kmatrix ( 1 , 1 , i ), kvec , v , 3 , 3 , 3 ) ! find the reduced coordinates of v and store in v2 call xmatmlt ( v , primlatt , v2 , 1 , 3 , 3 , 1 , 3 , 1 ) ! now check if v2 - any_previous_v2 is integer (differ by a G vector) ! if so, skip; else store this v as a new star vector do j = 1 , narms ! subtract previous_v2(=kvecstarp) from v2; result is v3 call xvsub ( v2 , kvecstarp ( 1 , j ), v3 , 3 ) do k = 1 , 3 n = nint ( v3 ( k )) if ( ncmp ( v3 ( k ) - n ). ne . 0 ) exit if ( k . eq . 3 ) cycle iloop ! goto next sym_op iff v3=integer enddo enddo narms = narms + 1 kvecstar ( 1 : 3 , narms ) = v ( 1 : 3 ) kvecstarp ( 1 : 3 , narms ) = v2 ( 1 : 3 ) kvecop ( narms ) = i enddo iloop end subroutine getstar !**************************************************************************** !! get force constants for a given rank out to a given nearest neighbor shell subroutine collect_force_constants ( nrank , nshell , ngroups , & & ntermsindep , iatomtermindep , ixyztermindep , nterm6 , & & iatomterm , ixyzterm , amat , ntermszero , iatomtermzero , & & ixyztermzero , maxrank , maxterms , maxtermsindep , maxtermszero , & & maxgroups , ierz , iert , ieri , ierg ) ! arguments: !     nrank (input), order or derivative !     nshell (input), shell of nearest-neighbor atoms to be included !     ngroups (output), number of groups of terms.  Within each group, the !          terms are related by symmetry. !     For the ith group: !     ntermsindep(i) (output), number of independent terms !     iatomtermindep(k,j,i) (output), atom at kth location in denominator of !          jth independent term !     ixyztermindep(k,j,i) (output), coordinate at kth location in denomonitor !          of jth independent term !     nterm6(i) (output), total number of terms !     iatomterm(k,j,i) (output), atom at kth location in denominators of !          jth term !     ixyzterm(k,j,i) (output), coordinate at kth location in denomonitor of !          jth term !     amat(k,j,i) (output), coefficient of jth independent term in equation !          for kth term !     ntermszero (output), number of zero terms !     iatomtermzero(k,j) (output), atom at kth location in denominator of !          jth zero term !     ixyztermzero(k,j) (output), coordinate at kth location in denomonitor !          of jth zero term !     maxrank (input), number of rows in arrays iatomtermindep, ixyztermindep, !          iatomterm, and ixyzterm !     maxterms (input), number of rows in array amat and number of columns !          in arrays iatomterm and ixyzterm !     maxtermsindep (input), number of columns !          in arrays amat, iatomtermindep, and ixyztermindep !     maxtermszero (input), number of columns !          in arrays iatomtermzero and ixyztermzero !     maxgroups (input), maximum number of groups use force_constants_module implicit none integer , intent ( in ) :: nrank , maxrank , maxterms , maxtermsindep , maxgroups , & & maxtermszero , nshell ( natoms0 ) integer , intent ( out ) :: ierz , iert , ieri , ierg , ngroups , ntermszero , nterm6 ( maxgroups ), & & ntermsindep ( maxgroups ), iatomtermindep ( maxrank , maxterms , maxgroups ), & & ixyztermindep ( maxrank , maxterms , maxgroups ), & & iatomterm ( maxrank , maxterms , maxgroups ), ixyzterm ( maxrank , maxterms , maxgroups ), & & iatomtermzero ( maxrank , maxtermszero ), ixyztermzero ( maxrank , maxtermszero ) real ( 8 ), intent ( out ) :: amat ( maxterms , maxtermsindep , maxgroups ) integer i , j , k , m , n , ncount , iatom , iatom0 , iatomd ( nrank ), ixyz , ngroupsave , & & ixyzd ( nrank ), icell ( 3 ), iatomd2 ( nrank ), ixyzd2 ( nrank ), ntermszerosave logical firsttime ierz = 0 ; iert = 0 ; ierg = 0 ; ieri = 0 write ( * , * ) ' INPUTS OF COLLECT_FORCE_CONSTANTS ' write ( * , * ) ' nrank=' , nrank do i = 1 , natoms0 write ( * , * ) ' iatom,nshell(iatom)=' , i , nshell ( i ) enddo write ( * , * ) ' mxrnk,mxtrm,mxtrmindp=' , maxrank , maxterms , maxtermsindep write ( * , * ) ' maxtermszero,maxgroups=' , maxtermszero , maxgroups ! check if input values are valid if ( nrank . gt . maxrank ) then write ( 6 , * ) 'Error in collect_force_constants: nrank > maxrank' stop endif ncount = 0 ngroups = 0 amat = 0 ntermszero = 0 ! do each atom in unit cell iatom0loop : do iatom0 = 1 , natoms0 ! find first nearest neighbor in list do iatom = 1 , natoms if ( iatomneighbor ( iatom0 , iatom ). le . nshell ( iatom0 )) exit if ( iatom . eq . natoms ) then write ( 6 , * ) 'Error in collect_force_constants: first ' & & // 'nearest neighbor not found' stop endif enddo ! try each atom for each position in denominator ! begin with first nearest neighbor iatomd ( 1 : nrank ) = iatom iatomd ( nrank ) = iatom - 1 iatomd ( 1 ) = iatom0 firsttime = . true . nextatomloop : do while (. true .) ! next set of atoms if ( firsttime ) then firsttime = . false . else if ( nrank . eq . 1 ) exit nextatomloop endif ! try each position in denominator iloop : do i = nrank , 2 , - 1 ! try each atom in that position jloop : do j = iatomd ( i ) + 1 , natoms ! nearest neighbor to atom in cell at origin? if ( iatomneighbor ( iatom0 , j ). le . nshell ( iatom0 )) then ! nearest neighbor to all other atoms in denominator? do k = 2 , i - 1 do m = 1 , 3 icell ( m ) = iatomcell ( m , iatomd ( k )) - iatomcell ( m , j ) enddo call findatom ( icell , iatomcell0 ( iatomd ( k )), m ) if ( m . eq . 0 ) cycle jloop if ( iatomneighbor ( iatomcell0 ( j ), m ). gt . nshell ( iatom0 )) cycle jloop enddo ! yes: put atom in denominator and get terms iatomd ( i : nrank ) = j exit iloop endif enddo jloop ! done: try next atom in cell at origin if ( i . eq . 2 ) cycle iatom0loop enddo iloop ! check if found yet ixyzd = 1 call unique_force_constant ( nrank , iatomd , ixyzd , iatomd2 , ixyzd2 ) do k = 1 , ngroups iloop2 : do i = 1 , nterm6 ( k ) do j = 1 , nrank if ( iatomterm ( j , i , k ). ne . iatomd2 ( j )) cycle iloop2 enddo ! found it: try next set of atoms cycle nextatomloop enddo iloop2 enddo iloop4 : do i = 1 , ntermszero do j = 1 , nrank if ( iatomtermzero ( j , i ). ne . iatomd2 ( j )) cycle iloop4 enddo ! found it: try next set of atoms cycle nextatomloop enddo iloop4 ! did not find it: generate terms ! all possible sets of coordinates ngroupsave = ngroups ntermszerosave = ntermszero ixyzloop : do ixyz = 1 , 3 ** nrank m = ixyz - 1 do i = 1 , nrank ixyzd ( i ) = mod ( m , 3 ) + 1 m = m / 3 enddo ! check if found yet call unique_force_constant ( nrank , iatomd , ixyzd , iatomd2 , ixyzd2 ) do k = ngroupsave + 1 , ngroups iloop3 : do i = 1 , nterm6 ( k ) do j = 1 , nrank if ( iatomterm ( j , i , k ). ne . iatomd2 ( j )) cycle iloop3 if ( ixyzterm ( j , i , k ). ne . ixyzd2 ( j )) cycle iloop3 enddo ! found it: try next set of coordinates cycle ixyzloop enddo iloop3 enddo iloop5 : do i = ntermszerosave + 1 , ntermszero do j = 1 , nrank if ( iatomtermzero ( j , i ). ne . iatomd2 ( j )) cycle iloop5 if ( ixyztermzero ( j , i ). ne . ixyzd2 ( j )) cycle iloop5 enddo ! found it: try next set of coordinates cycle ixyzloop enddo iloop5 ! did not find it: generate terms ngroups = ngroups + 1 if ( ngroups . ge . maxgroups ) then write ( 6 , * ) ' maxgroups is too small ' , maxgroups ierg = ierg + 1 return endif call force_constants ( nrank , iatomd2 , ixyzd2 , & & ntermsindep ( ngroups ), iatomtermindep ( 1 , 1 , ngroups ), & & ixyztermindep ( 1 , 1 , ngroups ), nterm6 ( ngroups ), & & iatomterm ( 1 , 1 , ngroups ), ixyzterm ( 1 , 1 , ngroups ), & & amat ( 1 , 1 , ngroups ), n , iatomtermzero ( 1 , ntermszero + 1 ), & & ixyztermzero ( 1 , ntermszero + 1 ), maxrank , maxterms , & & maxtermsindep , maxtermszero - ntermszero , ierz , iert , ieri ) if ( ierz . ne . 0 ) then write ( * , * ) ' maxtermszero is too small' , maxtermszero , ierz return endif if ( iert . ne . 0 ) then write ( * , * ) ' maxterms is too small' , maxterms , iert return endif if ( ieri . ne . 0 ) then write ( * , * ) ' maxtermsindep is too small' , maxtermsindep , ieri return endif ntermszero = ntermszero + n ! no nonzero terms in group if ( nterm6 ( ngroups ). eq . 0 ) then ngroups = ngroups - 1 ncount = ncount + 1 endif ! next set of coordinates enddo ixyzloop ! next set of atoms enddo nextatomloop enddo iatom0loop write ( * , * ) ' ngroups=' , ngroups write ( * , 3 ) ' ntermsindep      (maxgroups)=' , ntermsindep ( 1 : ngroups ) write ( * , 3 ) ' nterm6           (maxgroups)=' , nterm6 ( 1 : ngroups ) write ( * , 3 ) ' iatomtrmindep(rnk,1,ngroups)=' , iatomtermindep ( nrank , 1 , 1 : ngroups ) write ( * , 3 ) ' ixyztermindep(rnk,1,ngroups)=' , ixyztermindep ( nrank , 1 , 1 : ngroups ) write ( * , 3 ) ' iatomterm    (rnk,1,ngroups)=' , iatomterm ( nrank , 1 , 1 : ngroups ) write ( * , 3 ) ' ixyzterm     (rnk,1,ngroups)=' , ixyzterm ( nrank , 1 , 1 : ngroups ) ierz = 0 ; iert = 0 ; ieri = 0 ; ierg = 0 3 format ( a , 99 ( i4 )) end subroutine collect_force_constants !****************************************************************************","tags":"","loc":"sourcefile/force_constants.f90.html"},{"title":"ios.f90 – Example Project","text":"This file depends on sourcefile~~ios.f90~~EfferentGraph sourcefile~ios.f90 ios.f90 sourcefile~modules9.f90 modules9.f90 sourcefile~ios.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Subroutines read_input read_crystal check_input_poscar_consistency check_input_poscar_consistency_new read_force_position_data write_independent_fcs write_independent_fcs_2 write_neighbors write_output_fc2 read_output_fc2 write_output_fc read_fcs_2 calculate_and_write_displacements identify_atoms_in_supercell ustring pos_out_consistency write_correspondance write_correspondance2 warn write_lat_fc Source Code ios.f90 Source Code !=========================================================== subroutine read_input ! reads the param.inp file containing info on the atom types masses ! and coordinates within the primitive cell use ios use params use lattice use force_constants_module use atoms_force_constants use svd_stuff implicit none integer i , counter , label real ( 8 ) scal open ( uparams , file = 'params.inp' , status = 'old' ) read ( uparams , * ) latticeparameters ! (a,b,c,alpha,beta,gamma) read ( uparams , * ) primitivelattice ! prim latt vectors in terms of conventional above read ( uparams , * ) scal ! scale factor for lattparams is read from params.inp read ( uparams , * ) maxneighbors ! # of neigr-shells to use for each rank read ( uparams , * ) include_fc ! if=0 do not include this rank ! read(uparams,*) nshells , radius      ! # of neigr-shells to use for each rank ! read(uparams,*) maxterms      ! max # of terms for each rank ! read(uparams,*) maxtermsindep ! max # of independent terms for each rank read ( uparams , * ) itrans , irot , ihuang , enforce_inv ! translational and rotational invce flags (include if=1) read ( uparams , * ) tolerance , margin ! tolerance for equating coords, margin for eliminating FCs read ( uparams , * ) svdcut ! cutoff for smallest \"eigenvalue\" w to be included read ( uparams , * ) fdfiles , verbose ! number of force-displacement data files read ( uparams , * ) natom_type ! # of different elements present in prim cell ! allocate(natom(natom_type)) call allocate_mass ( natom_type ) read ( uparams , * ) ( mas ( i ), i = 1 , natom_type ) ! in the same order as in POTCAR read ( uparams , * ) ( atname ( i ), i = 1 , natom_type ) ! in the same order as in POTCAR read ( uparams , * ) natoms0 ! # of atoms in primitive cell read ( uparams , * ) nshells ( 1 , 1 : natoms0 ) read ( uparams , * ) nshells ( 2 , 1 : natoms0 ) read ( uparams , * ) nshells ( 3 , 1 : natoms0 ) read ( uparams , * ) nshells ( 4 , 1 : natoms0 ) write ( ulog , * ) svdcut , '    cutoff for smallest eigenvalue w to be included' write ( ulog , * ) tolerance , '   tolerance for equating two coordinates ' write ( ulog , * ) include_fc , '  which ranks of FCs to include ' write ( ulog , * ) nshells ( 1 ,:), '  how many shells to include for each rank ' write ( ulog , * ) nshells ( 2 ,:), '  how many shells to include for each rank ' write ( ulog , * ) nshells ( 3 ,:), '  how many shells to include for each rank ' write ( ulog , * ) nshells ( 4 ,:), '  how many shells to include for each rank ' write ( ulog , * ) itrans , irot , ihuang , enforce_inv , '  transl, rot and Huang invce, enforcing inv' latticeparameters ( 1 : 3 ) = latticeparameters ( 1 : 3 ) * scal call allocate_primcell ( natoms0 ) ! indices of atoms in primitive cell must be same order as in POSCAR counter = 0 natom = 0 do i = 1 , natoms0 ! positions here must be D format in conventional cell for use by fcs_init read ( uparams , * ) label , atom_type ( label ), atompos0 (:, label ) if ( i . ne . label ) then print * , ' positions must be sorted according to the labels ' , i , label write ( ulog , * ) ' READ_INPUT: positions must be sorted like labels ' , i , label write ( ulog , * ) ' Check atomic coordinates in primitive cell' stop endif atom0 ( i )% name = atname ( atom_type ( label )) atom0 ( i )% at_type = atom_type ( label ) atom0 ( i )% mass = mas ( atom_type ( label )) !   atom0(i)%nshells  ! actual no of neighbors shells < maxneighbors !   atom0(i)%shells   ! what is inside each shell ! Make sure the label tau is the same as the atom index in the array atompos ! this is useless because natom(:) is read from POSCAR if ( atom_type ( label ). eq . counter ) then natom ( atom_type ( label )) = natom ( atom_type ( label )) + 1 else natom ( atom_type ( label )) = 1 endif counter = atom_type ( label ) enddo close ( uparams ) do i = 1 , 4 !   if (nshells(i) .gt. maxneighbors) then if ( maxval ( nshells ( i ,:)) . gt . maxneighbors ) then write ( ulog , * ) ' READ_INPUT: nshell> maxneighbors for rank=' , & & i , maxval ( nshells ( i ,:)), maxneighbors write ( ulog , * ) ' Increase maxneighbors or choose a smaller # of shells' stop endif enddo end subroutine read_input !=========================================================== subroutine read_crystal ( poscar ) ! the following reads the POSCAR file that is used by VASP use ios use params use lattice use geometry use atoms_force_constants implicit none character line * 90 , poscar * ( * ) integer i real ( 8 ) om , latt_const , a , b , c , om0 type ( vector ) pos logical exst n1min = 100000 ; n2min = 100000 ; n3min = 100000 n1max =- 100000 ; n2max =- 100000 ; n3max =- 100000 ! open (uposcar,file='POSCAR',status='old') inquire ( file = poscar , exist = exst ) if ( exst ) then open ( uposcar , file = poscar , status = 'old' ) else write ( ulog , * ) ' poscar file ' , poscar , ' does not exist; check your files location and run again' stop endif read ( uposcar , '(a)' ) line write ( ulog , * ) ' VASP job title' write ( ulog , '(a)' ) line ! this is for the super-cell and has nothing to do with the one in params.inp ! which is for the primitive cell read ( uposcar , * ) lattice_parameter read ( uposcar , * ) r1 read ( uposcar , * ) r2 read ( uposcar , * ) r3 if ( lattice_parameter . lt . 0 ) then ! it is the -volume of the cell volume_r = - lattice_parameter ! need to find the volume(r1,r2,r3) for scaling call calculate_volume ( r1 , r2 , r3 , om ) latt_const = ( volume_r / om ) ** ( 1. / 3. ) else latt_const = lattice_parameter endif r1 = latt_const * r1 ; r2 = latt_const * r2 ; r3 = latt_const * r3 box ( 1 ) = length ( r1 ); box ( 2 ) = length ( r2 ); box ( 3 ) = length ( r3 ) call calculate_volume ( r1 , r2 , r3 , om ) call calculate_volume ( r01 , r02 , r03 , om0 ) call write_out ( ulog , ' Volume of supercell ' , om ) call write_out ( ulog , ' Volume of primicell ' , om0 ) write ( ulog , * ) ' box size in 1st direction=' , box ( 1 ) write ( ulog , * ) ' box size in 2nd direction=' , box ( 2 ) write ( ulog , * ) ' box size in 3rd direction=' , box ( 3 ) ! number of atoms participating in MD, read ( uposcar , * )( natom ( i ), i = 1 , natom_type ) natom_super_cell = sum ( natom ) if (. not . ( natom_super_cell * om0 / ( natoms0 * om ) . myeq . 1 d0 ) ) then write ( ulog , * ) ' supercell inconsistency; check input coordinates again' write ( ulog , * ) ' natoms0, om0=' , natoms0 , om0 write ( ulog , * ) ' natom_sc, om=' , natom_super_cell , om stop endif write ( ulog , * ) \" number of different elements and number of atoms of each type\" write ( ulog , * ) natom_type ,( natom ( i ), i = 1 , natom_type ) write ( ulog , * ) \" total number of atoms in the supercell= \" , natom_super_cell write ( ulog , * ) \"translation vectors of the supercell are\" write ( ulog , 4 ) r1 write ( ulog , 4 ) r2 write ( ulog , 4 ) r3 if ( allocated ( atom_sc )) then deallocate ( atom_sc ) endif allocate ( atom_sc ( natom_super_cell )) ! read equilibrium positions from POSCAR file and write in logfile ------------ ! read(uposcar,'(a)') line read ( uposcar , * ) line if ( line ( 1 : 1 ). eq . 's' . or . line ( 1 : 1 ). eq . 'S' ) then !   read(uposcar,'(a)') line read ( uposcar , * ) line endif if ( line ( 1 : 1 ). eq . 'd' . or . line ( 1 : 1 ). eq . 'D' ) then do i = 1 , natom_super_cell read ( uposcar , * ) a , b , c atom_sc ( i )% equilibrium_pos = a * r1 + b * r2 + c * r3 enddo elseif ( line ( 1 : 1 ). eq . 'c' . or . line ( 1 : 1 ). eq . 'C' ) then do i = 1 , natom_super_cell read ( uposcar , * ) pos atom_sc ( i )% equilibrium_pos = latt_const * pos ! pos enddo !   if(scale.ne.1)write(ulog,*)'WARNING: read cartesian positions are multiplied by scal!' else write ( ulog , * ) 'POSCAR: positions are not in direct or cartesian coordinates' stop endif ! now in atom_sc%equilibrium_pos we have the cartesian coordinates. close ( uposcar ) write ( ulog , * ) ' POSCAR read successfully and closed' write ( ulog , * ) 'RECIPROCAL_LATTICE: ' call make_reciprocal_lattice ( r1 , r2 , r3 , g1 , g2 , g3 ) call write_out ( ulog , 'om ' , om ) call write_out ( ulog , 'g1 ' , g1 ) call write_out ( ulog , 'g2 ' , g2 ) call write_out ( ulog , 'g3 ' , g3 ) 4 format ( 9 ( 2 x , f19 . 9 )) !6 format(2x,i5,1x,a2,2x,i5,9(2x,f19.10)) end subroutine read_crystal !=========================================================== subroutine check_input_poscar_consistency ! see if all atoms in the supercell can be obtained from the ! atoms in the input file using translations of the primitive lattice use atoms_force_constants use ios use geometry use lattice use params implicit none integer i , j , k , counter , ier , n1 , n2 , n3 real ( 8 ) a1 , a2 , a3 type ( vector ) shift0 , vec logical matched ! first describe r_i in terms of r0_i, and make sure the lin comb is integer write ( ulog , * ) ' ----------------------------------------------------------' write ( ulog , * ) ' CHECKING the commensurability between primcell and supercell' call check ( r1 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r1 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop call check ( r2 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r2 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop call check ( r3 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r3 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop write ( ulog , * ) ' COMMENSURABILITY CHECKED ---------------------------------' 4 format ( a , 3 ( 2 x , f8 . 3 ), 2 x , i1 ) !7 format(a,2(1x,i4),9(2x,f9.4)) !8 format(a,3(1x,i4),9(2x,f9.4)) ! do i=1,natoms0 !    tau1 = atom0(i)%at_type !    do j=1,natom_super_cell !       if (tau1 .eq. atom_sc(j)%cell%tau) then ! see if they can be mapped onto one another by a primitive translation vector !          vec = atom_sc(j)%equilibrium_pos - atom0(i)%equilibrium_pos !          call check(vec,a1,a2,a3,ier,g01,g02,g03) !          if (ier .eq. 1) then  ! There might be a constant shift !              shift0 = (a1-floor(a1)) * r01 + (a2-floor(a2)) * r02 + (a3-floor(a3)) * r03 !              write(ulog,8)'i,j,tau,shift=',i,j,tau1,shift0 !          endif !       endif !    enddo ! enddo ! return write ( ulog , * ) 'FINDING possible translation vectors, trying them on other atoms' checkloop : do i = 1 , natoms0 !,natom_super_cell shift0 = atom0 ( i )% equilibrium_pos - atom_sc ( 1 )% equilibrium_pos ! try this shift see if all atoms in SC can be mapped to the PC by it. SC : do k = 1 , natom_super_cell matched = . false . PRIM : do j = 1 , natoms0 ! one of the prim-cell atoms has to match vec = shift0 + atom_sc ( k )% equilibrium_pos - atom0 ( j )% equilibrium_pos call check ( vec , a1 , a2 , a3 , ier , g01 , g02 , g03 ) !         if (ier .eq. 0) matched = .true. if ( ier . eq . 0 ) then matched = . true . cycle SC else cycle PRIM endif enddo PRIM if (. not . matched ) then cycle checkloop !exit SC endif enddo SC if ( matched ) exit checkloop enddo checkloop if ( i . ge . 1 . and . i . le . natoms0 ) then call write_out ( ulog , 'THE shift vector ' , shift0 ) write ( ulog , * ) ' it maps atom 1 of the SC to atom ' , i , ' of the prim cell' else write ( ulog , * ) ' NO SHIFT VECTOR COULD BE DEFINED!, check your coordinates again' stop endif ! shift all the atoms in the primitive cell by -shift0 so that they fall ! on the atoms in the supercell ! write(ulog,*)'The shifted (cartesian) positions in the prim cell are now:' ! do i=1,natoms0 !    atom0(i)%equilibrium_pos = atom0(i)%equilibrium_pos-shift0 !    call write_out(ulog,'shifted position ', atom0(i)%equilibrium_pos) ! enddo ! write(ulog,*)'The shifted (cartesian) positions for ATOMPOS are now:' ! do i=1,natoms !    atompos(:,i) = atompos(:,i)- shift0 !    call write_out(ulog,'shifted position ', atompos(:,i)) ! enddo ! shifting vector has been identified. We can now identify all atoms of the SC SC2 : do k = 1 , natom_super_cell counter = 0 matched = . false . PRIM2 : do j = 1 , natoms0 ! one of the prim-cell atoms has to match vec = atom_sc ( k )% equilibrium_pos - atom0 ( j )% equilibrium_pos + shift0 call check ( vec , a1 , a2 , a3 , ier , g01 , g02 , g03 ) if ( verbose ) write ( ulog , 5 ) 'ier,a1,a2,a3=' , ier , a1 , a2 , a3 if ( ier . eq . 0 ) then ! found a matching vector matched = . true . counter = counter + 1 atom_sc ( k )% cell % tau = iatomcell0 ( j ) if ( verbose ) write ( ulog , * ) ' k in SC has type tau,j=' , k , atom_sc ( k )% cell % tau , j n1 = nint ( a1 ) n2 = nint ( a2 ) n3 = nint ( a3 ) if ( n1 . gt . n1max ) n1max = n1 if ( n2 . gt . n2max ) n2max = n2 if ( n3 . gt . n3max ) n3max = n3 if ( n1 . lt . n1min ) n1min = n1 if ( n2 . lt . n2min ) n2min = n2 if ( n3 . lt . n3min ) n3min = n3 atom_sc ( k )% cell % n ( 1 ) = n1 atom_sc ( k )% cell % n ( 2 ) = n2 atom_sc ( k )% cell % n ( 3 ) = n3 atom_sc ( k )% mass = atom0 ( j )% mass endif enddo PRIM2 if ( counter . eq . 0 ) then call write_out ( ulog , ' ATOM which can not be mapped to the prim cell ' , i ) write ( ulog , * ) ' check your coordinates ' write ( ulog , 3 ) atom_sc ( i )% equilibrium_pos stop elseif ( counter . ge . 2 ) then write ( ulog , * ) ' CHECK: more than one atom matched! check your coordinates' stop endif enddo SC2 write ( ulog , * ) '*******************************************************' write ( ulog , * ) 'SINCE THE PROGRAM WAS NOT STOPPED, MAPPING-CHECK PASSED!' write ( ulog , * ) '*******************************************************' 3 format ( 9 ( 1 x , g13 . 6 )) 5 format ( a , i2 , 9 ( 2 x , g11 . 4 )) end subroutine check_input_poscar_consistency !=========================================================== subroutine check_input_poscar_consistency_new ! see if all atoms in the supercell can be obtained from the ! atoms in the input file using translations of the primitive lattice use atoms_force_constants use ios use geometry use lattice use params implicit none integer i , j , k , counter , ier , n1 , n2 , n3 real ( 8 ) a1 , a2 , a3 type ( vector ) shift0 , vec logical matched ! first describe r_i in terms of r0_i, and make sure the lin comb is integer write ( ulog , * ) ' ----------------------------------------------------------' write ( ulog , * ) ' CHECKING the commensurability between primcell and supercell' call check ( r1 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r1 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop nr1 ( 1 ) = nint ( a1 ); nr1 ( 2 ) = nint ( a2 ); nr1 ( 3 ) = nint ( a3 ) call check ( r2 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r2 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop nr2 ( 1 ) = nint ( a1 ); nr2 ( 2 ) = nint ( a2 ); nr2 ( 3 ) = nint ( a3 ) call check ( r3 , a1 , a2 , a3 , ier , g01 , g02 , g03 ) write ( ulog , 4 ) 'checking r3 in units of r0s,ier=' , a1 , a2 , a3 , ier if ( ier . eq . 1 ) stop nr3 ( 1 ) = nint ( a1 ); nr3 ( 2 ) = nint ( a2 ); nr3 ( 3 ) = nint ( a3 ) write ( ulog , * ) ' COMMENSURABILITY CHECKED ---------------------------------' write ( ulog , * ) ' nr1=' , nr1 write ( ulog , * ) ' nr2=' , nr2 write ( ulog , * ) ' nr3=' , nr3 4 format ( a , 3 ( 2 x , f8 . 3 ), 2 x , i1 ) 7 format ( a , 2 ( 1 x , i4 ), 9 ( 2 x , f9 . 4 )) !8 format(a,3(1x,i4),9(2x,f9.4)) ! do i=1,natoms0 !    tau1 = atom0(i)%at_type !    do j=1,natom_super_cell !       if (tau1 .eq. atom_sc(j)%cell%tau) then ! see if they can be mapped onto one another by a primitive translation vector !          vec = atom_sc(j)%equilibrium_pos - atom0(i)%equilibrium_pos !          call check(vec,a1,a2,a3,ier,g01,g02,g03) !          if (ier .eq. 1) then  ! There might be a constant shift !              shift0 = (a1-floor(a1)) * r01 + (a2-floor(a2)) * r02 + (a3-floor(a3)) * r03 !              write(ulog,8)'i,j,tau,shift=',i,j,tau1,shift0 !          endif !       endif !    enddo ! enddo ! return write ( ulog , * ) 'FINDING possible translation vectors, trying them on other atoms' write ( ulog , * ) 'g01,g02,g03=' write ( ulog , * ) g01 write ( ulog , * ) g02 write ( ulog , * ) g03 checkloop : do i = 1 , natoms0 !,natom_super_cell shift0 = atom0 ( i )% equilibrium_pos - atom_sc ( 1 )% equilibrium_pos write ( ulog , 7 ) 'atom in PRIMCELL:' , i , atom0 ( i )% at_type , atom0 ( i )% equilibrium_pos write ( ulog , 3 ) 'trying shift vector=' , shift0 ! try this shift see if all atoms in SC can be mapped to the PC by it. SC : do k = 1 , natom_super_cell matched = . false . PRIM : do j = 1 , natoms0 ! one of the prim-cell atoms has to match vec = shift0 + atom_sc ( k )% equilibrium_pos - atom0 ( j )% equilibrium_pos call check ( vec , a1 , a2 , a3 , ier , g01 , g02 , g03 ) if ( verbose ) write ( ulog , 6 ) '* err,k_sc,r_sc,a1,a2,a3=' , ier , k , atom_sc ( k )% equilibrium_pos , a1 , a2 , a3 if ( ier . eq . 0 ) then matched = . true . !            write(ulog,*)' atom ',i,' in primitice cell matched with atom ',k,' in supercell' cycle SC !exit PRIM else cycle PRIM endif enddo PRIM if (. not . matched ) then ! wrong shift , try another shift cycle checkloop !      exit SC endif enddo SC if ( k . ge . natom_super_cell . and . matched ) then ! all atoms were matched exit checkloop !   if (matched) exit checkloop endif enddo checkloop if ( i . ge . 1 . and . i . le . natoms0 ) then call write_out ( ulog , 'THE shift vector ' , shift0 ) write ( ulog , * ) ' it maps atom 1 of the SC to atom ' , i , ' of the prim cell' else write ( ulog , * ) ' NO SHIFT VECTOR COULD BE DEFINED!, check your coordinates again;i=' , i stop endif ! shift all the atoms in the primitive cell by -shift0 so that they fall ! on the atoms in the supercell ! write(ulog,*)'The shifted (cartesian) positions in the prim cell are now:' ! do i=1,natoms0 !    atom0(i)%equilibrium_pos = atom0(i)%equilibrium_pos-shift0 !    call write_out(ulog,'shifted position ', atom0(i)%equilibrium_pos) ! enddo ! write(ulog,*)'The shifted (cartesian) positions for ATOMPOS are now:' ! do i=1,natoms !    atompos(:,i) = atompos(:,i)- shift0 !    call write_out(ulog,'shifted position ', atompos(:,i)) ! enddo ! shifting vector has been identified. We can now identify all atoms of the SC SC2 : do k = 1 , natom_super_cell counter = 0 matched = . false . PRIM2 : do j = 1 , natoms0 ! one of the prim-cell atoms has to match vec = atom_sc ( k )% equilibrium_pos - atom0 ( j )% equilibrium_pos + shift0 call check ( vec , a1 , a2 , a3 , ier , g01 , g02 , g03 ) if ( verbose ) write ( ulog , 5 ) 'ier,a1,a2,a3=' , ier , a1 , a2 , a3 if ( ier . eq . 0 ) then ! found a matching vector matched = . true . counter = counter + 1 atom_sc ( k )% cell % tau = iatomcell0 ( j ) if ( verbose ) write ( ulog , * ) ' k in SC has type tau,j=' , k , atom_sc ( k )% cell % tau , j n1 = nint ( a1 ) n2 = nint ( a2 ) n3 = nint ( a3 ) if ( n1 . gt . n1max ) n1max = n1 if ( n2 . gt . n2max ) n2max = n2 if ( n3 . gt . n3max ) n3max = n3 if ( n1 . lt . n1min ) n1min = n1 if ( n2 . lt . n2min ) n2min = n2 if ( n3 . lt . n3min ) n3min = n3 atom_sc ( k )% cell % n ( 1 ) = n1 atom_sc ( k )% cell % n ( 2 ) = n2 atom_sc ( k )% cell % n ( 3 ) = n3 atom_sc ( k )% mass = atom0 ( j )% mass atom_sc ( k )% at_type = atom0 ( j )% at_type endif enddo PRIM2 if ( counter . eq . 0 ) then call write_out ( ulog , ' ATOM which can not be mapped to the prim cell ' , i ) write ( ulog , * ) ' check your coordinates ' write ( ulog , 3 ) atom_sc ( i )% equilibrium_pos stop elseif ( counter . ge . 2 ) then write ( ulog , * ) ' CHECK: more than one atom matched! check your coordinates' stop endif enddo SC2 write ( ulog , * ) '*******************************************************' write ( ulog , * ) 'SINCE THE PROGRAM WAS NOT STOPPED, MAPPING-CHECK PASSED!' write ( ulog , * ) '*******************************************************' 3 format ( 9 ( 1 x , g13 . 6 )) 5 format ( a , i2 , 9 ( 2 x , g11 . 4 )) 6 format ( a , i2 , 1 x , i5 , 9 ( 2 x , g11 . 4 )) open ( 173 , file = 'poscar.xyz' ) write ( 173 , * ) natom_super_cell write ( 173 , * ) 'poscar.xyz to visualize' i = 0 do n1 = 1 , natom_type do i = 1 , natom_super_cell if ( atom_sc ( i )% at_type . eq . n1 ) then if ( n1 . eq . 1 ) then write ( 173 , 9 ) 'N ' , atom_sc ( i )% equilibrium_pos elseif ( n1 . eq . 2 ) then write ( 173 , 9 ) 'O ' , atom_sc ( i )% equilibrium_pos elseif ( n1 . eq . 3 ) then write ( 173 , 9 ) 'C ' , atom_sc ( i )% equilibrium_pos elseif ( n1 . eq . 4 ) then write ( 173 , 9 ) 'Ge ' , atom_sc ( i )% equilibrium_pos elseif ( n1 . eq . 5 ) then write ( 173 , 9 ) 'Si ' , atom_sc ( i )% equilibrium_pos endif endif enddo enddo close ( 173 ) 9 format ( a , 9 ( 2 x , f19 . 9 )) end subroutine check_input_poscar_consistency_new !=========================================================== subroutine read_force_position_data ( outcar , frc_constr ) use ios use atoms_force_constants use geometry use params use lattice use svd_stuff implicit none integer i , t , j , frc_constr ! type(vector) v ! real(8) x1,x2,x3,x4 character line * 99 , outcar * ( * ) logical found , exst ! open(utraj,file='OUTCAR',status='old') inquire ( file = outcar , exist = exst ) if ( exst ) then open ( utraj , file = outcar , status = 'old' ) else write ( ulog , * ) ' outcar file ' , outcar , ' does not exist; check your files location and run again' stop endif t = 0 do j = 1 , 11000000 read ( utraj , '(a)' , end = 99 ) line call findword ( 'POSITION' , line , found ) !    if (line(1:8) .eq. \"POSITION\" ) then if ( found ) then t = t + 1 endif enddo 99 write ( ulog , * ) ' reached the end of OUTCAR file; number of configurations= ' , t nconfigs = t if ( t . eq . 0 ) then write ( ulog , * ) ' the word POSITION was not found in OUTCAR file, check it!' stop endif i = ( j - 1 ) / t - 2 ! this is the number of atoms read from OUTCAR if ( i . ne . natom_super_cell ) then write ( ulog , * ) ' number of atoms read .ne. no of atoms in POSCAR file' , i , natom_super_cell write ( ulog , * ) ' # of read lines in OUTCAR is=' , j write ( ulog , * ) ' check your POSCAR and OUTCAR again ' write ( ulog , * ) ' make sure the # of atoms is the same in both files' write ( ulog , * ) ' there should be no blank lines at the end of OUTCAR' stop endif ! allocates displ and force arrays if ( allocated ( displ )) deallocate ( displ ) if ( allocated ( force )) deallocate ( force ) call allocate_pos ( natom_super_cell , nconfigs ) ! now get the FORCES from OUTCAR file rewind ( utraj ) t = 0 do j = 1 , 11000000 read ( utraj , '(a)' , end = 88 ) line !    if (line(1:8) .eq. \"POSITION\" ) then call findword ( 'POSITION' , line , found ) if ( found ) then read ( utraj , * ) t = t + 1 do i = 1 , natom_super_cell read ( utraj , * ) displ ( 1 : 3 , i , t ), force ( 1 : 3 , i , t ) enddo endif enddo 88 write ( ulog , * ) ' reached the end of OUTCAR file after steps= ' , t write ( ulog , * ) ' last line read was ' write ( ulog , '(a)' ) line close ( utraj ) if ( t . ne . nconfigs ) then write ( ulog , * ) 'ERROR in reading the force file OUTCAR' write ( ulog , * ) 'nconfigs, # of read steps=' , nconfigs , t stop endif call write_out ( ulog , ' last force ' , force (:, natom_super_cell , t )) call write_out ( ulog , ' last coord ' , displ (:, natom_super_cell , t )) ! force_constraints = nconfigs *natom_super_cell*3 frc_constr = nconfigs * natom_super_cell * 3 ! call pos_out_consistency end subroutine read_force_position_data !=========================================================== subroutine write_independent_fcs ( sd ) use svd_stuff use atoms_force_constants use ios use params implicit none integer i , g , cnt2 , cnt real ( 8 ), intent ( out ) :: sd ( 4 ) write ( ulog , * ) '******* Violation of translational invariance relations: ' , itrans do i = 1 , transl_constraints write ( ulog , * ) i , dot_product ( atransl ( i ,:), fcs (:)) enddo write ( ulog , * ) '******* Violation of rotational invariance relations: ' , irot do i = 1 , rot_constraints write ( ulog , * ) i , dot_product ( arot ( i ,:), fcs (:)), brot ( i ) enddo !  if(.not.allocated(ahuang)) allocate( ahuang(dim_al,ngr)) if ( ihuang . ne . 0 ) then write ( ulog , * ) '******* Violation of Huang invariance relations: ' do i = 1 , huang_constraints write ( ulog , * ) i , dot_product ( ahuang ( i ,:), fcs (:)) enddo endif !   call check_huang !return write ( ulog , * ) ' group, fcs(group), sigma(group) for all SVD' do i = 1 , dim_ac write ( ulog , 4 ) i , fcs ( i ), sigma ( i ), sigma ( i ) / sqrt ( 1. * dim_al ) enddo write ( ulog , * ) \"rank, average error\" cnt2 = 0 ; sd = 0 do i = 1 , 4 if ( include_fc ( i ). eq . 0 ) cycle cnt = 0 do g = 1 , map ( i )% ngr !        do k=1,map(i)%ntind(g) cnt = cnt + 1 cnt2 = cnt2 + 1 !cnt sd ( i ) = sd ( i ) + sigma ( cnt2 ) / sqrt ( 1. * dim_al ) !        enddo enddo if ( cnt . ne . 0 ) sd ( i ) = sd ( i ) / cnt write ( ulog , 4 ) i , sd ( i ) enddo write ( ulog , 5 ) ' !==== Error summary for each rank' ,( sd ( i ), i = 1 , 4 ) ! if  (enforce_inv .eq. 0) then ! else !   write(ulog,*)' group, fcs(group), sigma(group) for non-eliminated SVD' ! !!  fc1 = fc1-matmul(a11ia12,fcs) !   do i=1,n_indep !      write(ulog,4) i,fc1(i) !   enddo !   do i=1,dim_ac !      write(ulog,4) i,fcs(i),sigma(i),sigma(i)/sqrt(1.*dim_al) !   enddo !   sigma = fcs !   deallocate(fcs) !   allocate(fcs(ngr)) !   fcs(1:n_indep)=fc1; fcs(1+n_indep:ngr) = sigma ! endif 4 format ( i6 , 3 ( 2 x , g15 . 8 )) 5 format ( a , 9 ( 2 x , g11 . 4 )) end subroutine write_independent_fcs !=========================================================== subroutine write_independent_fcs_2 ( sd ) use svd_stuff use atoms_force_constants use ios use params implicit none integer i , k , g , cnt2 , cnt real ( 8 ) sd ( 4 ) if ( enforce_inv . eq . 0 ) then write ( ulog , * ) '******* Violation of translational invariance relations: ' , itrans do i = 1 , transl_constraints write ( ulog , * ) i , dot_product ( atransl ( i ,:), fcs (:)) enddo write ( ulog , * ) '******* Violation of rotational invariance relations: ' , irot do i = 1 , rot_constraints write ( ulog , * ) i , dot_product ( arot ( i ,:), fcs (:)), brot ( i ) enddo write ( ulog , * ) '******* Violation of Huang invariance relations: ' do i = 1 , huang_constraints write ( ulog , * ) i , dot_product ( ahuang ( i ,:), fcs (:)) enddo call check_huang write ( ulog , * ) ' group, fcs(group), sigma(group) for all SVD' do i = 1 , dim_ac write ( ulog , 4 ) i , fcs ( i ), sigma ( i ), sigma ( i ) / sqrt ( 1. * dim_al ) enddo cnt2 = 0 ; sd = 0 do i = 1 , 4 if ( include_fc ( i ). eq . 0 ) then cnt = 0 cycle endif cnt = 0 do g = 1 , map ( i )% ngr do k = 1 , map ( i )% ntind ( g ) cnt = cnt + 1 cnt2 = cnt2 + 1 !cnt sd ( i ) = sd ( i ) + sigma ( cnt2 ) / sqrt ( 1. * dim_al ) enddo enddo if ( cnt . ne . 0 ) sd ( i ) = sd ( i ) / cnt write ( ulog , 4 ) i , sd ( i ) enddo write ( ulog , 5 ) ' !==== Error summary for each rank' ,( sd ( i ), i = 1 , 4 ) else write ( ulog , * ) ' group, fcs(group), sigma(group) for non-eliminated SVD' !  fc1 = fc1-matmul(a11ia12,fcs) do i = 1 , n_indep write ( ulog , 4 ) i , fc1 ( i ) enddo do i = 1 , dim_ac write ( ulog , 4 ) i , fcs ( i ), sigma ( i ), sigma ( i ) / sqrt ( 1. * dim_al ) enddo sigma = fcs deallocate ( fcs ) allocate ( fcs ( ngr )) fcs ( 1 : n_indep ) = fc1 ; fcs ( 1 + n_indep : ngr ) = sigma endif 4 format ( i6 , 3 ( 2 x , g15 . 8 )) 5 format ( a , 9 ( 2 x , g11 . 4 )) end subroutine write_independent_fcs_2 !=========================================================== subroutine write_neighbors use atoms_force_constants use force_constants_module use params use ios implicit none integer i0 , shel_count , j , nm ( 3 ), ta , nbmx real ( 8 ) dij write ( ulog , * ) ' rcut(2) corresponding to nshell(2)=' , rcut ( 2 ) write ( ulog , * ) ' ************ Writing the neighborlist ************** ' do i0 = 1 , natoms0 write ( ulog , * ) ' Neighbors of atom number ' , i0 do shel_count = 1 , maxshells nbmx = atom0 ( i0 )% shells ( shel_count )% no_of_neighbors dij = atom0 ( i0 )% shells ( shel_count )% rij do j = 1 , min ( nbmx , 500 ) ! write the first 500 neighbors ta = atom0 ( i0 )% shells ( shel_count )% neighbors ( j )% tau nm = atom0 ( i0 )% shells ( shel_count )% neighbors ( j )% n write ( ulog , 3 ) ' shell,radius,neighbor,atomid=' , shel_count , dij , j , ta , nm enddo write ( 333 , 2 ) shel_count , dij , j - 1 enddo enddo write ( ulog , * ) ' ************ End of the neighborlist ************** ' 2 format ( i4 , 2 x , f8 . 4 , 2 x , i4 ) 3 format ( a , 2 x , i3 , 2 x , f8 . 4 , 2 x , i3 , 4 x , i3 , ' (' , 3 ( 1 x , i4 ), ')' ) end subroutine write_neighbors !============================================================ subroutine write_output_fc2 use svd_stuff use ios use force_constants_module use atoms_force_constants use params use lattice use constants implicit none integer rnk , t , ti , i , res , j , rs !ni(4),nt(4) integer iat ( 4 ), ixyz ( 4 ), g , ng , term , term2 , cnt2 , frm real ( 8 ) rij , bunit , one , fcd , trace , dij character frmt * 2 , goh * 48 , ln * 1 , geh * 47 bunit = ryd / ab / ab one = 1 d0 !6 format(2x,i5,1x,a2,2x,i5,9(2x,f19.10)) !7 format(1(2x,i5),3(2x,f19.10),4(2x,i5),2x,f9.5) 8 format ( 2 ( 2 x , i5 ), 3 ( 2 x , f19 . 10 ), 4 ( 2 x , i5 ), 2 x , f9 . 5 ) !9 format(9(2x,f19.10)) ! first write the crystal data ! nt=0; ni=0 ! do i=1,4 !    if(map(i)%ngr.gt.0) then !      nt(i)= sum(map(i)%nt(:)) !      ni(i)= sum(map(i)%ntind(:)) !      if ( (ni(i).ne.map(i)%ntotind) .or. (nt(i).ne.map(i)%ntot) ) then !         write(ulog,*)'WRITE_OUTPUT_FC2: ERROR!!' !         write(ulog,*)'ni(i).ne.map(i)%ntotind ',ni(i),map(i)%ntotind !         write(ulog,*)'nt(i).ne.map(i)%ntot    ',nt(i),map(i)%ntot !    endif ! enddo ! call write_lat_fc(ni,nt)  ! same as call write_lat_fc(map(:)%ntotind,map(:)%ntot) !---------------------------------------- res = 0 do rnk = 1 , 4 if ( include_fc ( rnk ) . ne . 0 ) then frm = 30 + rnk write ( ln , '(i1)' ) rnk goh = '(a1,i6,1x,i5,' // ln // '(3x,i4,1x,i1),3x,2(g14.8,2x),f5.2)' geh = '(i6,1x,i5,' // ln // '(3x,i4,1x,i1),3x,g14.8,f8.4,2x,f9.5)' write ( frmt , '(i2)' ) 30 + rnk write ( ulog , * ) ' FOR RANK=' , rnk , ' format=' , frmt write ( * , * ) ' FOR RANK=' , rnk , ' format=' , frmt write ( ufc1 - 1 + rnk , * ) '# RANK ' , rnk , ' tensors :term,group,(iatom,ixyz)_2 d&#94;nU/dx_{i,alpha}&#94;n' ng = map ( rnk )% ngr ! number of groups cnt2 = 0 term = 0 term2 = 0 do g = 1 , map ( rnk )% ngr ! index of a given group if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) ! write in the log and fcn_fit.dat: cnt2+ti is the position of indep_fc of that rank do ti = 1 , map ( rnk )% ntind ( g ) ! index of independent terms in that group g iat ( 1 : rnk ) = map ( rnk )% gr ( g )% iatind (:, ti ) ixyz ( 1 : rnk ) = map ( rnk )% gr ( g )% ixyzind (:, ti ) term = term + 1 if ( rnk . eq . 2 ) then rij = length ( atompos (:, iat ( 1 )) - atompos (:, iat ( 2 ))) else rij = 0 endif write ( ulog , goh ) map ( rnk )% err ( cnt2 + ti ), g , ti ,( iat ( j ), ixyz ( j ), j = 1 , rnk ), & & fcs ( res + cnt2 + ti ), fcs ( res + cnt2 + ti ) / ryd * ab ** rnk , rij write ( ufit1 - 1 + rnk , geh ) ti , g ,( iat ( j ), ixyz ( j ), j = 1 , rnk ), & & fcs ( res + cnt2 + ti ), one , rij enddo ! write in the fcn.dat file do t = 1 , map ( rnk )% nt ( g ) ! index of dependent terms in that group g iat ( 1 : rnk ) = map ( rnk )% gr ( g )% iat (:, t ) ixyz ( 1 : rnk ) = map ( rnk )% gr ( g )% ixyz (:, t ) term2 = term2 + 1 fcd = 0 ! must find the corresponding index of the indep term t <-> ti do ti = 1 , map ( rnk )% ntind ( g ) ! this is the index of the indep FC coming in the A*FC=b matrix product fcd = fcd + fcs ( res + cnt2 + ti ) * map ( rnk )% gr ( g )% mat ( t , ti ) enddo if ( abs ( fcd ) . gt . margin ) then write ( ufc1 - 1 + rnk , geh ) t , g , ( iat ( j ), ixyz ( j ), j = 1 , rnk ), fcd , one endif enddo enddo !  res = res+ndindp(rnk) res = res + map ( rnk )% ntotind endif enddo write ( ulog , * ) '******* Trace for the harmonic FCs ********' open ( 456 , file = 'trace_fc.dat' ) ! write the trace of FC2 rnk = 2 iloop : do i = 1 , natoms0 jloop : do j = 1 , natoms rij = length ( atompos (:, i ) - atompos (:, j )) trace = 0 !     rs=ndindp(1) rs = map ( 1 )% ntotind if ( include_fc ( rnk ) . ne . 0 ) then ng = map ( rnk )% ngr ! number of groups cnt2 = 0 term2 = 0 do g = 1 , map ( rnk )% ngr ! index of a given group if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) ! index of independent terms in that group g iat ( 1 : rnk ) = map ( rnk )% gr ( g )% iat (:, t ) ixyz ( 1 : rnk ) = map ( rnk )% gr ( g )% ixyz (:, t ) !    i=iat(1) ; j=iat(2) if ( iat ( 1 ). ne . i ) cycle !iloop if ( iat ( 2 ). ne . j ) cycle ! jloop !      write(*,*)'i,j,term2,al,be=',i,j,term2,ixyz(1),ixyz(2) fcd = 0 ! must find the corresponding index of the indep term t <-> ti do ti = 1 , map ( rnk )% ntind ( g ) ! this is the index of the indep FC coming in the A*FC=b matrix product fcd = fcd + fcs ( rs + cnt2 + ti ) * map ( rnk )% gr ( g )% mat ( t , ti ) enddo dij = length ( atompos (:, iat ( 1 )) - atompos (:, iat ( 2 ))) if ( ixyz ( 1 ). eq . ixyz ( 2 )) then term2 = term2 + 1 trace = trace + fcd !       write(*,*)'al,term2,trace=',ixyz(1),term2,trace endif enddo enddo if ( trace . ne . 0 ) then write ( ulog , 8 ) i , j , dij , trace write ( 456 , 8 ) i , j , dij , trace endif !     if (term2.ne.3) write(456,*)'#ERROR: there are ',term2,' terms for rij=',dij endif enddo jloop enddo iloop close ( 456 ) write ( ulog , * ) '***************** END OF FC Trace ******************' !---------------------------------------- ! 125  format(a) if ( res . ne . ngr ) then write ( ulog , * ) 'WRITE_OUTPUT: sum(nterms),ngr=' , res , ngr write ( ulog , * ) 'WRITE_OUTPUT: they should be equal!' endif end subroutine write_output_fc2 !============================================================ !*************************************************BIKASH************************************************************************ !*************************************************BIKASH************************************************************************ !*************************************************BIKASH************************************************************************ subroutine read_output_fc2 use svd_stuff use ios use force_constants_module use atoms_force_constants use params use lattice use constants implicit none integer rnk , t , ti , i , res , j , rs !ni(4),nt(4) integer iat ( 4 ), ixyz ( 4 ), g , ng , term , term2 , cnt2 , frm , gi real ( 8 ) rij , bunit , one , fcd , trace , dij character frmt * 2 , goh * 48 , ln * 1 , geh * 47 , line * 99 logical ex bunit = ryd / ab / ab one = 1 d0 write ( * , * ) \"This call is taking...\" !6 format(2x,i5,1x,a2,2x,i5,9(2x,f19.10)) !7 format(1(2x,i5),3(2x,f19.10),4(2x,i5),2x,f9.5) 8 format ( 2 ( 2 x , i5 ), 3 ( 2 x , f19 . 10 ), 4 ( 2 x , i5 ), 2 x , f9 . 5 ) !9 format(9(2x,f19.10)) ! first write the crystal data ! nt=0; ni=0 ! do i=1,4 !    if(map(i)%ngr.gt.0) then !      nt(i)= sum(map(i)%nt(:)) !      ni(i)= sum(map(i)%ntind(:)) !      if ( (ni(i).ne.map(i)%ntotind) .or. (nt(i).ne.map(i)%ntot) ) then !         write(ulog,*)'WRITE_OUTPUT_FC2: ERROR!!' !         write(ulog,*)'ni(i).ne.map(i)%ntotind ',ni(i),map(i)%ntotind !         write(ulog,*)'nt(i).ne.map(i)%ntot    ',nt(i),map(i)%ntot !    endif ! enddo ! call write_lat_fc(ni,nt)  ! same as call write_lat_fc(map(:)%ntotind,map(:)%ntot) !---------------------------------------- res = 0 do rnk = 1 , 4 if ( include_fc ( rnk ) . ne . 0 ) then frm = 30 + rnk write ( ln , '(i1)' ) rnk goh = '(a1,i6,1x,i5,' // ln // '(3x,i4,1x,i1),3x,2(g14.8,2x),f5.2)' geh = '(i6,1x,i5,' // ln // '(3x,i4,1x,i1),3x,g14.8,f8.4,2x,f9.5)' write ( frmt , '(i2)' ) 30 + rnk write ( ulog , * ) ' FOR RANK=' , rnk , ' format=' , frmt write ( * , * ) ' FOR RANK=' , rnk , ' format=' , frmt inquire ( file = \"fc2.dat\" , exist = ex ) if ( ex ) then if ( rnk . eq . 2 ) then if ( include_fc ( rnk ) . eq . 2 ) then write ( * , * ) \"This call is taking FC\" open ( 431 , file = \"fc2.dat\" ) read ( 431 , '(A)' ) line write ( * , * ) line endif endif endif ! write(ufc1-1+rnk,*)'# RANK ',rnk,' tensors :term,group,(iatom,ixyz)_2 d&#94;nU/dx_{i,alpha}&#94;n' write ( * , * ) \"Outside if is valid...\" ng = map ( rnk )% ngr ! number of groups write ( * , * ) \"The value of ng is: \" , map ( rnk )% ngr cnt2 = 0 term = 0 term2 = 0 do g = 1 , map ( rnk )% ngr ! index of a given group if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) write ( * , * ) \"Looping in g...\" ! write in the log and fcn_fit.dat: cnt2+ti is the position of indep_fc of that rank do ti = 1 , map ( rnk )% ntind ( g ) ! index of independent terms in that group g iat ( 1 : rnk ) = map ( rnk )% gr ( g )% iatind (:, ti ) ixyz ( 1 : rnk ) = map ( rnk )% gr ( g )% ixyzind (:, ti ) term = term + 1 if ( rnk . eq . 2 ) then rij = length ( atompos (:, iat ( 1 )) - atompos (:, iat ( 2 ))) else rij = 0 endif !   write(ulog,goh) map(rnk)%err(cnt2+ti),g,ti,(iat(j),ixyz(j),j=1,rnk),  & !   &     fcs(res+cnt2+ti),fcs(res+cnt2+ti)/ryd*ab**rnk,rij !   write(ufit1-1+rnk,geh) ti,g,(iat(j),ixyz(j),j=1,rnk),  & !   &     fcs(res+cnt2+ti),one,rij enddo write ( * , * ) \"Value for include_fc(rnk) is: \" , include_fc ( rnk ) ! read in from the fcn.dat file if ( rnk . eq . 2 ) then if ( include_fc ( rnk ) . eq . 2 ) then do t = 1 , map ( rnk )% nt ( g ) ! index of dependent terms in that group g !         iat(1:rnk)  = map(rnk)%gr(g)%iat (:,t) !         ixyz(1:rnk) = map(rnk)%gr(g)%ixyz(:,t) term2 = term2 + 1 !         fcd = 0 write ( * , * ) \"This call is also taking...\" ! must find the corresponding index of the indep term t <-> ti, g <-> gi !         do ti=1,map(rnk)%ntind(g) ! this is the index of the indep FC coming in the A*FC=b matrix product !            fcd = fcd + fcs(res+cnt2+ti)*map(rnk)%gr(g)%mat(t,ti) !         enddo !         if( abs(fcd) .gt. margin) then !            write(ufc1-1+rnk,geh)t,g, (iat(j),ixyz(j),j=1,rnk),fcd,one read ( 431 , * ) ti , gi , ( iat ( j ), ixyz ( j ), j = 1 , rnk ), fcd , one !         endif write ( * , * ) \"The reading is done...\" enddo endif endif close ( 431 ) enddo !  res = res+ndindp(rnk) res = res + map ( rnk )% ntotind endif enddo !  write(ulog,*)'******* Trace for the harmonic FCs ********' open ( 456 , file = 'trace_fc.dat' ) ! write the trace of FC2 rnk = 2 iloop : do i = 1 , natoms0 jloop : do j = 1 , natoms rij = length ( atompos (:, i ) - atompos (:, j )) trace = 0 !     rs=ndindp(1) rs = map ( 1 )% ntotind if ( include_fc ( rnk ) . ne . 0 ) then ng = map ( rnk )% ngr ! number of groups cnt2 = 0 term2 = 0 do g = 1 , map ( rnk )% ngr ! index of a given group if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) ! index of independent terms in that group g iat ( 1 : rnk ) = map ( rnk )% gr ( g )% iat (:, t ) ixyz ( 1 : rnk ) = map ( rnk )% gr ( g )% ixyz (:, t ) !    i=iat(1) ; j=iat(2) if ( iat ( 1 ). ne . i ) cycle !iloop if ( iat ( 2 ). ne . j ) cycle ! jloop !      write(*,*)'i,j,term2,al,be=',i,j,term2,ixyz(1),ixyz(2) fcd = 0 ! must find the corresponding index of the indep term t <-> ti do ti = 1 , map ( rnk )% ntind ( g ) ! this is the index of the indep FC coming in the A*FC=b matrix product fcd = fcd + fcs ( rs + cnt2 + ti ) * map ( rnk )% gr ( g )% mat ( t , ti ) enddo dij = length ( atompos (:, iat ( 1 )) - atompos (:, iat ( 2 ))) if ( ixyz ( 1 ). eq . ixyz ( 2 )) then term2 = term2 + 1 trace = trace + fcd !       write(*,*)'al,term2,trace=',ixyz(1),term2,trace endif enddo enddo if ( trace . ne . 0 ) then write ( ulog , 8 ) i , j , dij , trace write ( 456 , 8 ) i , j , dij , trace endif !     if (term2.ne.3) write(456,*)'#ERROR: there are ',term2,' terms for rij=',dij endif enddo jloop enddo iloop close ( 456 ) !write(ulog,*)'***************** END OF FC Trace ******************' !---------------------------------------- ! 125  format(a) !if (res.ne.ngr) then !   write(ulog,*)'WRITE_OUTPUT: sum(nterms),ngr=',res,ngr !   write(ulog,*)'WRITE_OUTPUT: they should be equal!' !endif end subroutine read_output_fc2 !*************************************************BIKASH************************************************************************ !*************************************************BIKASH************************************************************************ !*************************************************BIKASH************************************************************************ subroutine write_output_fc use svd_stuff use ios use force_constants_module use atoms_force_constants use params use lattice use constants implicit none integer rank , t , i , res , j , term2 real ( 8 ) rij , bunit , one , dij , trace , fcd logical ex one = 1 d0 bunit = ryd / ab / ab 1 format ( i6 , 1 x , i5 , 1 ( 3 x ,( i4 , 1 x , i1 )), 3 x , g15 . 8 , 2 x , f5 . 2 ) 2 format ( i6 , 1 x , i5 , 2 ( 3 x ,( i4 , 1 x , i1 )), 3 x , g15 . 8 , 2 x , f5 . 2 ) 3 format ( i6 , 1 x , i5 , 3 ( 3 x ,( i4 , 1 x , i1 )), 3 x , g15 . 8 , 2 x , f5 . 2 ) 4 format ( i6 , 1 x , i5 , 4 ( 3 x ,( i4 , 1 x , i1 )), 3 x , g15 . 8 , 2 x , f5 . 2 ) !6 format(2x,i5,1x,a2,2x,i5,9(2x,f19.10)) !7 format(1(2x,i5),3(2x,f19.10),4(2x,i5),2x,f9.5) 8 format ( 2 ( 2 x , i3 ), 9 ( 2 x , g13 . 6 )) 18 format ( a , 2 ( 2 x , i3 ), 9 ( 2 x , g13 . 6 )) !9 format(9(2x,f19.10)) !12 format(i6,1x,i4,2(3x,(i3,1x,i1)),' [',i2,',(',3(1x,i2),') ]',3x,g13.6,2(2x,f7.3)) 31 format ( a1 , i6 , 1 x , i5 , 1 ( 3 x ,( i3 , 1 x , i1 )), 3 x , 2 ( g15 . 8 , 2 x ), f5 . 2 ) 32 format ( a1 , i6 , 1 x , i4 , 2 ( 3 x ,( i3 , 1 x , i1 )), ' [' , i3 , ',(' , 3 ( 1 x , i2 ), ') ]' , 3 x , 2 ( g13 . 6 , 1 x ), 2 ( 2 x , f7 . 3 )) 33 format ( a1 , i6 , 1 x , i5 , 3 ( 3 x ,( i3 , 1 x , i1 )), 3 x , 2 ( g15 . 8 , 2 x ), f5 . 2 ) 34 format ( a1 , i6 , 1 x , i5 , 4 ( 3 x ,( i3 , 1 x , i1 )), 3 x , 2 ( g15 . 8 , 2 x ), f5 . 2 ) ! first write the crystal data call write_lat_fc ( ngroups , nterms ) write ( ulog , * ) '********** INDEPENDENT FORCE CONSTANTS ARE *********' write ( ulog , * ) ' term, group(term) , (atom,xyz)_rank , FC(eV/A&#94;n), FC(Hart/aB&#94;n), amplitude ' !---------------------------------------- res = 0 rank = 1 if ( include_fc ( rank ) . eq . 1 ) then write ( ufc1 , * ) ' RANK 1 tensors :term,group,iatom,ixyz dU/dx_{i,alpha}' do t = 1 , nterms ( rank ) write ( ufc1 , 1 ) t , igroup_1 ( t ), & & iatomterm_1 ( 1 , t ), ixyzterm_1 ( 1 , t ), & & fcs ( res + igroup_1 ( t )) * ampterm_1 ( t ), one !& fcs(res+igroup_1(t)),ampterm_1(t) enddo do i = 1 , ngroups ( rank ) t = map_1 ( i ) !   write(ulog,1) t,igroup_1(t), iatomterm_1(1,t),ixyzterm_1(1,t),  & ! & fcs(res+igroup_1(t)),ampterm_1(t) write ( ulog , 31 ) err_1 ( igroup_1 ( t )), t , igroup_1 ( t ), iatomterm_1 ( 1 , t ), ixyzterm_1 ( 1 , t ), & & fcs ( res + igroup_1 ( t )), fcs ( res + igroup_1 ( t )) / ryd * ab , ampterm_1 ( t ) write ( ufit1 , 1 ) t , igroup_1 ( t ), iatomterm_1 ( 1 , t ), ixyzterm_1 ( 1 , t ), & & fcs ( res + igroup_1 ( t )) * ampterm_1 ( t ), one !& fcs(res+igroup_1(t)),ampterm_1(t) enddo res = res + igroup_1 ( nterms ( rank )) endif !---------------------------------------- rank = 2 if ( include_fc ( rank ) . eq . 1 ) then write ( ufc2 , * ) '# RANK 2 tensors :term,group,(iatom,ixyz)_2 d2U/dx_{i,alpha}&#94;2' do t = 1 , nterms ( rank ) if ( abs ( fcs ( res + igroup_2 ( t )) * ampterm_2 ( t )) . gt . margin ) then write ( ufc2 , 2 ) t , igroup_2 ( t ), & & iatomterm_2 ( 1 , t ), ixyzterm_2 ( 1 , t ), iatomterm_2 ( 2 , t ), ixyzterm_2 ( 2 , t ), & & fcs ( res + igroup_2 ( t )) * ampterm_2 ( t ), one !& fcs(res+igroup_2(t)),ampterm_2(t) endif enddo do i = 1 , ngroups ( rank ) t = map_2 ( i ) rij = length ( atompos (:, iatomterm_2 ( 1 , t )) - atompos (:, iatomterm_2 ( 2 , t ))) !   write(ulog,12) t,igroup_2(t),  & !& iatomterm_2(1,t),ixyzterm_2(1,t),iatomterm_2(2,t),ixyzterm_2(2,t),  & !& iatomcell0(iatomterm_2(2,t)),iatomcell(:,iatomterm_2(2,t)), & !& fcs(res+igroup_2(t)),rij,ampterm_2(t) write ( ulog , 32 ) err_2 ( igroup_2 ( t )), t , igroup_2 ( t ), & & iatomterm_2 ( 1 , t ), ixyzterm_2 ( 1 , t ), iatomterm_2 ( 2 , t ), ixyzterm_2 ( 2 , t ), & & iatomcell0 ( iatomterm_2 ( 2 , t )), iatomcell (:, iatomterm_2 ( 2 , t )), & & fcs ( res + igroup_2 ( t )), fcs ( res + igroup_2 ( t )) / ryd * ab * ab , rij , ampterm_2 ( t ) !   write(ufit2,2) t,igroup_2(t),  & !& iatomterm_2(1,t),ixyzterm_2(1,t),iatomterm_2(2,t),ixyzterm_2(2,t),  & !& fcs(res+igroup_2(t)),ampterm_2(t) ! fc2, ampterm has been changed to fc2*ampterm and 1 (basically the last column ! does not count) so that the pure fc is read in the general case where ampterm ! is really a matrix write ( ufit2 , 2 ) t , igroup_2 ( t ), & & iatomterm_2 ( 1 , t ), ixyzterm_2 ( 1 , t ), iatomterm_2 ( 2 , t ), ixyzterm_2 ( 2 , t ), & & fcs ( res + igroup_2 ( t )) * ampterm_2 ( t ), one enddo !---------------------------------------- write ( ulog , * ) '******* Trace for the harmonic FCs ********' open ( 456 , file = 'trace_fc.dat' ) ! write the trace of FC2 rank = 2 if ( include_fc ( rank ) . ne . 0 ) then iloop : do i = 1 , natoms0 jloop : do j = 1 , natoms rij = length ( atompos (:, i ) - atompos (:, j )) trace = 0 term2 = 0 !       do g=1,ngroups(rank) !          t = map_2(g) do t = 1 , nterms ( rank ) dij = length ( atompos (:, iatomterm_2 ( 1 , t )) - atompos (:, iatomterm_2 ( 2 , t ))) if ( iatomterm_2 ( 1 , t ). ne . i ) cycle !iloop if ( iatomterm_2 ( 2 , t ). ne . j ) cycle ! jloop if ( rij . ne . dij ) then write ( * , 18 ) 'rij ne dij ' , i , j , rij , dij stop endif write ( * , * ) 'i,j,term2,al,be=' , i , j , term2 , ixyzterm_2 ( 1 , t ), ixyzterm_2 ( 2 , t ) fcd = fcs ( res + igroup_2 ( t )) * ampterm_2 ( t ) if ( ixyzterm_2 ( 1 , t ). eq . ixyzterm_2 ( 2 , t )) then term2 = term2 + 1 trace = trace + fcd !          write(*,*)'al,term2,trace=',ixyz(1),term2,trace endif enddo if ( trace . ne . 0 ) then write ( ulog , 8 ) i , j , rij , trace write ( 456 , 8 ) i , j , rij , trace endif !      if (term2.ne.3) write(456,*)'#ERROR: there are ',term2,' terms for rij=',dij enddo jloop enddo iloop endif close ( 456 ) write ( ulog , * ) '***************** END OF FC Trace ******************' !---------------------------------------- res = res + igroup_2 ( nterms ( rank )) endif rank = 3 if ( include_fc ( rank ) . eq . 1 ) then write ( ufc3 , * ) ' RANK 3 tensors :term,group, (iatom,ixyz)_3 d3U/dx_{i,alpha}&#94;3' do t = 1 , nterms ( rank ) if ( abs ( fcs ( res + igroup_3 ( t )) * ampterm_3 ( t )) . gt . margin ) then write ( ufc3 , 3 ) t , igroup_3 ( t ), & & iatomterm_3 ( 1 , t ), ixyzterm_3 ( 1 , t ), iatomterm_3 ( 2 , t ), ixyzterm_3 ( 2 , t ), & & iatomterm_3 ( 3 , t ), ixyzterm_3 ( 3 , t ), & & fcs ( res + igroup_3 ( t )) * ampterm_3 ( t ), one !& fcs(res+igroup_3(t)),ampterm_3(t) endif enddo do i = 1 , ngroups ( rank ) t = map_3 ( i ) !   write(ulog,3) t,igroup_3(t),  & !& iatomterm_3(1,t),ixyzterm_3(1,t),iatomterm_3(2,t),ixyzterm_3(2,t), & !& iatomterm_3(3,t),ixyzterm_3(3,t),  & !& fcs(res+igroup_3(t)),ampterm_3(t) write ( ulog , 33 ) err_3 ( igroup_3 ( t )), t , igroup_3 ( t ), & & iatomterm_3 ( 1 , t ), ixyzterm_3 ( 1 , t ), iatomterm_3 ( 2 , t ), ixyzterm_3 ( 2 , t ), & & iatomterm_3 ( 3 , t ), ixyzterm_3 ( 3 , t ), & & fcs ( res + igroup_3 ( t )), fcs ( res + igroup_3 ( t )) / ryd * ab * ab * ab , ampterm_3 ( t ) write ( ufit3 , 3 ) t , igroup_3 ( t ), & & iatomterm_3 ( 1 , t ), ixyzterm_3 ( 1 , t ), iatomterm_3 ( 2 , t ), ixyzterm_3 ( 2 , t ), & & iatomterm_3 ( 3 , t ), ixyzterm_3 ( 3 , t ), & & fcs ( res + igroup_3 ( t )) * ampterm_3 ( t ), one !& fcs(res+igroup_3(t)),ampterm_3(t) enddo res = res + igroup_3 ( nterms ( rank )) endif !---------------------------------------- rank = 4 if ( include_fc ( rank ) . eq . 1 ) then write ( ufc4 , * ) ' RANK 4 tensors :term, group, (iatom,ixyz)_4 d4U/dx_{i,alpha}&#94;4' do t = 1 , nterms ( rank ) if ( abs ( fcs ( res + igroup_4 ( t )) * ampterm_4 ( t )) . gt . margin ) then write ( ufc4 , 4 ) t , igroup_4 ( t ), & & iatomterm_4 ( 1 , t ), ixyzterm_4 ( 1 , t ), iatomterm_4 ( 2 , t ), ixyzterm_4 ( 2 , t ), & & iatomterm_4 ( 3 , t ), ixyzterm_4 ( 3 , t ), iatomterm_4 ( 4 , t ), ixyzterm_4 ( 4 , t ), & & fcs ( res + igroup_4 ( t )) * ampterm_4 ( t ), one !& fcs(res+igroup_4(t)),ampterm_4(t) endif enddo do i = 1 , ngroups ( rank ) t = map_4 ( i ) !   write(ulog,4) t,igroup_4(t),  & !& iatomterm_4(1,t),ixyzterm_4(1,t),iatomterm_4(2,t),ixyzterm_4(2,t), & !& iatomterm_4(3,t),ixyzterm_4(3,t),iatomterm_4(4,t),ixyzterm_4(4,t), & !& fcs(res+igroup_4(t)),ampterm_4(t) write ( ulog , 34 ) err_4 ( igroup_4 ( t )), t , igroup_4 ( t ), & & iatomterm_4 ( 1 , t ), ixyzterm_4 ( 1 , t ), iatomterm_4 ( 2 , t ), ixyzterm_4 ( 2 , t ), & & iatomterm_4 ( 3 , t ), ixyzterm_4 ( 3 , t ), iatomterm_4 ( 4 , t ), ixyzterm_4 ( 4 , t ), & & fcs ( res + igroup_4 ( t )), fcs ( res + igroup_4 ( t )) / ryd * ab * ab * ab * ab , ampterm_4 ( t ) write ( ufit4 , 4 ) t , igroup_4 ( t ), & & iatomterm_4 ( 1 , t ), ixyzterm_4 ( 1 , t ), iatomterm_4 ( 2 , t ), ixyzterm_4 ( 2 , t ), & & iatomterm_4 ( 3 , t ), ixyzterm_4 ( 3 , t ), iatomterm_4 ( 4 , t ), ixyzterm_4 ( 4 , t ), & & fcs ( res + igroup_4 ( t )) * ampterm_4 ( t ), one !& fcs(res+igroup_4(t)),ampterm_4(t) enddo res = res + igroup_4 ( nterms ( rank )) endif !---------------------------------------- if ( res . ne . ngr ) then write ( ulog , * ) 'WRITE_OUTPUT: sum(nterms),ngr=' , res , ngr write ( ulog , * ) 'WRITE_OUTPUT: they should be equal!' endif end subroutine write_output_fc !============================================================ subroutine read_fcs_2 ( rank ) ! was this before subroutine read_fcs_2(iunit,rank) use svd_stuff use ios use force_constants_module use atoms_force_constants use params implicit none integer rank , iunit , t , res , i , cnt , k , ti , j , g , l , newfile , a , b , c , d , e , f , reason , rnk real amp , rijs , gh !real(8), allocatable:: fc_ind(:) character line * 99 logical ex !newfile=431 !open(newfile,file=\"fc2.dat\") ! read(newfile,'(a)') line !write(*,*) line t = 0 if ( rank . eq . 1 ) then res = 0 do i = 1 , nterms ( rank ) read ( iunit , * , err = 91 ) t , igroup_1 ( t ), & & iatomterm_1 ( 1 , t ), ixyzterm_1 ( 1 , t ), & & fcs_1 ( igroup_1 ( t )), ampterm_1 ( t ) enddo return 91 write ( ulog , * ) 'READ_FCS: rank=' , rank , ' reached end of file after t=' , t if ( t . eq . 0 ) then nterms ( 1 ) = 1 iatomterm_1 ( 1 : 1 , 1 : 1 ) = 1 ixyzterm_1 ( 1 : 1 , 1 : 1 ) = 1 igroup_1 ( 1 : 1 ) = 0 ampterm_1 ( 1 : 1 ) = 0 include_fc ( rank ) = 0 ! if nothing, then exclude from fitting endif !---------------------------------------- !write(*,*) \"The value of map(2)%ngr is: \", map(2)%ngr elseif ( rank . eq . 2 ) then write ( * , * ) \"Entering into INCLUDE_FC CONDITION 2: \" if ( include_fc ( rank ) . eq . 2 ) then write ( * , * ) \"The value of map(2)%ngr and rank is: \" , map ( 2 )% ngr , rank allocate ( fc_ind ( map ( 2 )% ngr )) inquire ( file = \"fc2_fit.dat\" , exist = ex ) if ( ex ) then open ( 473 , file = \"fc2_fit.dat\" ) do i = 1 , map ( 2 )% ngr read ( 473 , * , iostat = reason ) a , b , c , d , e , f , fc_ind ( i ), amp , rijs if ( reason > 0 ) then write ( * , * ) \"something is wrong\" elseif ( reason < 0 ) then write ( * , * ) \"END OF FILE REACHED\" else write ( * , * ) a , b , c , d , e , f , fc_ind ( i ), amp , rijs endif enddo close ( 473 ) endif endif return !elseif ( rank .eq. 2) then ! res =  igroup_1(nterms(1)) ! do i=1,nterms(rank) !       read(iunit,*,err=92)t,igroup_2(t), & !& iatomterm_2(1,t),ixyzterm_2(1,t),iatomterm_2(2,t),ixyzterm_2(2,t),  & !& fcs_2(igroup_2(t)),ampterm_2(t) ! enddo ! return !92 write(ulog,*)'READ_FCS: rank=',rank,' reached end of file after t=',t !---------------------------------------- elseif ( rank . eq . 3 ) then res = igroup_1 ( nterms ( 1 )) + igroup_2 ( nterms ( 2 )) do i = 1 , nterms ( rank ) read ( iunit , * , err = 93 ) t , igroup_3 ( t ), & & iatomterm_3 ( 1 , t ), ixyzterm_3 ( 1 , t ), iatomterm_3 ( 2 , t ), ixyzterm_3 ( 2 , t ), & & iatomterm_3 ( 3 , t ), ixyzterm_3 ( 3 , t ), & & fcs_3 ( igroup_3 ( t )), ampterm_3 ( t ) enddo return 93 write ( ulog , * ) 'READ_FCS: rank=' , rank , ' reached end of file after t=' , t !---------------------------------------- elseif ( rank . eq . 4 ) then res = igroup_1 ( nterms ( 1 )) + igroup_2 ( nterms ( 2 )) + igroup_3 ( nterms ( 3 )) do i = 1 , nterms ( rank ) read ( iunit , * , err = 94 ) t , igroup_4 ( t ), & & iatomterm_4 ( 1 , t ), ixyzterm_4 ( 1 , t ), iatomterm_4 ( 2 , t ), ixyzterm_4 ( 2 , t ), & & iatomterm_4 ( 3 , t ), ixyzterm_4 ( 3 , t ), iatomterm_4 ( 4 , t ), ixyzterm_4 ( 4 , t ), & & fcs_4 ( igroup_4 ( t )), ampterm_4 ( t ) enddo return 94 write ( ulog , * ) 'READ_FCS: rank=' , rank , ' reached end of file after t=' , t else write ( ulog , * ) ' READ_FCS: rank must be from 1 to 4, not ' , rank endif write ( ulog , * ) 'READ_FCS: error!! should not have gotten here!' if ( rank . ne . 1 . or . rank . ne . 2 . or . rank . ne . 3 . or . rank . ne . 4 ) then stop ! There was stop here endif end subroutine read_fcs_2 !================================================================= subroutine calculate_and_write_displacements use ios use params use lattice use geometry use atoms_force_constants implicit none ! character line*90 integer i , j , t , step real ( 8 ) dc ( 3 ), dr ( 3 ) write ( ulog , * ) ' t , particle#, cartesian disp & forces u1,u2,u3,f1,f2,f3' ! get displacements from positions do t = 1 , nconfigs do i = 1 , natom_super_cell ! first get direct coordinates, then take the distance using pbc, then ! transfrom back to cartesian coordinates dc ( 1 ) = displ ( 1 , i , t ) - atom_sc ( i )% equilibrium_pos % x dc ( 2 ) = displ ( 2 , i , t ) - atom_sc ( i )% equilibrium_pos % y dc ( 3 ) = displ ( 3 , i , t ) - atom_sc ( i )% equilibrium_pos % z call cart_to_direct_aa ( dc , dr ) dr ( 1 ) = dr ( 1 ) - anint ( dr ( 1 )) dr ( 2 ) = dr ( 2 ) - anint ( dr ( 2 )) dr ( 3 ) = dr ( 3 ) - anint ( dr ( 3 )) call direct_to_cart_aa ( dr , displ (:, i , t )) enddo enddo step = nconfigs - 1 if ( verbose ) step = 1 do t = 1 , nconfigs , step ! write first and last displ-force data do i = 1 , natom_super_cell write ( ulog , 6 ) t , i ,( displ ( j , i , t ), j = 1 , 3 ),( force ( j , i , t ), j = 1 , 3 ) enddo enddo 6 format ( 2 ( i5 ), 3 ( 1 x , f10 . 6 ), 3 x , 3 ( 1 x , g12 . 5 )) end subroutine calculate_and_write_displacements !================================================================= subroutine identify_atoms_in_supercell use ios use params use lattice use geometry use atoms_force_constants implicit none ! character line*90 integer i , n1 , n2 , n3 real ( 8 ) a ( 3 ), a1 , a2 , a3 ! check mapping and assign label and address to each atom in the supercell ! this seems to be working for now.... call check_input_poscar_consistency_new write ( ulog , * ) ' n1min, n1max =' , n1min , n1max write ( ulog , * ) ' n2min, n2max =' , n2min , n2max write ( ulog , * ) ' n3min, n3max =' , n3min , n3max write ( ulog , * ) ' ASSIGNMENTS WERE DONE FOR ATOMS IN THE SUPER CELL ' do i = 1 , natom_super_cell !   write(ulog,*) '-----------------------  ATOM NUMBER, tau =',i,atom_sc(i)%cell%tau !   call write_out(ulog,'      type ', atom_sc(i)%atom_type) !   call write_out(ulog,'       tau ', atom_sc(i)%cell%tau) !   call write_out(ulog,'      mass ', atom_sc(i)%mass) !   call write_out(ulog,'     label ', atom_sc(i)%label_in_unit_cell) a1 = atom_sc ( i )% equilibrium_pos . dot . g01 a2 = atom_sc ( i )% equilibrium_pos . dot . g02 a3 = atom_sc ( i )% equilibrium_pos . dot . g03 n1 = nint ( a1 ) n2 = nint ( a2 ) n3 = nint ( a3 ) write ( ulog , 8 ) 'i,tau,type,n,r=' , i , atom_sc ( i )% cell % tau , atom_sc ( i )% at_type , atom_sc ( i )% cell % n , atom_sc ( i )% equilibrium_pos !   write(ulog,5)'   address is= ', atom_sc(i)%cell%n !   call write_out(ulog,' eqlb posn ', atom_sc(i)%equilibrium_pos) ! if( atom_sc(i)%cell%n(1) .ne. n1) write(ulog,*)' address no match n1=',n1,a1 ! if( atom_sc(i)%cell%n(2) .ne. n2) write(ulog,*)' address no match n2=',n2,a2 ! if( atom_sc(i)%cell%n(3) .ne. n3) write(ulog,*)' address no match n3=',n3,a3 ! this not needed as ai need not be integers in case the prim cell is not bravais enddo close ( uposcar ) !3 format(i5,9(2x,g13.6)) !4 format(9(2x,f10.4)) !5 format(a,3(i6,2x)) !7 format(a,9(1x,f10.4)) 8 format ( a , i4 , i3 , i3 , '(' , 3 ( i2 , ',' ), ')' , 3 ( 1 x , f10 . 5 )) write ( ulog , * ) ' POSCAR read successfully and closed' end subroutine identify_atoms_in_supercell !================================================================= subroutine ustring ( m , lineout , nrank , iatom , ixyz ) implicit none integer i , m , n , nrank , iatom ( nrank ), ixyz ( nrank ) character lineout * 80 , xyz ( 3 ) data xyz / 'x' , 'y' , 'z' / !     write(*,*)' Entering ustring with rank=',nrank lineout ( m + 1 : m + 1 ) = 'd' m = m + 1 write ( lineout ( m + 1 : m + 1 ), '(i1)' ) nrank m = m + 1 lineout ( m + 1 : m + 2 ) = 'U/' m = m + 2 do i = 1 , nrank lineout ( m + 1 : m + 2 ) = 'd' // xyz ( ixyz ( i )) m = m + 2 n = iatom ( i ) if ( n . lt . 10 ) then write ( lineout ( m + 1 : m + 1 ), '(i1)' ) n m = m + 1 else if ( n . lt . 100 ) then write ( lineout ( m + 1 : m + 2 ), '(i2)' ) n m = m + 2 else if ( n . lt . 1000 ) then write ( lineout ( m + 1 : m + 3 ), '(i3)' ) n m = m + 3 else write ( lineout ( m + 1 : m + 4 ), '(i4)' ) n m = m + 4 endif enddo !     write(*,*)' Exiting ustring' end subroutine ustring !============================================================ subroutine pos_out_consistency use geometry use ios use params use lattice use atoms_force_constants implicit none integer i real ( 8 ) dr ( 3 ), dc ( 3 ) ! checking consistency between POSCAR:atom_sc%equilibrium_pos and OUTCAR:displ(:,:,1) do i = 1 , natom_super_cell dc = atom_sc ( i )% equilibrium_pos - displ (:, i , 1 ) call cart_to_direct_aa ( dc , dr ) dr ( 1 ) = dr ( 1 ) - anint ( dr ( 1 )) dr ( 2 ) = dr ( 2 ) - anint ( dr ( 2 )) dr ( 3 ) = dr ( 3 ) - anint ( dr ( 3 )) call direct_to_cart_aa ( dr , dc ) !   if (.not.( dc .myeq. 0d0 ) ) then if ( abs ( dc ( 1 )). gt . tolerance . or . abs ( dc ( 2 )). gt . tolerance & & . or . abs ( dc ( 3 )). gt . tolerance ) then !    if ( dc(1).gt.0.1 .or. dc(2).gt.0.1 .or. dc(3).gt.0.1 ) then write ( ulog , * ) ' atom # ' , i , ' in POSCAR and OUTCAR are different' write ( ulog , * ) ' POSCAR:atom_SC=' , atom_sc ( i )% equilibrium_pos write ( ulog , * ) ' OUTCAR: displ =' , displ (:, i , 1 ) write ( ulog , * ) ' check your input files ' write ( * , * ) ' atom # ' , i , ' in POSCAR and OUTCAR are different' write ( * , * ) ' check your input files ' stop endif enddo end subroutine pos_out_consistency !============================================================ subroutine write_correspondance use params use atoms_force_constants use svd_stuff use ios use geometry use force_constants_module use lattice implicit none integer t , ired , nat , iatom , jatom , j integer al , be , taui , tauj , ni ( 3 ), nj ( 3 ), nsi ( 3 ), nsj ( 3 ) real ( 8 ) rij write ( ulog , * ) ' HARMONIC FCs: correspondance between a given FC and all pairs ' write ( ulog , * ) ' Basically we describe the harmonic terms in the Taylor expansion' write ( ulog , * ) ' Which atom pairs in the supercell are bridged by a FC element ' write ( ulog , * ) ' Below, ni refers to the translations of the supercell' write ( ulog , * ) '  i,   taui (nsi),  alpha ;     j,   tauj (nsj),   beta  :   term group  rij ' write ( ucor , * ) '# i,   taui  (ni),  alpha ;     j,   tauj  (nj),   beta  :   term group  rij ' ! do nat=1,natom_super_cell do nat = 1 , natoms0 do al = 1 , 3 ! this is how we order each line !    taui = atom_sc(nat)%cell%tau !    ni   = atom_sc(nat)%cell%n taui = iatomcell0 ( nat ) ni (:) = iatomcell (:, nat ) call findatom_sc ( ni , nat , iatom ) ! now iatom is the supercell index nsi = nint ( matmul ( r0g , dfloat ( ni ))) tloop2 : do t = 1 , nterms ( 2 ) ! ineq. terms and identify neighbors if ( ( taui . eq . iatomterm_2 ( 1 , t )) . and . & !tau belongs to primcl & ( al . eq . ixyzterm_2 ( 1 , t )) ) then ! this is the (tau,al) corresponding to that t, now what is its neighbor j? !  (n1,tau1)=(iatomcell(:,iatomterm(2,t)),iatomcell0(iatomterm(2,t))) j = iatomterm_2 ( 2 , t ) tauj = iatomcell0 ( iatomterm_2 ( 2 , t )) nj (:) = iatomcell (:, iatomterm_2 ( 2 , t )) + ni (:) ! translate by ni nsj = nint ( matmul ( r0g , dfloat ( nj ))) be = ixyzterm_2 ( 2 , t ) ! Identify neighbor j within the SCell, find its displacement and add to ared call findatom_sc ( nj , tauj , jatom ) if ( jatom . eq . 0 ) then write ( ulog , 4 ) 'WRITE_CORRESPONDANCE: jatom not found: tau,n ' , tauj , nj write ( ulog , 4 ) 'for term ' , t write ( ulog , 4 ) 'atom,xyz ' , nat , al stop endif ! if j and j+R(supercell) are in the same group but with opposite ampterms ! then their sum is cancelled in the force as they both have the same ! displacement. This will lead to errors in evaluation of the FCs if all ! terms in the group cancel in this way, and the ! corresponding group in FC2 will be evaluated to be zero. That will also ! affect the ASR and produce a violation of the sum rules. ired = igroup_2 ( t ) ! this is the corresponding index of ared rij = length ( atompos (:, nat ) - atompos (:, j )) write ( ucor , 5 ) iatom , taui , ni , al , jatom , tauj , nj , be , t , ired , rij , ampterm_2 ( t ) write ( ulog , 5 ) iatom , taui , nsi , al , jatom , tauj , nsj , be , t , ired , rij , ampterm_2 ( t ) endif enddo tloop2 enddo enddo write ( ulog , * ) ' Correspondance of harmonic FCs and pairs of atoms established' 4 format ( a , 4 ( 1 x , i6 )) 5 format ( 2 ( i4 , 1 x , ' [ ' , i4 , ' (' , i2 , ',' , i2 , ',' , i2 , ') ] ' , i1 , 2 x ), ' : ' , i6 , 1 x , i4 , 2 x , f7 . 3 , 2 x , f7 . 3 ) end subroutine write_correspondance !============================================================ subroutine write_correspondance2 use params use atoms_force_constants use svd_stuff use ios use geometry use force_constants_module use lattice implicit none integer t , nat , iatom , jatom , l , rnk integer al , be , taui , tauj , ni ( 3 ), nj ( 3 ), nsi ( 3 ), nsj ( 3 ) real ( 8 ) rij rnk = 2 write ( ulog , * ) ' HARMONIC FCs: correspondance between a given FC and all pairs ' write ( ulog , * ) ' Basically we describe the harmonic terms in the Taylor expansion' write ( ulog , * ) ' Which atom pairs in the supercell are bridged by a FC element ' write ( ulog , * ) ' Below, ni refers to the translations of the supercell' write ( ulog , * ) '  i,    taui (nsi)        ;   j,    tauj (nsj)          :   term  group   rij ' write ( ucor , * ) '# i,    taui (ni),  alpha ;   j,    tauj  (nj),   beta  :   term  group   rij ' ! do nat=1,natom_super_cell do nat = 1 , natoms0 do al = 1 , 3 ! this is how we order each line !    taui = atom_sc(nat)%cell%tau !    ni   = atom_sc(nat)%cell%n taui = iatomcell0 ( nat ) ni (:) = iatomcell (:, nat ) call findatom_sc ( ni , nat , iatom ) ! now iatom is the supercell index nsi = nint ( matmul ( r0g , dfloat ( ni ))) do l = 1 , map ( rnk )% ngr ! sum over groups !           if(l.gt.1) cnt2 = cnt2 + map(rnk)%ntind(l-1) do t = 1 , map ( rnk )% nt ( l ) ! sum over all terms in that group if ( taui . eq . map ( rnk )% gr ( l )% iat ( 1 , t ) . and . & & al . eq . map ( rnk )% gr ( l )% ixyz ( 1 , t ) ) then tauj = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 2 , t )) nj (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 2 , t )) + ni (:) ! trnslte by ni nsj = nint ( matmul ( r0g , dfloat ( nj ))) be = map ( rnk )% gr ( l )% ixyz ( 2 , t ) ! Identify neighbor j within the SCell, call findatom_sc ( nj , tauj , jatom ) if ( jatom . eq . 0 ) then write ( ulog , 4 ) 'WRITE_CORRESPONDANCE2:jatom not found: tau,n ' , tauj , nj write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al stop endif ! if j and j+R(supercell) are in the same group but with opposite ampterms ! then their sum is cancelled in the force as they both have the same ! displacement. This will lead to errors in evaluation of the FCs if all ! terms in the group cancel in this way, and the ! corresponding group in FC2 will be evaluated to be zero. That will also ! affect the ASR and produce a violation of the sum rules. !              ired = igroup_2(t)  ! this is the corresponding index of ared rij = length ( atompos (:, nat ) - atompos (:, jatom )) !      write(ucor,5)iatom,taui,ni,al,jatom,tauj,nj,be,t,ired,rij,ampterm_2(t) write ( ucor , 6 ) iatom , taui , ni , al , jatom , tauj , nj , be , t , l , rij if ( al . eq . 1 . and . be . eq . 1 ) write ( ulog , 5 ) iatom , taui , nsi , jatom , tauj , nsj , t , l , rij endif enddo enddo enddo enddo write ( ulog , * ) ' Correspondance of harmonic FCs and pairs of atoms established' 4 format ( a , 4 ( 1 x , i6 )) 5 format ( 2 ( i4 , 1 x , ' [ ' , i4 , ' (' , i2 , ',' , i2 , ',' , i2 , ') ] ' , 2 x ), ':' , i6 , 1 x , i4 , 2 x , f7 . 3 , 2 x , f7 . 3 ) 6 format ( 2 ( i4 , 1 x , ' [ ' , i4 , ' (' , i2 , ',' , i2 , ',' , i2 , ') ] ' , i1 , 2 x ), ':' , i6 , 1 x , i4 , 2 x , f7 . 3 , 2 x , f7 . 3 ) end subroutine write_correspondance2 !============================================================ subroutine warn ( unt ) implicit none integer unt write ( unt , * ) '********************************************************************' write ( unt , * ) '|                                                                  |' write ( unt , * ) '|                                                                  |' write ( unt , * ) '|      W    W    AA    RRRRR   N    N  II  N    N   GGGG   !!!     |' write ( unt , * ) '|      W    W   A  A   R    R  NN   N  II  NN   N  G    G  !!!     |' write ( unt , * ) '|      W    W  A    A  R    R  N N  N  II  N N  N  G       !!!     |' write ( unt , * ) '|      W WW W  AAAAAA  RRRRR   N  N N  II  N  N N  G  GGG   !      |' write ( unt , * ) '|      WW  WW  A    A  R   R   N   NN  II  N   NN  G    G          |' write ( unt , * ) '|      W    W  A    A  R    R  N    N  II  N    N   GGGG   !!!     |' write ( unt , * ) '|                                                                  |' write ( unt , * ) '|   There MIGHT be FC cancellation in the sum and perhaps errors   |' write ( unt , * ) '|                                                                  |' write ( unt , * ) '********************************************************************' end subroutine warn !============================================================ subroutine write_lat_fc ( ngrps , ntrms ) use svd_stuff use ios use force_constants_module use atoms_force_constants use params use lattice use constants implicit none real ( 8 ) rij integer i , j , ngrps ( 4 ), ntrms ( 4 ), j_sc write ( ufco , * ) ' Crystal data: translation vectors of the primitive cell ' write ( ufco , 9 ) r01 write ( ufco , 9 ) r02 write ( ufco , 9 ) r03 write ( ufco , * ) ' Crystal data: atoms in primitive cell: label,type,x,y,z,mass ' write ( ufco , * ) natoms0 do i = 1 , natoms0 write ( ufco , 6 ) i , atom0 ( i )% name , atom0 ( i )% at_type , atom0 ( i )% equilibrium_pos , atom0 ( i )% mass enddo write ( ufco , * ) ' Crystal data written ************************************' write ( ufco , * ) ' Included ranks of FCs ' write ( ufco , * ) include_fc ( 1 ), include_fc ( 2 ), include_fc ( 3 ), include_fc ( 4 ) write ( ufco , * ) ' Number of FCs for each rank ' write ( ufco , * ) ntrms ( 1 ), ntrms ( 2 ), ntrms ( 3 ), ntrms ( 4 ) write ( ufco , * ) ' Number of independent FCs for each rank ' write ( ufco , * ) ngrps ( 1 ), ngrps ( 2 ), ngrps ( 3 ), ngrps ( 4 ) write ( ufco , * ) ' Neighborshell atoms: i,x,y,z,type_tau,n1,n2,n3 ' write ( ufco , * ) natoms do i = 1 , natoms rij = length ( atompos (:, i ) - atompos (:, 1 )) write ( ufco , 7 ) i ,( atompos ( j , i ), j = 1 , 3 ), iatomcell0 ( i ),( iatomcell ( j , i ), j = 1 , 3 ), rij enddo open ( 173 , file = 'primlatt.xyz' ) write ( 173 , * ) natoms0 write ( 173 , * ) ngrps ( 1 ), ngrps ( 2 ), ngrps ( 3 ), ngrps ( 4 ) do i = 1 , natoms0 write ( 173 , 8 ) atom0 ( i )% name , atom0 ( i )% equilibrium_pos !  write(173,7)atom0(i)%name,(atompos(j,i),j=1,3) enddo close ( 173 ) open ( 173 , file = 'latfc.xyz' ) write ( 173 , * ) natoms write ( 173 , * ) ngrps ( 1 ), ngrps ( 2 ), ngrps ( 3 ), ngrps ( 4 ) do i = 1 , natoms call findatom_sc ( iatomcell (:, i ), iatomcell0 ( i ), j_sc ) ! (=n(3),tau) write ( 173 , 8 ) atom0 ( iatomcell0 ( i ))% name ,( atompos ( j , i ), j = 1 , 3 ), j_sc enddo close ( 173 ) 6 format ( 2 x , i5 , 1 x , a2 , 2 x , i5 , 9 ( 2 x , f19 . 10 )) 7 format ( 1 ( 2 x , i5 ), 3 ( 2 x , f19 . 10 ), 4 ( 2 x , i5 ), 2 x , f9 . 5 ) 8 format ( a , 3 ( 2 x , f19 . 10 ), i6 ) 9 format ( 9 ( 2 x , f19 . 10 )) end subroutine write_lat_fc !============================================================","tags":"","loc":"sourcefile/ios.f90.html"},{"title":"extratools.f90 – Example Project","text":"finds the index n of the coarse kpoint defined with 3 loop indices\nijk going from 1 to ni , i being the outer loop and k the inner one This file depends on sourcefile~~extratools.f90~~EfferentGraph sourcefile~extratools.f90 extratools.f90 sourcefile~modules9.f90 modules9.f90 sourcefile~extratools.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions fcut delta delta_g delta_l nbe indexg indexn trace Subroutines findword findatom_sc make_r0g check check_d calculate_distance sort calculate_volume make_reciprocal_lattice make_reciprocal_lattice_2pi find_root check_inside_bz check_inside_fbz check_inside_irred_fbz2 check_inside_irred_fbz select_IBZ make_sorted_gs get_direct_components comp1 comp_c get_components_g get_components_g_centered set_neighbork send_to_fbz send_to_primcell inverse_real mean_sd histogram Source Code extratools.f90 Source Code !============================================================================= subroutine findword ( word , line , found ) ! says if the string \"word\" exists in string \"line\" implicit none logical found character ( * ) line , word integer i , l , k l = len_trim ( line ); k = len_trim ( word ) found = . False . do i = 1 , l - k + 1 if ( line ( i : i + k - 1 ) . eq . word ( 1 : k )) then found = . True . exit endif enddo end subroutine findword !====================================================================================== subroutine findatom_sc ( n3 , tau , iatom ) ! finds the index of the atom in supercell with identity (n3[modulo supercell],tau) ! arguments: !     n3(3) (input), linear combination of basis vectors of the primitive !          lattice that takes us to the unit cell containing the ith atom !     tau (input), identity of equivalent atom in unit cell at origin !     iatom (output), index of equivalent atom in supercell. Returns zero if not found use geometry use lattice use ios use atoms_force_constants implicit none integer , intent ( in ) :: n3 ( 3 ), tau integer j , m ( 3 ) integer , intent ( out ) :: iatom real ( 8 ) a ( 3 ), zero ( 3 ) ! first check to see if it is one of the sc atoms zero = 0 d0 iatom = 0 jloop : do j = 1 , natom_super_cell if ( atom_sc ( j )% cell % tau . eq . tau ) then m = atom_sc ( j )% cell % n - n3 ! find direct coordinates of n3 - n(j) and see if it is integer a = matmul ( r0g , dfloat ( m )) ! if the 3 components of a are integer, then iatom=j !             m = floor(a+0.00001) !             b = a - m !             if (b .myeq. zero ) then !                iatom = j !                return !             endif if ( abs ( a ( 1 ) - nint ( a ( 1 ))). lt . 0.0001 . and . & & abs ( a ( 2 ) - nint ( a ( 2 ))). lt . 0.0001 . and . & & abs ( a ( 3 ) - nint ( a ( 3 ))). lt . 0.0001 ) then iatom = j exit jloop endif endif enddo jloop end subroutine findatom_sc !====================================================================== subroutine make_r0g ! matmul(r0g,n) gives the 3 reduced coordinates of the primcell of index n in units of the supercell ri's ! matmul(r0g,v) gives the 3 reduced coordinates of an atom in the supercell if its ! reduced coordinates in the primitive cell are given by v use lattice implicit none r0g ( 1 , 1 ) = r01 . dot . g1 r0g ( 2 , 1 ) = r01 . dot . g2 r0g ( 3 , 1 ) = r01 . dot . g3 r0g ( 1 , 2 ) = r02 . dot . g1 r0g ( 2 , 2 ) = r02 . dot . g2 r0g ( 3 , 2 ) = r02 . dot . g3 r0g ( 1 , 3 ) = r03 . dot . g1 r0g ( 2 , 3 ) = r03 . dot . g2 r0g ( 3 , 3 ) = r03 . dot . g3 end subroutine make_r0g !============================================================ subroutine check ( r , a1 , a2 , a3 , ier , g1 , g2 , g3 ) ! subroutine to check whether r is an integer multiple of (r01,r02,r03) ! output ai are the coefficients of its linear combination on this basis ! ier=0 means r is an integer multiple of the basis use geometry use params use ios implicit none type ( vector ) :: r , g1 , g2 , g3 real ( 8 ) a1 , a2 , a3 , ep integer ier ep = tolerance ! 0.001 ! displacements larger than 0.001 A are not tolerated !call write_out(ulog,'CHECK: R ',r) a1 = r . dot . g1 a2 = r . dot . g2 a3 = r . dot . g3 if ( abs ( a1 - nint ( a1 )). ge . ep . or . abs ( a2 - nint ( a2 )). ge . ep & & . or . abs ( a3 - nint ( a3 )). ge . ep ) then !  write(ulog,*) ' R is not a multiple of r0s , check your inputs ' !  write(ulog,*) ' R.r0i=',a1,a2,a3 ier = 1 !  stop else !  write(ulog,*) ' R is a multiple of r0s' !  write(ulog,3) ' n1,n2,n3  =',a1,a2,a3 ier = 0 endif !3 format(a,3(1x,g13.6)) end subroutine check !============================================================ subroutine check_d ( r , a1 , a2 , a3 , ier ) ! subroutine to check whether r is an integer vector ! output ai are the coefficients of its linear combination on this basis ! ier=0 means r is an integer multiple of the basis use geometry use params use ios implicit none type ( vector ) :: r real ( 8 ) a1 , a2 , a3 , ep integer ier ep = tolerance ! 1d-3 !call write_out(ulog,'CHECK: R ',r) a1 = r % x a2 = r % y a3 = r % z if ( abs ( a1 - nint ( a1 )). ge . ep . or . abs ( a2 - nint ( a2 )). ge . ep & & . or . abs ( a3 - nint ( a3 )). ge . ep ) then ier = 1 else ier = 0 endif end subroutine check_d !====================================================================== function fcut ( x , x1 , x2 ) result ( y ) implicit none real ( 8 ), intent ( in ) :: x , x1 , x2 real ( 8 ) y if ( x . lt . x1 ) then y = 1 elseif ( x . gt . x2 ) then y = 0 else y = 0.5 * ( 1 + cos ( 3.1415926 * ( x - x1 ) / ( x2 - x1 ))) endif end function fcut !===================================================================== subroutine calculate_distance ( i , j , atompos , maxatoms , rij ) implicit none integer i , j , maxatoms real ( 8 ) atompos ( 3 , maxatoms ), rij rij = sqrt ( ( atompos ( 1 , i ) - atompos ( 1 , j )) * ( atompos ( 1 , i ) - atompos ( 1 , j )) + & & ( atompos ( 2 , i ) - atompos ( 2 , j )) * ( atompos ( 2 , i ) - atompos ( 2 , j )) + & & ( atompos ( 3 , i ) - atompos ( 3 , j )) * ( atompos ( 3 , i ) - atompos ( 3 , j )) ) end subroutine calculate_distance !============================================================ subroutine sort ( n , r , mcor , maxat ) ! sorts the first n elements of array r in ascending order r(mcor(i)) is the ordered array ! make sure to initialize the array r to a huge number if n\\=maxat implicit none integer maxat , n , i , j , temp real ( 8 ) r ( maxat ) integer mcor ( maxat ) do i = 1 , maxat ! n mcor ( i ) = i enddo do i = 1 , n ! was 1,n-1 do j = i + 1 , maxat ! was i+1,n if ( r ( mcor ( i )). gt . r ( mcor ( j ))) then temp = mcor ( i ) mcor ( i ) = mcor ( j ) mcor ( j ) = temp endif enddo enddo !  r(mcor) is now the ordered array! end subroutine sort !============================================================ subroutine calculate_volume ( r1 , r2 , r3 , om ) use geometry implicit none real ( 8 ) om type ( vector ) cross , r1 , r2 , r3 cross = r1 . cross . r2 om = abs ( r3 . dot . cross ) end subroutine calculate_volume !=============================================================== subroutine make_reciprocal_lattice ( r1 , r2 , r3 , g1 , g2 , g3 ) ! be careful it does not have the factor of 2*pi in it! use geometry use constants use ios implicit none type ( vector ) :: r1 , r2 , r3 , g1 , g2 , g3 real ( 8 ) om om = r1 . dot . ( r2 . cross . r3 ) ! write(ulog,*)'RECIPROCAL_LATTICE: ' g1 = ( r2 . cross . r3 ) / om g2 = ( r3 . cross . r1 ) / om g3 = ( r1 . cross . r2 ) / om ! call write_out(ulog,'om ',om) ! call write_out(ulog,'g1 ',g1) ! call write_out(ulog,'g2 ',g2) ! call write_out(ulog,'g3 ',g3) end subroutine make_reciprocal_lattice !=============================================================== subroutine make_reciprocal_lattice_2pi ( r1 , r2 , r3 , g1 , g2 , g3 ) ! be careful it does not have the factor of 2*pi in it! use geometry use constants use ios implicit none type ( vector ) :: r1 , r2 , r3 , g1 , g2 , g3 real ( 8 ) om om = r1 . dot . ( r2 . cross . r3 ) write ( ulog , * ) 'RECIPROCAL_LATTICE: ' g1 = 2 * pi * ( r2 . cross . r3 ) / om g2 = 2 * pi * ( r3 . cross . r1 ) / om g3 = 2 * pi * ( r1 . cross . r2 ) / om call write_out ( ulog , 'om ' , om ) call write_out ( ulog , 'g1 ' , g1 ) call write_out ( ulog , 'g2 ' , g2 ) call write_out ( ulog , 'g3 ' , g3 ) end subroutine make_reciprocal_lattice_2pi !========================================================== function delta ( x ) result ( y ) use constants implicit none real ( 8 ) x , y y = exp ( - x * x / 2 d0 ) / sqrt ( 2 * pi ) end function delta !========================================================== function delta_g ( x , w ) result ( y ) use constants implicit none real ( 8 ) x , y , w y = exp ( - x * x / 2 d0 / w / w ) / sqrt ( 2 * pi ) / w end function delta_g !========================================================== function delta_l ( x , w ) result ( y ) use constants implicit none real ( 8 ) x , y , w y = w / ( x * x + w * w ) / pi end function delta_l !=========================================================== function nbe ( w , t , m ) result ( y ) implicit none real ( 8 ) , intent ( in ) :: w , t real ( 8 ) y , z integer m if ( t . le . 0 ) then write ( * , * ) 'ERROR in N_BE: t=<0 ' , t stop endif if ( w . le . 0 ) then write ( * , * ) 'ERROR in N_BE: w=<0 ' , w stop endif z = w / t if ( m . eq . 0 ) then ! quantum calculation if ( z . gt . 60 ) then y = 0 elseif ( z . lt . 0.0010 ) then y = 1 / ( z * ( 1 + z / 2 * ( 1 + z / 3 ))) else y = 1 / ( exp ( z ) - 1 ) endif elseif ( m . eq . 1 ) then ! classical calculation y = 1 / z else print * , 'NBE: m must be either 0 or 1, not ' , m stop endif end function nbe !=========================================================== subroutine find_root ( fcn , x1 , x2 , root ) implicit none real ( 8 ) :: x1 , x2 , root , fcn , error , fcnroot , fx1 integer counter external fcn counter = 0 error = 0.0000001 fx1 = fcn ( x1 ) if ( fx1 * fcn ( x2 ). gt . 0 ) then print * , 'bad guess for initial root brackets ' , x1 , x2 , fx1 stop endif fcnroot = 100000000 do while ( dabs ( fcnroot ). gt . error ) counter = counter + 1 if ( counter . gt . 50 ) then print * , 'find_root did not converge after 50 iterations' print * , 'guessed root,f(root)=' , root , fcnroot stop endif root = ( x1 + x2 ) / 2. fcnroot = fcn ( root ) if ( fcnroot * fx1 . lt . 0 ) then x2 = root else x1 = root fx1 = fcnroot endif enddo end subroutine find_root !=========================================================== subroutine check_inside_bz ( q , g1 , g2 , g3 , inside ) use geometry ! this one is in accordane with make_kp_reg with even nki, and zero shift ! between 0,gi before shifting by (g1+g2+g3)/2 implicit none type ( vector ) g1 , g2 , g3 real ( 8 ) q ( 3 ), qx , qy , qz , q2 ( 3 ) ! integer n integer inside ! first shift q by  (g1+g2+g3)/2 q2 = q + 0.5d0 * ( g1 + g2 + g3 ) ! then find its reduced coordinates call get_direct_components ( q2 , qx , qy , qz , g1 , g2 , g3 , inside ) end subroutine check_inside_bz !=========================================================== subroutine check_inside_fbz ( q , g1 , g2 , g3 , inside ) use geometry use constants implicit none logical inside type ( vector ) g1 , g2 , g3 real ( 8 ) qdotg , gg , gt ( 3 ), sm , q ( 3 ) sm = - . 000001 ! on the boundary is also counted as inside, but once only inside = . false . !------------------- along the diagonal 100 qdotg = ( q . dot . g1 ) + sm gg = g1 . dot . g1 if ( abs ( qdotg ) . gt . gg / 2 ) return ! this is the Bragg condition |q.G| < G.G/2 qdotg = ( q . dot . g2 ) + sm gg = g2 . dot . g2 if ( abs ( qdotg ) . gt . gg / 2 ) return qdotg = ( q . dot . g3 ) + sm gg = g3 . dot . g3 if ( abs ( qdotg ) . gt . gg / 2 ) return !------------------- along the diagonal 110 gt = g1 + g2 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 - g2 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 + g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 - g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g3 + g2 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g3 - g2 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return !------------------- along the diagonal 111 gt = g1 + g2 + g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 + g2 - g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 - g2 + g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return gt = g1 - g2 - g3 qdotg = ( q . dot . gt ) + sm gg = gt . dot . gt if ( abs ( qdotg ) . gt . gg / 2 ) return !------------------- inside = . true . end subroutine check_inside_fbz !=========================================================== subroutine check_inside_irred_fbz2 ( k , inside ) ! assuming k is inside FBZ, this checks whether it is inside the irreducible FBZ ! the case of FCC and hexagonal are treated here. use lattice use constants implicit none real ( 8 ) k ( 3 ), kdg , q2 logical inside , inx ! this is for FCC ! if( (abs(k(3)).lt.1d-9 .or. (k(3) >= 0)) .and. (k(3) <= k(2)) .and. (k(2) <= k(1)) & !&    .and. (k(1) <= boxg(1))  .and.  (k(1)+k(2)+k(3) <= 3.5d0*boxg(1)/2d0) ) then !    inside = .true.  ! this goes 15% beyond the FBZ boundary ! else !    inside = .false. !    write(444,*)k ! endif ! this is for a 2d hexagonal lattice (ex: graphene) inx = . false . ; inside = . false . if ( abs ( k ( 3 )). lt . 1 d - 3 ) then kdg = k ( 1 ) * g1 % x + k ( 2 ) * g1 % y q2 = g1 % x * g1 % x + g1 % y * g1 % y if ( kdg . lt . q2 / 2 . and . kdg . ge . 0 ) inx = . true . kdg = k ( 1 ) * g2 % x + k ( 2 ) * g2 % y q2 = g2 % x * g2 % x + g2 % y * g2 % y if ( kdg . lt . q2 / 2 . and . kdg . ge . 0 ) inside = inx !   write(6,9)'k,g01,g02=',k,g1,g2,kdg,q2 endif !if (inside) write(444,*)\"k HEX=\",k !9 format(a,99(1x,f6.3)) end subroutine check_inside_irred_fbz2 !=========================================================== subroutine check_inside_irred_fbz ( k , inside ) ! assuming kp is inside FBZ, this checks whether it is inside the irreducible FBZ of FCC use lattice use constants implicit none real ( 8 ) k ( 3 ) logical inside if ( ( abs ( k ( 3 )). lt . 1 d - 9 . or . ( k ( 3 ) >= 0 )) . and . ( k ( 3 ) <= k ( 2 )) . and . ( k ( 2 ) <= k ( 1 )) & & . and . ( k ( 1 ) <= boxg ( 1 )) . and . ( k ( 1 ) + k ( 2 ) + k ( 3 ) <= 3 d0 * boxg ( 1 ) / 2 d0 ) ) then inside = . true . else inside = . false . write ( 444 , * ) k endif end subroutine check_inside_irred_fbz !=========================================================== subroutine select_IBZ ( nbz , kbz , nib , kib ) ! for a given kpoint mesh kbz within the FBZ, this routine stores ! those which are in the irreducible FBZ into kib use lattice implicit none integer nbz , i , nib real ( 8 ) kbz ( 3 , nbz ), q ( 3 ), kib ( 3 , nbz ) logical inside ! real(8), allocatable kib(:,:),ki(:,:) !  allocate(ki(3,nkfine)) nib = 0 kib = 0 do i = 1 , nbz q (:) = kbz (:, i ) call check_inside_irred_fbz2 ( q , inside ) if ( inside ) then nib = nib + 1 kib (:, nib ) = q (:) endif enddo ! allocate(kib(3,ni)) ! do i=1,ni !    kib(:,i)=ki(:,i) ! enddo ! deallocate(ki) end subroutine select_IBZ !============================================================ function indexg ( i , j , k , nil , njl , njh , nkl , nkh ) result ( n ) ! function indexg(i,j,k,nil,nih,njl,njh,nkl,nkh) result(n) ! finds the index n of the kpoint defined with 3 loop indices ! ijk going in general from nil to nih, njl to njh nkl to nkh ! n=0; do i1=nil,nih; do j=njl,njh; do k=nkl,nkh; n=n+1 implicit none integer i , j , k , nil , njl , njh , nkl , nkh , n n = ( k - nkl + 1 ) + ( j - njl ) * ( nkh - nkl + 1 ) + ( i - nil ) * ( njh - njl + 1 ) * ( nkh - nkl + 1 ) end function indexg !============================================================ function indexn ( i , j , k , n1 , n2 , n3 ) result ( n ) ! finds the index n of the coarse kpoint defined with 3 loop indices ! ijk going from -ni to ni implicit none integer i , j , k , n1 , n2 , n3 , n n = ( k + n3 + 1 ) + ( j + n2 ) * ( 2 * n3 + 1 ) + ( i + n1 ) * ( 2 * n2 + 1 ) * ( 2 * n3 + 1 ) end function indexn !============================================================ ! function index_reg(i,j,k,n1,n2,n3) result(n) !! finds the index n of the coarse kpoint defined with 3 loop indices !! ijk going from 1 to ni , i being the outer loop and k the inner one ! implicit none ! integer i,j,k,n1,n2,n3,n ! ! n = k + (j-1)*n3 + (i-1)*n2*n3 ! ! end function index_reg !=========================================================== subroutine make_sorted_gs ( g1 , g2 , g3 , nshell , gg ) ! from the basis (g1,g2,g3) generate the nshell shortest linear combinations including 0 use geometry ! use io2 implicit none integer nshell , i , j , k , n5 , ik , ns type ( vector ) :: g1 , g2 , g3 real ( 8 ) gg ( 3 , nshell ) real ( 8 ), allocatable :: g5 (:,:), gs (:) integer , allocatable :: xmap (:) ns = nint (( 2 * nshell + 1 ) ** ( 0.3333 )) n5 = ( 2 * ns + 1 ) ** 3 allocate ( g5 ( 3 , n5 ), gs ( n5 ), xmap ( n5 ) ) ik = 0 do i =- ns , ns do j =- ns , ns do k =- ns , ns ik = ik + 1 g5 (:, ik ) = i * g1 + j * g2 + k * g3 gs ( ik ) = length ( g5 (:, ik )) enddo enddo enddo ! now sort g2 in ascending order call sort ( n5 , gs , xmap , n5 ) do i = 1 , nshell gg (:, i ) = g5 (:, xmap ( i )) write ( 30 , 3 ) i , gg (:, i ), length ( gg (:, i )) enddo 3 format ( i6 , 9 ( 2 x , g11 . 4 )) deallocate ( g5 , xmap , gs ) end subroutine make_sorted_gs !============================================================ ! subroutine get_direct_components(q,n,qx,qy,qz,g1,g2,g3,inside) subroutine get_direct_components ( q , qx , qy , qz , g1 , g2 , g3 , inside ) ! for a given q-vector, it finds its direct components assuming it was ! created as: q=qx*g1+qy*g2+qz*g3 ! if the integer variable inside=1 then q is inside the primcell, defined ! by [0:g1[,[0:g2[,[0:g3[ ; if inside=0 it's outside use geometry implicit none real ( 8 ), intent ( in ) :: q ( 3 ) type ( vector ), intent ( in ) :: g1 , g2 , g3 type ( vector ) rr1 , rr2 , rr3 ! integer, intent(in):: n(3) integer , intent ( out ) :: inside real ( 8 ), intent ( out ) :: qx , qy , qz real ( 8 ) epsl epsl = 5 d - 10 call make_reciprocal_lattice ( g1 , g2 , g3 , rr1 , rr2 , rr3 ) ! no factor of 2pi inside = 1 qx = ( q . dot . rr1 ) + epsl if ( qx . lt . 0 . or . qx . ge . 1 ) inside = 0 ! write(*,7)'i,qdotr,aux=',i,qdr,aux qy = ( q . dot . rr2 ) + epsl if ( qy . lt . 0 . or . qy . ge . 1 ) inside = 0 qz = ( q . dot . rr3 ) + epsl if ( qz . lt . 0 . or . qz . ge . 1 ) inside = 0 !7 format(a,i5,9(1x,g12.5)) end subroutine get_direct_components !============================================================ subroutine comp1 ( q , rr , n , i , insid ) ! inside would be =1 if 0<q<1 use geometry implicit none real ( 8 ) q ( 3 ), aux , qdr , epsl type ( vector ) rr integer n , i , insid epsl = 5 d - 10 qdr = ( q . dot . rr ) + epsl ! include from -0.00005 to 0.99995 included (include 0.0 and exclude 1.0) if ( qdr . lt . 0 . or . qdr . ge . 1 ) insid = 0 aux = qdr - floor ( qdr ) i = nint ( 1 + n * aux ) ! write(*,7)'i,qdotr,aux=',i,qdr,aux if ( i . eq . n + 1 ) i = 1 !7 format(a,i5,9(1x,g12.5)) end subroutine comp1 !============================================================ subroutine comp_c ( q , rr , n , i , insid ) ! inside would be =1 if -0.5<q<0.5 use geometry implicit none real ( 8 ) q ( 3 ), aux , qdr type ( vector ) rr integer n , i , insid qdr = ( q . dot . rr ) ! include from -0.00005 to 0.99995 included (include 0.0 and exclude 1.0) if ( qdr . lt . - 0.5d0 . or . qdr . ge . 0.5d0 ) insid = 0 ! in order to get i, bring qdr between 0 and 1 by adding 0.5 aux = 0.5d0 + qdr - floor ( qdr + 0.5d0 ) i = nint ( 1 + n * aux ) ! write(*,7)'i,qdotr,aux=',i,qdr,aux if ( i . eq . n + 1 ) i = 1 !7 format(a,i5,9(1x,g12.5)) end subroutine comp_c !============================================================ subroutine get_components_g ( q , n , i , j , k , inside ) ! subroutine get_components_g(q,n,i,j,k,gg1,gg2,gg3,inside) ! for a given q-vector, it finds its integer components assuming it was ! created as: q=(i-1)/n1*g1 + (j-1)/n2*g2 + (k-1)/n3*g3; i=1,n1 j=1,n2 k=1,n3 ! as the ones created in make_kp_reg with zero shift ! if the integer variable inside=1 then q is inside the primcell ! if q is outside the prim_cell, then inside=0 but produces the i,j,k of its ! image inside use lattice use geometry implicit none real ( 8 ), intent ( in ) :: q ( 3 ) ! type(vector),intent(in):: gg1,gg2,gg3 ! type(vector)rx1,rx2,rx3 integer , intent ( in ) :: n ( 3 ) integer , intent ( out ) :: i , j , k , inside ! call make_reciprocal_lattice(g1,g2,g3,rr1,rr2,rr3) ! i = nint(1+ n(1)* q.dot.r1) ! j = nint(1+ n(2)* q.dot.r2) ! k = nint(1+ n(3)* q.dot.r3) ! if q.dot.r is larger than 1, we want to have its fractional part inside = 1 call comp1 ( q , rr1 , n ( 1 ), i , inside ) call comp1 ( q , rr2 , n ( 2 ), j , inside ) call comp1 ( q , rr3 , n ( 3 ), k , inside ) end subroutine get_components_g !============================================================ subroutine get_components_g_centered ( q , n , i , j , k , inside ) ! subroutine get_components_g_centered(q,n,i,j,k,gg1,gg2,gg3,inside) ! for a given q-vector, it finds its integer components assuming it was ! created as: q=(i-1-n1/2)/n1*g1 + (j-1-n2/2)/n2*g2 + (k-1-n3/2)/n3*g3; ! i=1,n1 j=1,n2 k=1,n3 ! as the ones created in make_kp_reg with zero shift ! if the integer variable inside=1 then q is inside the primcell, if inside=0 it's outside ! it works even if there's a shift less than 0.5, and if q is oustide the prim_cell use geometry use lattice implicit none real ( 8 ), intent ( in ) :: q ( 3 ) ! type(vector),intent(in):: gg1,gg2,gg3 integer , intent ( in ) :: n ( 3 ) integer , intent ( out ) :: i , j , k , inside ! real(8) w(3) ! w = q+0.5d0*(gg1+gg2+gg3) ! write(*,8)'q=',q ! write(*,8)'w=',w inside = 1 call comp_c ( q , rr1 , n ( 1 ), i , inside ) call comp_c ( q , rr2 , n ( 2 ), j , inside ) call comp_c ( q , rr3 , n ( 3 ), k , inside ) ! write(*,*)'w-components,inside are=',i,j,k ,inside end subroutine get_components_g_centered !=========================================================== subroutine set_neighbork ( nkp , kp , nb , nbk , nbmax , kcutoff , nshl , gg ) ! finds the list of neighbors to the nkp vectors kp within kcutoff but ! a maximum of nbmax per vector. Output is nb(i,l) which is the ! label of the lth neighbor of the ith vector, and nbk(i)( nbmax), ! which is the total no of neighbors of ith vector within kcutoff ! periodic structure for the kmesh is assumed : supercell is (g1,g2,g3) ! if no pbc should be applied, set nshl = 1 use geometry use lattice use ios implicit none integer nkp , i , j , nbmax , l , sh , nshl , sh0 integer nb ( nkp , nbmax ), nbk ( nkp ) real ( 8 ) kp ( 3 , nkp ), q2 ( 3 ), qw ( 3 ), gg ( 3 , nshl ), dismin , kcutoff , kdist write ( ulog , * ) 'SET_NEIGHBORK: kp#, neighbr#, kpnghbr#, kp,kdist,deltak,sh0' nb = 0 do i = 1 , nkp l = 0 jloop : do j = 1 , nkp if ( i . eq . j ) cycle jloop dismin = 1 d9 do sh = 1 , nshl q2 = kp (:, i ) - kp (:, j ) + gg (:, sh ) kdist = length ( q2 ) if ( kdist . lt . dismin ) then dismin = kdist qw = q2 sh0 = sh endif enddo ! this has selected among kp(j) and its images the nearest one to kp(i) if ( dismin . lt . kcutoff ) then if ( l . lt . nbmax ) then l = l + 1 nb ( i , l ) = j write ( ulog , 6 ) i , l , nb ( i , l ), kp (:, i ), dismin , qw , sh0 else !          write(ulog,*)'neighbor # too small, increase nbmax from ',nbmax endif else !          write(ulog,*)'neighbor # too small, or decrease kcutoff from ',kcutoff !          stop endif enddo jloop nbk ( i ) = l enddo ! nbmax=max(l,1)  ! in case l = 0 (one kpoint) ! if (nbmax .eq.1) then !    nb(1,1)=1 ! endif write ( ulog , * ) 'SET_NEIGHBORK: largest no of neighbors=nbkmax,nshl=' , nbmax , nshl 6 format ( 3 ( i8 ), 7 ( 2 x , f9 . 4 ), 1 x , i4 ) end subroutine set_neighbork !=========================================================== subroutine send_to_fbz ( kp , nshl , gg , q , ns ) ! folds the kpoint kp into the FBZ and stores the result in q ! also returns ns : ns=1 means it was inside, ns=16 means too far , it failed use lattice !! use io2 implicit none integer , intent ( in ) :: nshl real ( 8 ), intent ( in ) :: kp ( 3 ), gg ( 3 , nshl ) integer , intent ( out ) :: ns real ( 8 ), intent ( out ) :: q ( 3 ) logical inside foldloop : do ns = 1 , nshl q = kp (:) + gg (:, ns ) call check_inside_fbz ( q , g1 , g2 , g3 , inside ) if ( inside ) then return endif enddo foldloop !3 format(3(i6),9(2x,f8.4)) end subroutine send_to_fbz !=========================================================== subroutine send_to_primcell ( kp , q ) ! folds the kpoint kp into the primitive cell (between 0 and G) stores the result in q use lattice !! use io2 implicit none real ( 8 ), intent ( in ) :: kp ( 3 ) real ( 8 ), intent ( out ) :: q ( 3 ) real ( 8 ) a1 , a2 , a3 a1 = ( kp . dot . r1 ) / 2 / pi a2 = ( kp . dot . r2 ) / 2 / pi a3 = ( kp . dot . r3 ) / 2 / pi a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) q = a1 * g1 + a2 * g2 + a3 * g3 end subroutine send_to_primcell !============================================================ subroutine inverse_real ( a , b , n ) implicit none integer n , imax , k , j , i , ii real ( 8 ) :: amax real ( 8 ) a ( n , n ), b ( n , n ), atmp , btmp , amult , div b = 0 d0 do i = 1 , n b ( i , i ) = 1 d0 enddo MAIN_LOOP : do k = 1 , n amax =- 1.d-31 imax = 1 if ( k . ne . n ) then do i = k , n if ( abs ( a ( i , k )) . ge . amax ) then amax = abs ( a ( i , k )) imax = i endif enddo if ( imax . ne . k ) then do j = 1 , n atmp = a ( imax , j ) a ( imax , j ) = a ( k , j ) a ( k , j ) = atmp btmp = b ( imax , j ) b ( imax , j ) = b ( k , j ) b ( k , j ) = btmp enddo endif endif div = a ( k , k ) if ( abs ( div ). gt . 1.d-14 ) then do ii = 1 , n a ( k , ii ) = a ( k , ii ) / div b ( k , ii ) = b ( k , ii ) / div enddo !          a(k,:)=a(k,:)/div !          b(k,:)=b(k,:)/div endif do i = 1 , n amult = a ( i , k ) if ( i . eq . k ) cycle do j = 1 , n a ( i , j ) = a ( i , j ) - amult * a ( k , j ) b ( i , j ) = b ( i , j ) - amult * b ( k , j ) enddo enddo enddo MAIN_LOOP end subroutine inverse_real !=============================================================== subroutine mean_sd ( x , mean , sd ) implicit none integer n real ( 8 ) x (:), mean , sd , sd2 n = size ( x ) mean = sum ( x ) / n sd2 = sum ( x * x ) / n sd = sqrt ( sd2 - mean * mean ) end subroutine mean_sd !===================================================== subroutine histogram ( m , x , mesh ) ! calculates the histogram of the data set x (needs not be sorted) ! and writes the distribution function in the file 'histo.dat' implicit none integer , intent ( in ) :: m , mesh real ( 8 ), intent ( in ) :: x ( m ) integer i , j , cnt , unit real ( 8 ) xmin , xmax , dx , e ( mesh ) unit = 123 open ( unit , file = 'histo.dat' ) write ( unit , * ) '# j,  x(j) , e(j) , e(j)/sume/dx,accumulated e ' cnt = size ( x ) xmax = maxval ( x ) xmin = minval ( x ) dx = ( xmax - xmin ) / mesh write ( * , 5 ) 'HISTO: size,xmin,xmax,dx=' , cnt , xmin , xmax , dx e = 0 do i = 1 , cnt ! j=position of the bin to which x(i) belongs j = int (( x ( i ) - xmin ) / dx ) + 1 if ( j . eq . mesh + 1 ) j = mesh if ( j . lt . 1 . or . j . gt . mesh ) then write ( * , * ) 'j is out of range ' , j stop endif !     write(unit,4)j,xmin+(j-0.5)*dx,e(j),e(j)/sume/dx,cume enddo ! 4 format(i8,9(2x,g13.6)) 5 format ( a , i8 , 9 ( 2 x , g13 . 6 )) close ( unit ) end subroutine histogram !============================================================ function trace ( n , mat ) implicit none integer n , i real ( 8 ) trace , mat ( n , n ) trace = 0 do i = 1 , n trace = trace + mat ( i , i ) enddo end function trace !===========================================================","tags":"","loc":"sourcefile/extratools.f90.html"},{"title":"svd.f90 – Example Project","text":"Contents Functions pythag2 Subroutines svd_set svdcmp svbksb Source Code svd.f90 Source Code !=========================================================== subroutine svd_set ( m3 , n , a , b , x , sig , svdcut , error , ermax , sigma , fnsvd ) ! use mappings implicit none integer i , j , m3 , n , k , uio real ( 8 ), intent ( in ) :: a ( m3 , n ), b ( m3 ) ! real(8) u(m3,n),v(n,n),w(n) real ( 8 ), allocatable :: u (:,:), v (:,:), w (:) real ( 8 ), intent ( out ) :: error , ermax , x ( n ), sig ( n ) real ( 8 ) prod , wmax , wmin , svdcut , junk , sigma , num , denom character ( * ) fnsvd ! m=dim_a ; n=ngr ! ! do i=1,m ! do j=1,n !    call random_number( prod ) !    a(i,j) = 2*prod - 1 ! enddo !    call random_number( prod ) !    b(i) = 2*prod - 1 ! enddo uio = 345 ! open(uio,file='svd-results.dat',status='unknown') open ( uio , file = fnsvd , status = 'unknown' ) write ( uio , * ) ' Matrix A and vector b are ' ! do i=1,m3 !   write(uio,9)i,(a(i,j),j=1,n),b(i) ! enddo !9 format(i8,1x,99(1x,f7.3)) 8 format ( i8 , 1 x , i8 , 3 x , f25 . 15 , 3 x , f25 . 15 ) 7 format ( i8 , 1 x , 99 ( 1 x , g16 . 9 )) write ( uio , * ) ' A and b written, now doing the SVD ' allocate ( u ( m3 , n ), v ( n , n ), w ( n ) ) u = a call svdcmp ( u , m3 , n , m3 , n , w , v ) write ( uio , * ) ' product of U&#94;T*U is: (no lines means it is identity) ' do k = 1 , n do j = 1 , n prod = 0 do i = 1 , m3 prod = prod + u ( i , j ) * u ( i , k ) enddo ! if it is not 0 or 1 write... if ( abs ( abs ( prod - 0.5 ) - 0.5 ) . gt . 1 d - 12 ) write ( uio , 8 ) k , j , prod enddo enddo !write(uio,*)' product of V*V&#94;T is: (no lines means it is identity) ' do k = 1 , n do j = 1 , n prod = 0 do i = 1 , n prod = prod + v ( j , i ) * v ( k , i ) enddo ! if it is not 0 or 1 write... if ( abs ( abs ( prod - 0.5 ) - 0.5 ) . gt . 1 d - 12 ) write ( uio , 8 ) k , j , prod enddo enddo write ( uio , * ) ' W (better not be too small) is:  ' do k = 1 , n write ( uio , * ) 'k,w(k)=' , k , w ( k ) enddo write ( uio , * ) ' Its condition number w_max/w_min should not be too large ' , maxval ( w ) / minval ( w ) !write(uio,*)' SVD product of U*W*V&#94;T, a is: ' do i = 1 , m3 do j = 1 , n prod = 0 do k = 1 , n prod = prod + v ( j , k ) * u ( i , k ) * w ( k ) enddo !    write(uio,8)i,j,prod,a(i,j) if ( abs ( prod - a ( i , j )) . gt . 1 d - 10 ) write ( uio , 8 ) i , j , prod , a ( i , j ) enddo enddo wmax = maxval ( abs ( w )) wmin = svdcut * wmax write ( uio , * ) ' Maxval of w is=' , wmax write ( uio , * ) ' w larger than ' , wmin , ' was used in the inversion' ! this is to eliminate the v vectors with small w do j = 1 , n if ( abs ( w ( j )). lt . wmin ) w ( j ) = 0 d0 enddo call svbksb ( u , w , v , m3 , n , m3 , n , b , x ) write ( uio , * ) ' results of SVD solution, variance, error are: x,sigma,Dx' do j = 1 , n sig ( j ) = 0 do k = 1 , n if ( w ( k ). gt . wmin ) then sig ( j ) = sig ( j ) + v ( j , k ) * v ( j , k ) / w ( k ) / w ( k ) endif enddo sig ( j ) = sqrt ( sig ( j )) write ( uio , 7 ) j , x ( j ), sig ( j ), sig ( j ) / sqrt ( m3 * 1. ) enddo deallocate ( u , v , w ) !write(uio,*)' residual of SVD solution is: Ax,b,Ax-b,(Ax-b)/Ax' error = 0 ; ermax = 0 ; num = 0 ; denom = 0 do i = 1 , m3 prod = 0 do j = 1 , n prod = prod + a ( i , j ) * x ( j ) enddo junk = abs ( prod - b ( i )) num = num + junk * junk denom = denom + b ( i ) * b ( i ) if ( ermax . lt . junk ) ermax = junk write ( uio , 6 ) i , prod , b ( i ), prod - b ( i ), ( prod - b ( i )) / prod !    if (prod.ne.0) then !       error = error + abs((prod-b(i))/prod) !    elseif(b(i).ne.0) then !       error = error + abs((prod-b(i))/b(i)) !    endif error = error + junk enddo error = error / ( 1. * m3 ) sigma = sqrt ( num / denom ) write ( uio , 3 ) ' Average, largest errors in force,percent deviation=' , error , ermax , sigma 6 format ( i6 , 3 ( 1 x , g13 . 6 ), 3 x , g11 . 4 ) 3 format ( a , 3 ( 1 x , g13 . 6 )) close ( uio ) end subroutine svd_set !=================================================== SUBROUTINE svdcmp ( a , m , n , mp , np , w , v ) implicit none INTEGER m , mp , n , np !,NMAX REAL ( 8 ) a ( mp , np ), v ( np , np ), w ( np ) !     PARAMETER (NMAX=500) INTEGER i , its , j , jj , k , l , nm !     REAL(8) anorm,c,f,g,h,s,scale,x,y,z,rv1(NMAX),pythag2 REAL ( 8 ) anorm , c , f , g , h , s , scale , x , y , z , rv1 ( n ), pythag2 g = 0.d0 scale = 0.d0 anorm = 0.d0 L25 : do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = 0.d0 s = 0.d0 scale = 0.d0 if ( i . le . m ) then do k = i , m scale = scale + abs ( a ( k , i )) enddo if ( scale . ne . 0.d0 ) then do k = i , m a ( k , i ) = a ( k , i ) / scale s = s + a ( k , i ) * a ( k , i ) enddo f = a ( i , i ) g =- sign ( sqrt ( s ), f ) h = f * g - s a ( i , i ) = f - g do j = l , n s = 0.d0 do k = i , m s = s + a ( k , i ) * a ( k , j ) enddo f = s / h do k = i , m a ( k , j ) = a ( k , j ) + f * a ( k , i ) enddo enddo do k = i , m a ( k , i ) = scale * a ( k , i ) enddo endif endif w ( i ) = scale * g g = 0.d0 s = 0.d0 scale = 0.d0 if (( i . le . m ). and .( i . ne . n )) then do k = l , n scale = scale + abs ( a ( i , k )) enddo if ( scale . ne . 0.d0 ) then do k = l , n a ( i , k ) = a ( i , k ) / scale s = s + a ( i , k ) * a ( i , k ) enddo f = a ( i , l ) g =- sign ( sqrt ( s ), f ) h = f * g - s a ( i , l ) = f - g do k = l , n rv1 ( k ) = a ( i , k ) / h enddo do j = l , m s = 0.d0 do k = l , n s = s + a ( j , k ) * a ( i , k ) enddo do k = l , n a ( j , k ) = a ( j , k ) + s * rv1 ( k ) enddo enddo do k = l , n a ( i , k ) = scale * a ( i , k ) enddo endif endif anorm = max ( anorm ,( abs ( w ( i )) + abs ( rv1 ( i )))) enddo L25 L32 : do i = n , 1 , - 1 if ( i . lt . n ) then if ( g . ne . 0.d0 ) then do j = l , n v ( j , i ) = ( a ( i , j ) / a ( i , l )) / g enddo do j = l , n s = 0.d0 do k = l , n s = s + a ( i , k ) * v ( k , j ) enddo do k = l , n v ( k , j ) = v ( k , j ) + s * v ( k , i ) enddo enddo endif do j = l , n v ( i , j ) = 0.d0 v ( j , i ) = 0.d0 enddo endif v ( i , i ) = 1.d0 g = rv1 ( i ) l = i enddo L32 L39 : do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) do j = l , n a ( i , j ) = 0.d0 enddo if ( g . ne . 0.d0 ) then g = 1.0 / g do j = l , n s = 0.d0 do k = l , m s = s + a ( k , i ) * a ( k , j ) enddo f = ( s / a ( i , i )) * g do k = i , m a ( k , j ) = a ( k , j ) + f * a ( k , i ) enddo enddo do j = i , m a ( j , i ) = a ( j , i ) * g enddo else do j = i , m a ( j , i ) = 0.d0 enddo endif a ( i , i ) = a ( i , i ) + 1.d0 enddo L39 L49 : do k = n , 1 , - 1 do its = 1 , 30 L41 : do l = k , 1 , - 1 nm = l - 1 if (( abs ( rv1 ( l )) + anorm ). eq . anorm ) goto 2 if (( abs ( w ( nm )) + anorm ). eq . anorm ) exit L41 !goto 1 enddo L41 !1         c=0.0 c = 0.d0 s = 1.d0 L43 : do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) if (( abs ( f ) + anorm ). eq . anorm ) exit L43 ! goto 2 g = w ( i ) h = pythag2 ( f , g ) w ( i ) = h h = 1.d0 / h c = ( g * h ) s =- ( f * h ) do j = 1 , m y = a ( j , nm ) z = a ( j , i ) a ( j , nm ) = ( y * c ) + ( z * s ) a ( j , i ) =- ( y * s ) + ( z * c ) enddo enddo L43 2 z = w ( k ) if ( l . eq . k ) then if ( z . lt . 0.d0 ) then w ( k ) =- z do j = 1 , n v ( j , k ) =- v ( j , k ) enddo endif cycle L49 !goto 3 endif if ( its . eq . 30 ) write ( * , * ) 'no convergence in svdcmp' x = w ( l ) nm = k - 1 y = w ( nm ) g = rv1 ( nm ) h = rv1 ( k ) f = (( y - z ) * ( y + z ) + ( g - h ) * ( g + h )) / ( 2.d0 * h * y ) g = pythag2 ( f , 1 d0 ) f = (( x - z ) * ( x + z ) + h * (( y / ( f + sign ( g , f ))) - h )) / x c = 1.0 s = 1.0 do j = l , nm i = j + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag2 ( f , h ) rv1 ( j ) = z c = f / z s = h / z f = ( x * c ) + ( g * s ) g =- ( x * s ) + ( g * c ) h = y * s y = y * c do jj = 1 , n x = v ( jj , j ) z = v ( jj , i ) v ( jj , j ) = ( x * c ) + ( z * s ) v ( jj , i ) =- ( x * s ) + ( z * c ) enddo z = pythag2 ( f , h ) w ( j ) = z if ( z . ne . 0.d0 ) then z = 1.d0 / z c = f * z s = h * z endif f = ( c * g ) + ( s * y ) x =- ( s * g ) + ( c * y ) do jj = 1 , m y = a ( jj , j ) z = a ( jj , i ) a ( jj , j ) = ( y * c ) + ( z * s ) a ( jj , i ) =- ( y * s ) + ( z * c ) enddo enddo rv1 ( l ) = 0.d0 rv1 ( k ) = f w ( k ) = x enddo ! 3       continue enddo L49 END SUBROUTINE svdcmp !  (C) Copr. 1986-92 Numerical Recipes Software !+!). !=================================================== SUBROUTINE svbksb ( u , w , v , m , n , mp , np , b , x ) implicit none INTEGER m , mp , n , np REAL ( 8 ) b ( mp ), u ( mp , np ), v ( np , np ), w ( np ), x ( np ) !     PARAMETER (NMAX=500) INTEGER i , j , jj !     REAL(8) s,tmp(NMAX) REAL ( 8 ) s , tmp ( n ) do j = 1 , n s = 0 d0 if ( w ( j ). ne . 0 d0 ) then do i = 1 , m s = s + u ( i , j ) * b ( i ) enddo s = s / w ( j ) endif tmp ( j ) = s enddo do j = 1 , n s = 0 d0 do jj = 1 , n s = s + v ( j , jj ) * tmp ( jj ) enddo x ( j ) = s enddo END SUBROUTINE svbksb !  (C) Copr. 1986-92 Numerical Recipes Software !+!) !=================================================== FUNCTION pythag2 ( a , b ) implicit none REAL ( 8 ) a , b , pythag2 REAL ( 8 ) absa , absb , rat absa = abs ( a ) absb = abs ( b ) if ( absa . gt . absb ) then rat = absb / absa pythag2 = absa * sqrt ( 1 d0 + rat * rat ) else if ( absb . eq . 0 d0 ) then pythag2 = 0 d0 else rat = absa / absb pythag2 = absb * sqrt ( 1 d0 + rat * rat ) endif endif END FUNCTION pythag2 !  (C) Copr. 1986-92 Numerical Recipes Software !+!).","tags":"","loc":"sourcefile/svd.f90.html"},{"title":"modules9.f90 – Example Project","text":"Files dependent on this one sourcefile~~modules9.f90~~AfferentGraph sourcefile~modules9.f90 modules9.f90 sourcefile~others3_nshells.f90 others3_nshells.f90 sourcefile~others3_nshells.f90->sourcefile~modules9.f90 sourcefile~fc234.f90 fc234.f90 sourcefile~fc234.f90->sourcefile~modules9.f90 sourcefile~ios.f90 ios.f90 sourcefile~ios.f90->sourcefile~modules9.f90 sourcefile~extratools.f90 extratools.f90 sourcefile~extratools.f90->sourcefile~modules9.f90 sourcefile~force_constants.f90 force_constants.f90 sourcefile~force_constants.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pre_matrix_elt mod_ksubset2 phi3_sy exactBTE2 constants params geometry ios force_constants_module lattice atoms_force_constants svd_stuff born Functions bring_to_prim_cell_cav bring_to_super_cell_cav bring_to_prim_cell_caa bring_to_super_cell_caa bring_to_prim_cell_cv bring_to_super_cell_cv Subroutines cart_to_direct_v cart_to_direct_av cart_to_direct_aa direct_to_cart_v direct_to_cart_av direct_to_cart_aa dir2cart_g Source Code modules9.f90 Source Code !============================================== ! Modules here !============================================== module pre_matrix_elt complex ( 8 ), allocatable :: eiqr2 (:,:), eivec2 (:,:,:,:) contains subroutine allocate_eiqr2 ( num1 , num2 ) allocate ( eiqr2 ( num1 , num2 )) end subroutine allocate_eiqr2 subroutine allocate_eivec2 ( num1 , num3 , num4 ) allocate ( eivec2 ( num1 , 3 , num3 , num4 )) end subroutine allocate_eivec2 subroutine deallocate_eiqr2 deallocate ( eiqr2 ) end subroutine deallocate_eiqr2 subroutine deallocate_eivec2 deallocate ( eivec2 ) end subroutine deallocate_eivec2 end module pre_matrix_elt !=========================================================== module mod_ksubset2 integer num_pfiles integer , allocatable :: ksubset2 (:,:) contains subroutine allocate_ksubset2 ( num ) allocate ( ksubset2 ( num , 2 )) end subroutine allocate_ksubset2 subroutine deallocate_ksubset2 deallocate ( ksubset2 ) end subroutine deallocate_ksubset2 end module mod_ksubset2 !========================================================== module phi3_sy complex ( 8 ), allocatable :: v33_md (:,:,:,:,:) real ( 8 ), allocatable :: v33sq1 (:,:,:,:,:) ! v3 : (nk1,nk2,la1,la2,la3) ! integer nv3,readv3,writev3, iter, split, calk ! sy added iter,split, calk ! real(8) v3_threshold,const33 contains subroutine allocate_v33_sy ( n1 , n2 , l1 , l2 , l3 ) allocate ( v33_md ( n1 , n2 , l1 , l2 , l3 ) ) end subroutine allocate_v33_sy subroutine deallocate_v33_sy deallocate ( v33_md ) end subroutine deallocate_v33_sy subroutine allocate_v33_sq ( n1 , n2 , l1 , l2 , l3 ) allocate ( v33sq1 ( n1 , n2 , l1 , l2 , l3 )) end subroutine allocate_V33_sq subroutine deallocate_v33_sq deallocate ( v33sq1 ) end subroutine subroutine allocate_phi3_sy ( nk , nl , ni ) integer nk , nl , ni !   allocate(delta3(nk,nl,nw),gamma3(nk,nl,nw),v3(nk,nk,nl,nl,nl)) !   allocate(selfN(ni,nl,nw),selfU(ni,nl,nw)) allocate ( v33_md ( ni , nk , nl , nl , nl )) end subroutine allocate_phi3_sy end module phi3_sy !=========================================================== module exactBTE2 integer ncol , nlin real ( 8 ), allocatable :: F_RTA (:,:,:), F1 (:,:,:), F2 (:,:,:), Qvalue (:,:), iselfenergy (:,:), tau (:,:,:), error (:,:,:), diff (:,:,:) real ( 8 ), allocatable :: mval (:,:), qval (:), coll (:,:), rhs (:,:), rhsi (:,:), ne_dist (:,:), ne_dist_rta (:,:) real ( 8 ), allocatable :: Qvalue_N (:,:), Qvalue_U (:,:) !, tauinv_N(:,:), tauinv_U(:,:), tauinv_tot(:,:), tauinv_eff(:,:,:) real ( 8 ), allocatable :: diff_kap (:,:,:,:), kappa (:,:,:), kappa_k (:,:,:,:), kappa_RTA (:,:,:), kappa_k_RTA (:,:,:,:) ! F1,F2: (kp1,la1,xyz)    , Qvalue,Avalue,iselfenergy: (kp,la) real ( 8 ), allocatable :: P1 (:,:,:,:,:), P2 (:,:,:,:,:) ! P1,P2: (kp1,kp2,la1,la2,la3)   don't need kp3 since it is determined by momentum conservation. real ( 8 ), allocatable :: frequency (:,:) , dist (:,:) ! BE distribution function !real(8), allocatable:: v33sq(:,:,:,:,:) contains !subroutine allocate_v33sq(nk,ndn) !allocate(v33sq(nk,nk,ndn,ndn,ndn)) !end subroutine allocate_v33sq subroutine allocate_iter_kap ( nk , ndn ) implicit none integer nk , ndn !allocate (F_RTA(nk,ndn,3),F1(nk,ndn,3),F2(nk,ndn,3),F1_old(nk,ndn,3),Qvalue(nk,ndn), & !&         iselfenergy(nk,ndn),tau(nk,ndn,3),error(nk,ndn,3),diff(nk,ndn,3)) allocate ( diff_kap ( nk , ndn , 3 , 3 ), kappa ( ndn , 3 , 3 ) ) !,kappa_k(nk,ndn,3,3),kappa_RTA(ndn,3,3), & !&         kappa_k_RTA(nk,ndn,3,3))    ! 3 for xyz !allocate (dist(nk,ndn),frequency(nk,ndn)) !allocate(tauinv_N(nk,ndn),tauinv_U(nk,ndn),tauinv_tot(nk,ndn),tauinv_eff(nk,ndn,3)) end subroutine allocate_iter_kap subroutine allocate_iter0 ( ni , nk , ndn ) allocate ( Qvalue_N ( ni , ndn ), Qvalue_U ( ni , ndn ), qval ( ni * ndn ), mval ( nk * ndn , ni * ndn )) end subroutine allocate_iter0 subroutine allocate_iter1 ( ni , nk , ndn ) allocate ( rhs ( ndn * nk , 3 ), rhsi ( ndn * ni , 3 ), coll ( ndn * ni , ndn * ni ), ne_dist ( ni * ndn , 3 ), ne_dist_rta ( ni * ndn , 3 )) end subroutine allocate_iter1 subroutine allocate_iter2 ( n1 , n2 , l1 , l2 , l3 ) allocate ( P1 ( n1 , n2 , l1 , l2 , l3 ), P2 ( n1 , n2 , l1 , l2 , l3 )) end subroutine allocate_iter2 subroutine deallocate_iter_kap !deallocate(dist,frequency) !deallocate(F_RTA,F1,F2,Qvalue,iselfenergy,tau,error,diff,F1_old) deallocate ( diff_kap , kappa ) !,kappa_k,kappa_RTA,kappa_k_RTA) end subroutine deallocate_iter_kap subroutine deallocate_iter0 deallocate ( Qvalue_N , Qvalue_U , qval , mval ) end subroutine deallocate_iter0 subroutine deallocate_iter1 deallocate ( rhs , rhsi , coll ) !tauinv_N,tauinv_U,tauinv_tot,tauinv_eff) end subroutine deallocate_iter1 subroutine deallocate_iter2 deallocate ( P1 , P2 ) end subroutine deallocate_iter2 !subroutine deallocate_v33sq !deallocate(v33sq) !end subroutine deallocate_V33sq end module exactBTE2 !============================================================== module constants implicit none real ( 8 ) :: pi = 3.14159265358979323846d0 complex ( 8 ) :: ci = dcmplx ( 0 d0 , 1 d0 ) real ( 8 ) :: h_plank = 6.62606896d-34 real ( 8 ) :: n_avog = 6.023d23 real ( 8 ) :: k_b = 1.3806504d-23 ! J/K: real ( 8 ) :: c_light = 2.99792458d+8 ! in (m/s) real ( 8 ) :: hbar = 1.054571628d-34 !h_plank/2/pi  ! real ( 8 ) :: ee = 1.60217653d-19 real ( 8 ) :: eps0 = 8.854187817d-12 real ( 8 ) :: me = 9.1093826d-31 real ( 8 ) :: uma = 1.66053878d-27 ! kg ! real(8) :: cnst = sqrt(ee*1d20/uma)/pi/200/c_light ! converts sqrt(eV/A/A/uma) to cm&#94;-1 real ( 8 ) :: cnst = 52 1.1098918 ! real(8) :: ryd= me*ee**4/2/pi/pi/hbar**2/16/pi/pi/eps0/eps0 real ( 8 ) :: ryd = 2 7.2116 ! real(8) :: ab = hbar*hbar/me/ee/ee*4*pi*eps0 real ( 8 ) :: ab = 0.529177 ! kbe=8.617343e-05 end module constants !============================================== module params real ( 8 ) tolerance , margin , scalelengths integer nconfigs , classical , ntemp , fdfiles , cal_cross , threemtrx , lamin , lamax , ncpu , n_dig_acc , isvd integer nshells ( 4 , 10 ) ! up to which shell to include for each rank of FC integer include_fc ( 4 ) ! whether to include FCs of that rank real ( 8 ) rcut ( 4 ), tau0 , wshift ( 3 ) real ( 8 ) tmin , tmax , qcros ( 3 ), svdc logical verbose end module params !============================================================ module geometry type vector real ( 8 ) :: x , y , z end type vector type point real ( 8 ) :: x , y , z end type point !----------------------------- interface operator ( * ) module procedure multiply_by_real , multiply_by_integer ; end interface interface operator ( / ) module procedure divide_by_scalar ; end interface interface assignment ( = ) module procedure array_eq_vector , array_eq_point , vector_eq_array , & & vector_eq_point , point_eq_vector , point_eq_array end interface interface operator ( + ) module procedure addition_avv , addition_vav , addition !,  & ! &                     addition_ava , addition_vaa end interface interface operator ( - ) module procedure subtraction , subtraction_av , subtraction_va ; end interface interface operator (. dot .) module procedure dotproduct_v , dotproduct_a , & & dotproduct_av , dotproduct_va ; end interface interface operator (. cross .) module procedure crossproduct_v , crossproduct_a ; end interface interface operator (. myeqz .) module procedure myequal0 , myequal0array , myequal0vector ; end interface interface operator (. myeq .) module procedure myequal , myequalarray , myequalvector ; end interface interface length module procedure lengthv , lengtha ; end interface interface bring_to_cell_c module procedure bring_to_cell_cv , bring_to_cell_ca end interface interface bring_to_cell_d module procedure bring_to_cell_dv , bring_to_cell_da end interface ! interface cart_to_direct !    module procedure cart_to_direct_aa,cart_to_direct_av,cart_to_direct_v ! end interface ! interface direct_to_cart !    module procedure direct_to_cart_aa,direct_to_cart_av,direct_to_cart_v ! end interface interface reduce module procedure reduce_v , reduce_a end interface interface bring_to_center module procedure bring_to_center_a , bring_to_center_v end interface bring_to_center contains !============================================================ function crossproduct_v ( v , w ) result ( cross ) type ( vector ) cross !, intent(out) :: type ( vector ), intent ( in ) :: v , w cross % x = v % y * w % z - v % z * w % y cross % y = v % z * w % x - v % x * w % z cross % z = v % x * w % y - v % y * w % x end function crossproduct_v function crossproduct_a ( v , w ) result ( cross ) real ( 8 ) cross ( 3 ) !, intent(out) :: real ( 8 ), intent ( in ) :: v ( 3 ), w ( 3 ) cross ( 1 ) = v ( 2 ) * w ( 3 ) - v ( 3 ) * w ( 2 ) cross ( 2 ) = v ( 3 ) * w ( 1 ) - v ( 1 ) * w ( 3 ) cross ( 3 ) = v ( 1 ) * w ( 2 ) - v ( 2 ) * w ( 1 ) end function crossproduct_a !----------------------------------- function dotproduct_v ( v , w ) result ( dot ) real ( 8 ) dot !, intent(out) :: type ( vector ), intent ( in ) :: v , w dot = w % x * v % x + w % y * v % y + w % z * v % z end function dotproduct_v !----------------------------------- function dotproduct_a ( v , w ) result ( dot ) real ( 8 ) dot !, intent(out) :: real ( 8 ), intent ( in ) :: v (:), w (:) !    dot = v(1)*w(1) + v(2)*w(2) + v(3)*w(3) dot = sum ( v * w ) end function dotproduct_a !----------------------------------- function dotproduct_av ( v , w ) result ( dot ) real ( 8 ) dot !, intent(out) :: real ( 8 ), intent ( in ) :: v ( 3 ) type ( vector ), intent ( in ) :: w dot = v ( 1 ) * w % x + v ( 2 ) * w % y + v ( 3 ) * w % z end function dotproduct_av !----------------------------------- function dotproduct_va ( w , v ) result ( dot ) real ( 8 ) dot !, intent(out) :: real ( 8 ), intent ( in ) :: v ( 3 ) type ( vector ), intent ( in ) :: w dot = v ( 1 ) * w % x + v ( 2 ) * w % y + v ( 3 ) * w % z end function dotproduct_va !----------------------------------- function myequal0 ( v , w ) result ( eq ) use params real ( 8 ), intent ( in ) :: v , w logical eq !, intent(out) :: eq if ( abs ( v - w ) . lt . 1 d - 5 ) then eq = . true . else eq = . false . endif end function myequal0 !----------------------------------- function myequal ( v , w ) result ( eq ) use params real ( 8 ), intent ( in ) :: v , w logical eq !, intent(out) :: eq !    if (v.eq.0 ) then !       if (w.eq.0) then !          eq=.true. !       else !          eq=.false. !       endif !    else !       if (abs(v-w)/abs(v) .lt. tolerance) then if ( abs ( v - w ) . lt . tolerance ) then eq = . true . else eq = . false . endif !    endif end function myequal !----------------------------------- function myequal0vector ( v , w ) result ( eq ) type ( vector ), intent ( in ) :: v , w logical eq !, intent(out) :: eq if ( ( v % x . myeqz . w % x ) . and . ( v % y . myeqz . w % y ) . and . ( v % z . myeqz . w % z ) ) then eq = . true . else eq = . false . endif end function myequal0vector !----------------------------------- function myequalvector ( v , w ) result ( eq ) type ( vector ), intent ( in ) :: v , w logical eq !, intent(out) :: eq if ( ( v % x . myeq . w % x ) . and . ( v % y . myeq . w % y ) . and . ( v % z . myeq . w % z ) ) then eq = . true . else eq = . false . endif end function myequalvector !----------------------------------- function myequal0array ( v , w ) result ( eq ) real ( 8 ), dimension (:), intent ( in ) :: v , w logical eq !, intent(out) :: eq integer i , n i = size ( v ) ; n = size ( w ) if ( n . ne . i ) then print * , 'MYEQUAL0ARRAY: the input arrays are of different size ' , i , n stop else eq = . true . loop : do n = 1 , i if ( . not . myequal0 ( v ( n ), w ( n )) ) then eq = . false . exit loop endif enddo loop endif end function myequal0array !----------------------------------- function myequalarray ( v , w ) result ( eq ) real ( 8 ), dimension (:), intent ( in ) :: v , w logical eq !, intent(out) :: eq integer i , n i = size ( v ) ; n = size ( w ) if ( n . ne . i ) then print * , 'MYEQUALARRAY: the input arrays are of different size ' , i , n stop else eq = . true . loop : do n = 1 , i if ( . not . myequal ( v ( n ), w ( n )) ) then eq = . false . exit loop endif enddo loop endif end function myequalarray !----------------------------------- function addition ( v , w ) result ( add ) type ( vector ) add !, intent(out) :: type ( vector ), intent ( in ) :: v , w add % x = v % x + w % x add % y = v % y + w % y add % z = v % z + w % z end function addition !----------------------------------- function addition_vav ( v , w ) result ( add ) type ( vector ) add !, intent(out) :: type ( vector ), intent ( in ) :: v real ( 8 ), intent ( in ) :: w ( 3 ) add % x = v % x + w ( 1 ) add % y = v % y + w ( 2 ) add % z = v % z + w ( 3 ) end function addition_vav !----------------------------------- function addition_avv ( w , v ) result ( add ) type ( vector ) add !, intent(out) :: type ( vector ), intent ( in ) :: v real ( 8 ), intent ( in ) :: w ( 3 ) add % x = v % x + w ( 1 ) add % y = v % y + w ( 2 ) add % z = v % z + w ( 3 ) end function addition_avv !----------------------------------- !  function addition_vaa(v,w) result(add) !    real(8) add(3) !, intent(out) :: !    type(vector), intent(in) :: v !    real(8), intent(in) :: w(3) !    add(1) = v%x + w(1) !    add(2) = v%y + w(2) !    add(3) = v%z + w(3) !  end function addition_vaa !----------------------------------- !  function addition_ava(w,v) result(add) !    real(8) add(3) !, intent(out) :: !    type(vector), intent(in) :: v !    real(8), intent(in) :: w(3) !    add(1) = v%x + w(1) !    add(2) = v%y + w(2) !    add(3) = v%z + w(3) !  end function addition_ava !----------------------------------- function subtraction ( v , w ) result ( dif ) type ( vector ) dif !, intent(out) :: type ( vector ), intent ( in ) :: v , w dif % x = v % x - w % x dif % y = v % y - w % y dif % z = v % z - w % z end function subtraction !----------------------------------- function subtraction_va ( v , w ) result ( dif ) type ( vector ) dif !, intent(out) :: type ( vector ), intent ( in ) :: v real ( 8 ), intent ( in ) :: w ( 3 ) dif % x = v % x - w ( 1 ) dif % y = v % y - w ( 2 ) dif % z = v % z - w ( 3 ) end function subtraction_va !----------------------------------- function subtraction_av ( w , v ) result ( dif ) type ( vector ) dif !, intent(out) :: type ( vector ), intent ( in ) :: v real ( 8 ), intent ( in ) :: w ( 3 ) dif % x = v % x - w ( 1 ) dif % y = v % y - w ( 2 ) dif % z = v % z - w ( 3 ) end function subtraction_av !----------------------------------- function multiply_by_integer ( s , v ) result ( sv ) integer , intent ( in ) :: s type ( vector ), intent ( in ) :: v type ( vector ) sv !, intent(out):: sv % x = s * v % x sv % y = s * v % y sv % z = s * v % z end function multiply_by_integer !----------------------------------- function multiply_by_real ( s , v ) result ( sv ) real ( 8 ), intent ( in ) :: s type ( vector ), intent ( in ) :: v type ( vector ) sv !, intent(out):: sv % x = s * v % x sv % y = s * v % y sv % z = s * v % z end function multiply_by_real !----------------------------------- function divide_by_scalar ( v , s ) result ( sv ) real ( 8 ), intent ( in ) :: s type ( vector ), intent ( in ) :: v type ( vector ) sv !, intent(out):: sv % x = 1 / s * v % x sv % y = 1 / s * v % y sv % z = 1 / s * v % z end function divide_by_scalar !----------------------------------- function distance ( v , w ) result ( d ) type ( point ), intent ( in ) :: v , w real ( 8 ) d !, intent(out):: d = sqrt ( ( v % x - w % x ) ** 2 + ( v % y - w % y ) ** 2 + ( v % z - w % z ) ** 2 ) end function distance !----------------------------------- subroutine point_eq_array ( p , a ) real ( 8 ), intent ( in ) :: a ( 3 ) type ( point ), intent ( out ) :: p p % x = a ( 1 ) p % y = a ( 2 ) p % z = a ( 3 ) end subroutine point_eq_array !----------------------------------- subroutine point_eq_vector ( p , v ) type ( vector ), intent ( in ) :: v type ( point ), intent ( out ) :: p p % x = v % x p % y = v % y p % z = v % z end subroutine point_eq_vector !----------------------------------- subroutine vector_eq_point ( v , p ) type ( point ), intent ( in ) :: p type ( vector ), intent ( out ) :: v v % x = p % x v % y = p % y v % z = p % z end subroutine vector_eq_point !----------------------------------- subroutine vector_eq_array ( vv , aa ) real ( 8 ), intent ( in ) :: aa ( 3 ) type ( vector ), intent ( out ) :: vv vv % x = aa ( 1 ) vv % y = aa ( 2 ) vv % z = aa ( 3 ) end subroutine vector_eq_array !----------------------------------- subroutine array_eq_vector ( a , v ) type ( vector ), intent ( in ) :: v real ( 8 ), intent ( out ) :: a ( 3 ) a ( 1 ) = v % x a ( 2 ) = v % y a ( 3 ) = v % z end subroutine array_eq_vector !----------------------------------- subroutine array_eq_point ( a , p ) type ( point ), intent ( in ) :: p real ( 8 ), intent ( out ) :: a ( 3 ) a ( 1 ) = p % x a ( 2 ) = p % y a ( 3 ) = p % z end subroutine array_eq_point !----------------------------------- function vect ( a , b ) result ( v ) type ( point ), intent ( in ) :: a , b type ( vector ) v v % x = b % x - a % x v % y = b % y - a % y v % z = b % z - a % z end function vect !----------------------------------- function lengthv ( v ) result ( l ) real ( 8 ) l type ( vector ), intent ( in ) :: v l = sqrt ( v % x * v % x + v % y * v % y + v % z * v % z ) end function lengthv !----------------------------------- function lengtha ( v ) result ( l ) real ( 8 ) l real ( 8 ), dimension (:), intent ( in ) :: v integer i l = 0 d0 do i = 1 , size ( v ) l = l + v ( i ) * v ( i ) enddo l = sqrt ( l ) end function lengtha !----------------------------------- subroutine reduce_v ( v , q1 , q2 , q3 , w ) ! takes direct coordinates and returns direct coordinates implicit none type ( vector ) v , q1 , q2 , q3 , w real ( 8 ) a1 , a2 , a3 a1 = v . dot . q1 a2 = v . dot . q2 a3 = v . dot . q3 w % x = a1 ; w % y = a2 ; w % z = a3 end subroutine reduce_v !----------------------------------------- subroutine reduce_a ( a , q1 , q2 , q3 , w ) ! takes direct coordinates and returns direct coordinates implicit none type ( vector ) v , q1 , q2 , q3 , w real ( 8 ) a1 , a2 , a3 , a ( 3 ) v % x = a ( 1 ); v % y = a ( 2 ); v % z = a ( 3 ) a1 = v . dot . q1 a2 = v . dot . q2 a3 = v . dot . q3 w % x = a1 ; w % y = a2 ; w % z = a3 end subroutine reduce_a !----------------------------------------- function bring_to_cell_dv ( v ) result ( w ) ! takes direct coordinates and returns direct coordinates implicit none type ( vector ) v , w real ( 8 ) a1 , a2 , a3 a1 = v % x ; a2 = v % y ; a3 = v % z a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) w % x = a1 ; w % y = a2 ; w % z = a3 end function bring_to_cell_dv !----------------------------------------- function bring_to_cell_da ( a ) result ( w ) ! takes direct coordinates and returns direct coordinates implicit none type ( vector ) w real ( 8 ) a ( 3 ) a ( 1 ) = a ( 1 ) - floor ( a ( 1 )) a ( 2 ) = a ( 2 ) - floor ( a ( 2 )) a ( 3 ) = a ( 3 ) - floor ( a ( 3 )) w % x = a ( 1 ) ; w % y = a ( 2 ) ; w % z = a ( 3 ) end function bring_to_cell_da !----------------------------------------- subroutine bring_to_cell_ca ( a , r1 , r2 , r3 , g1 , g2 , g3 , b ) ! takes cart coordinates and returns cart coordinates within the supercell ! assumes r_i.g_j=delta_ij (no factor of 2pi included) implicit none type ( vector ) v , w , g1 , g2 , g3 , r1 , r2 , r3 real ( 8 ) a1 , a2 , a3 , a ( 3 ), b ( 3 ) v % x = a ( 1 ); v % y = a ( 2 ); v % z = a ( 3 ) ! get direct coordinates first a1 = v . dot . g1 a2 = v . dot . g2 a3 = v . dot . g3 ! bring into cell: between 0 and cell a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) ! convert to cartesian coordinates w = a1 * r1 + a2 * r2 + a3 * r3 b ( 1 ) = w % x ; b ( 2 ) = w % y ; b ( 3 ) = w % z end subroutine bring_to_cell_ca !----------------------------------- subroutine bring_to_cell_cv ( v , r1 , r2 , r3 , g1 , g2 , g3 , w ) ! takes cart coordinates and returns cart coordinates within the supercell ! assumes r_i.g_j=delta_ij (no factor of 2pi included) implicit none type ( vector ) v , g1 , g2 , g3 , w , r1 , r2 , r3 real ( 8 ) a1 , a2 , a3 ! get direct coordinates first a1 = v . dot . g1 a2 = v . dot . g2 a3 = v . dot . g3 !print*,'v=',v !print*,'g1,g2,g3=',g1,g2,g3 !print*,'a1,a2,a3=',a1,a2,a3 ! bring into cell: between 0 and cell a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) !print*,'NEW a1,a2,a3=',a1,a2,a3 ! convert to cartesian coordinates w = a1 * r1 + a2 * r2 + a3 * r3 end subroutine bring_to_cell_cv !----------------------------------------- subroutine bring_to_center_v ( v , r1 , r2 , r3 , g1 , g2 , g3 , w ) use constants ! takes cart coordinates and returns cart coordinates within the FBZ implicit none type ( vector ) v , g1 , g2 , g3 , r1 , r2 , r3 , w real ( 8 ) a1 , a2 , a3 ! get direct coordinates first a1 = v . dot . g1 a2 = v . dot . g2 a3 = v . dot . g3 a1 = a1 / 2 / pi ; a2 = a2 / 2 / pi ; a3 = a3 / 2 / pi !print*,'v=',v !print*,'g1,g2,g3=',g1,g2,g3 !print*,'a1,a2,a3=',a1,a2,a3 ! bring into cell: between -cell/2 and cell/2 a1 = a1 - floor ( a1 ) - 0.5 a2 = a2 - floor ( a2 ) - 0.5 a3 = a3 - floor ( a3 ) - 0.5 !print*,'NEW a1,a2,a3=',a1,a2,a3 ! convert to cartesian coordinates w = a1 * r1 + a2 * r2 + a3 * r3 end subroutine bring_to_center_v !----------------------------------------- subroutine bring_to_center_a ( v , r1 , r2 , r3 , g1 , g2 , g3 , w ) use constants ! takes cart coordinates and returns cart coordinates within the FBZ implicit none type ( vector ) g1 , g2 , g3 , r1 , r2 , r3 real ( 8 ) a1 , a2 , a3 , v ( 3 ), w ( 3 ) ! get direct coordinates first a1 = v . dot . g1 a2 = v . dot . g2 a3 = v . dot . g3 a1 = a1 / 2 / pi ; a2 = a2 / 2 / pi ; a3 = a3 / 2 / pi !print*,'v=',v !print*,'g1,g2,g3=',g1,g2,g3 !print*,'a1,a2,a3=',a1,a2,a3 ! bring into cell: between -cell/2 and cell/2 a1 = a1 - floor ( a1 ) - 0.5 a2 = a2 - floor ( a2 ) - 0.5 a3 = a3 - floor ( a3 ) - 0.5 !print*,'NEW a1,a2,a3=',a1,a2,a3 ! convert to cartesian coordinates w = a1 * r1 + a2 * r2 + a3 * r3 end subroutine bring_to_center_a end module geometry !============================================== module ios integer , parameter :: ulog = 30 , uposcar = 10 , uparams = 11 , utraj = 40 , ufco = 20 , & & umap = 60 , umatrx = 50 , utimes = 70 , ufc1 = 21 , ufc2 = 22 , ufc3 = 23 , ufc4 = 24 , & & ufc = 80 , ufit1 = 31 , ufit2 = 32 , ufit3 = 33 , ufit4 = 34 , ucor = 93 , uborn = 12 interface write_out module procedure write_outiv , write_outrv , write_outim , write_outrm & & , write_outi , write_outr , write_outv end interface contains !----------------------------- subroutine write_outrm ( unit , string , n , m , var ) implicit none character * ( * ) string integer n , m , unit , l , i , j real ( 8 ) var ( n , m ) l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' ,(( var ( i , j ), i = 1 , n ), j = 1 , m ) 4 format ( a , 99 ( 1 x , g13 . 6 )) end subroutine write_outrm !----------------------------- subroutine write_outim ( unit , string , n , m , var ) implicit none character * ( * ) string integer n , m , unit , i , l , j integer var ( n , m ) l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' ,(( var ( i , j ), i = 1 , n ), j = 1 , m ) 4 format ( a , 99 ( 1 x , i8 )) end subroutine write_outim !----------------------------- subroutine write_outrv ( unit , string , var ) implicit none character * ( * ) string integer unit , l , i real ( 8 ), dimension (:) :: var l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' ,( var ( i ), i = 1 , size ( var )) 4 format ( a , 99 ( 1 x , g13 . 6 )) end subroutine write_outrv !----------------------------- subroutine write_outiv ( unit , string , var ) implicit none character * ( * ) string integer unit , i , l integer , dimension (:) :: var l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' ,( var ( i ), i = 1 , size ( var )) 4 format ( a , 99 ( 1 x , i8 )) end subroutine write_outiv !----------------------------- subroutine write_outr ( unit , string , var ) implicit none character * ( * ) string integer unit , l real ( 8 ) var l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' , var 4 format ( a , 99 ( 1 x , g13 . 6 )) end subroutine write_outr !----------------------------- subroutine write_outi ( unit , string , var ) implicit none character * ( * ) string integer unit , l integer var l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' , var 4 format ( a , 99 ( 1 x , i8 )) end subroutine write_outi !----------------------------- subroutine write_outv ( unit , string , var ) use geometry implicit none character * ( * ) string integer unit , l type ( vector ) var l = len_trim ( string ) write ( unit , 4 ) string ( 1 : l ) // ' is=' , var 4 format ( a , 3 ( 1 x , g13 . 6 )) end subroutine write_outv end module ios !=========================================================== ! Module for saved data module force_constants_module ! maximum number of shells of nearest neighbors integer maxneighbors !     parameter(maxneighbors=18 ) ! maximum number of atoms out to maxneighbors integer maxatoms , imaxat !     parameter(maxatoms=2800 ) ! op_matrix(k,j,i), matrix for the ith point operator double precision op_matrix ( 3 , 3 , 48 ) ! op_kmatrix(k,j,i), matrix for the ith point operator acting on k vector double precision op_kmatrix ( 3 , 3 , 48 ) integer lattpgcount ! isgopcount, number of operators in space group integer isgopcount ! isgop(i), point operation in ith space group operator integer isgop ( 48 ) ! sgfract(j,i), jth cartesian coordinate of fractional in ith space group operator double precision sgfract ( 3 , 48 ) ! iatomop(j,i), point operator that takes jth atom into ith atom integer , allocatable :: iatomop (:,:) ! atomopfract(k,j,i), kth cartesian coordinate of fractional to accompany iatomop double precision , allocatable :: atomopfract (:,:,:) ! natoms0, number of atoms in the primitive unit cell integer natoms0 ! natoms, number of atoms out to maxneighbors integer natoms ! atompos(j,i), jth cartesian coordinate of ith atom !  double precision atompos(3,maxatoms) real ( 8 ), allocatable :: atompos (:,:) ! iatomcell(j,i), linear combination of basis vectors of the primitive lattice ! that takes us to the unit cell containing the ith atom !  integer iatomcell(3,maxatoms) integer , allocatable :: iatomcell (:,:), iatomcell0 (:) ! iatomcell0(i), identity of atom in unit cell at origin equivalent to ith atom !  integer iatomcell0(maxatoms) ! iatomneighbor(j,i), nearest neighbor shell of jth atom in primitive unit ! cell at the origin that contains the ith atom integer , allocatable :: iatomneighbor (:,:) !      allocatable iatomneighbor,iatomop,atomopfract end module force_constants_module !============================================================ module lattice use geometry use constants implicit none type ( vector ) r1 , r2 , r3 , g1 , g2 , g3 , rr1 , rr2 , rr3 ! translation vectors of the supercell type ( vector ) r01 , r02 , r03 , g01 , g02 , g03 ! tr vect of prim cell and its recip spce real ( 8 ) volume_r , volume_g , lattice_parameter , latticeparameters ( 6 ), primitivelattice ( 3 , 3 ) real ( 8 ) box ( 3 ), boxg ( 3 ) real ( 8 ) r0g ( 3 , 3 ) integer n1min , n2min , n3min , n1max , n2max , n3max , NC ( 3 ), NF ( 3 ) integer nr1 ( 3 ), nr2 ( 3 ), nr3 ( 3 ) ! contains ! subroutine get_components(q,n,i,j,k )  !,g1,g2,g3) !! for a given q-vector, it finds its integer components assuming it was !! created as: nk=0 do i=0,N(1)-1 ; do j=0,N(2)-1; do k=0,N(3)-1; nk=nk+1 ;q=i*G1/N1+j*G2/N2+k*G3/N3 !! as the ones created in make_kp_reg with zero shift !! it works even if there's a shift less than 0.5 ! implicit none ! real(8) q(3) !,g1(3),g2(3),g3(3),r1(3),r2(3),r3(3) !! type(vector) g1,g2,g3,r1,r2,r3 ! integer i,j,k,n(3) ! !! call make_reciprocal_lattice(g1,g2,g3,r1,r2,r3) ! i = nint(1+ n(1)* (q.dot.r1)/2/pi ) ! j = nint(1+ n(2)* (q.dot.r2)/2/pi ) ! k = nint(1+ n(3)* (q.dot.r3)/2/pi ) ! ! end subroutine get_components end module lattice !=========================================================== module atoms_force_constants ! the type atom_id0 concerns the properties of the primitive unit cell ! it s atoms, masses, neighbors, shells and force constants, whereas the ! type atomic refers to atoms in the supercell, their displacements and forces. use geometry use force_constants_module implicit none integer natom_prim_cell , natom_super_cell , maxshells !------------------------- type cell_id ! id of atoms: position within cell, and cell coordinates integer n ( 3 ) integer tau !    integer at_type end type !------------------------- type shell integer no_of_neighbors ! within that shell real ( 8 ) rij ! radius of that shell type ( cell_id ) :: neighbors ( 296 ) ! id of atoms in that shell end type !------------------------- type atomic !   type(tensor1) u       ! displacement from equilibrium !   type(tensor1) force   ! force applied on it type ( vector ) equilibrium_pos type ( cell_id ) cell integer at_type real ( 8 ) mass end type !------------------------- type atom_id0 ! all characteristics of an atom in the primitive central cell integer at_type character name * 2 real ( 8 ) mass , charge integer nshells ! how many shells are included=actual dim(shell) type ( vector ) equilibrium_pos type ( shell ), allocatable :: shells (:) !0:maxshells) !    type(tensor2r), pointer :: phi2(:)  ! refers to atom numbers neighbor of i !    type(tensor3), pointer :: phi3(:,:) !    type(tensor4), pointer :: phi4(:,:,:) end type !------------------------- ! everything with 0 refers to the primitive cell integer natom_type integer , allocatable :: natom (:), atom_type (:) !label_of_primitive_atoms(:), ! integer, allocatable:: ncel1(:),ncel2(:),ncel3(:) real ( 8 ), allocatable :: atompos0 (:,:), mas (:), force (:,:,:), displ (:,:,:) real ( 8 ), allocatable :: forc (:,:), disp (:,:), vel (:,:), cur (:,:) character ( 2 ), allocatable :: atname (:) type ( atom_id0 ), allocatable :: atom0 (:) type ( atomic ), allocatable :: atom_sc (:), atom_shl (:) contains subroutine allocate_disp_forc ( n ) ! needed for the md code integer n !   allocate( disp(3,n),forc(3,n),vel(3,n),cur(3,n),ncel1(n),ncel2(n),ncel3(n) ) allocate ( disp ( 3 , n ), forc ( 3 , n ), vel ( 3 , n ), cur ( 3 , n ) ) end subroutine allocate_disp_forc subroutine allocate_pos ( n , m ) integer n , m !   allocate( pos(n,m),force(3,n,m) ) allocate ( displ ( 3 , n , m ), force ( 3 , n , m ) ) end subroutine allocate_pos subroutine allocate_mass ( n ) integer n allocate ( mas ( n ) , natom ( n ), atname ( n ) ) end subroutine allocate_mass subroutine allocate_primcell ( n0 ) integer n0 !print*,'n0=',n0 allocate ( atom0 ( n0 ), atompos0 ( 3 , n0 ), atom_type ( n0 ) ) !label_of_primitive_atoms(n0), end subroutine allocate_primcell subroutine allocate_supercell ( n ) integer n allocate ( atom_sc ( n ) ) end subroutine allocate_supercell !------------------------------------ subroutine set_neighbor_list ! this is needed in order to know what force constants to associate ! to a pair ij, or ijk or ijkl ! if a neighbor j is known then one can get the vect(i,j) between ! their equilibrium positions use force_constants_module use params use lattice use ios use geometry implicit none ! integer, parameter :: max=500 integer i0 , j , shel_count , counter , msort ( maxatoms ), l real ( 8 ) dist ( maxatoms ), d_old , d_min , rmax ! allocate( atom0(1:natoms0)%shells(maxshells) ) rmax = 0 ; dist = 1 d10 do i0 = 1 , natoms0 allocate ( atom0 ( i0 )% shells ( 0 : maxshells ) ) do j = 1 , natoms call calculate_distance ( i0 , j , atompos , maxatoms , dist ( j ) ) !      if ( iatomneighbor(i0,j) .eq. nshells(2) .and. dist(j) .gt. rmax ) then if ( iatomneighbor ( i0 , j ) . eq . nshells ( 2 , i0 ) . and . dist ( j ) . gt . rmax ) then rmax = dist ( j ) endif enddo call sort ( natoms , dist , msort , maxatoms ) shel_count = - 1 d_old = 0 write ( ulog , * ) ' =========================================================' write ( ulog , * ) ' neighborlist j, of atom i0 in atompos array =' , i0 jloop : do j = 1 , min ( 500 , natoms ) ! assign the first 500 neighbors d_min = dist ( msort ( j )) if ( ( d_min . myeq . d_old ) . and . ( shel_count . ne . - 1 ) ) then ! same shell counter = counter + 1 else ! new shell shel_count = shel_count + 1 counter = 1 if ( shel_count . gt . maxshells ) then write ( ulog , * ) maxshells , ' shells completed' write ( ulog , * ) 'shel_count=' , shel_count , ' exceeded it for j=' , j exit jloop endif d_old = d_min endif if ( counter . gt . 296 ) then write ( ulog , * ) ' counter in neighbors exceeded 296 ' , counter stop endif atom0 ( i0 )% shells ( shel_count )% no_of_neighbors = counter atom0 ( i0 )% shells ( shel_count )% rij = d_min atom0 ( i0 )% shells ( shel_count )% neighbors ( counter )% tau = iatomcell0 ( msort ( j )) atom0 ( i0 )% shells ( shel_count )% neighbors ( counter )% n = iatomcell (:, msort ( j )) write ( ulog , * ) ' ------------------------------------' write ( ulog , 5 ) ' count, j, of tau =' , j , msort ( j ), iatomcell0 ( msort ( j )), & & iatomcell (:, msort ( j )) !      write(ulog,3)' cell (n1,n2,n3) =' write ( ulog , 2 ) ' shell# , neighb#, neighbdist =' , shel_count , counter ,( atompos ( l , msort ( j )), l = 1 , 3 ), d_min !       write(ulog,6)' neighbor distance=',d_min !      write(ulog,4)' neighborshel,xyz =',iatomneighbor(i0,msort(j)) enddo jloop do shel_count = 0 , maxshells write ( ulog , * ) 'shell#, neigh#=' , shel_count , atom0 ( i0 )% shells ( shel_count )% no_of_neighbors enddo ! also initialize atom0%equilibrium_pos ! shift the position of the first atom to the  origin !do i=1,natoms0 !   atompos(:,i) = atompos(:,i)-atompos(:,1) !    atom0(i0)%equilibrium_pos = atompos0(1,i0)*r01 + atompos0(2,i0)*r02  & !&                             + atompos0(3,i0)*r03 atom0 ( i0 )% equilibrium_pos % x = atompos ( 1 , i0 ) atom0 ( i0 )% equilibrium_pos % y = atompos ( 2 , i0 ) atom0 ( i0 )% equilibrium_pos % z = atompos ( 3 , i0 ) !enddo ! they might not be inside the primitive cell enddo rcut ( 2 ) = rmax 2 format ( a , 2 ( 2 x , i4 ), ', (' , 3 ( 1 x , f8 . 4 ), ') ,' , 3 x , f10 . 5 ) !3 format(a,' (',i4,2(1x,i4),1x,')') !4 format(a,1x,i4,' (',f8.4,2(1x,f8.4),1x,')') 5 format ( a , 3 ( 2 x , i4 ), ' (' , i4 , 2 ( 1 x , i4 ), 1 x , ')' ) !6 format(a,2x,g16.7) end subroutine set_neighbor_list end module atoms_force_constants !============================================================ module svd_stuff ! stuff related to Harold's subroutines, mappings and the svd matrices type groupmatrix real ( 8 ), allocatable :: mat (:,:) integer , allocatable :: iat (:,:), ixyz (:,:), iatind (:,:), ixyzind (:,:) end type groupmatrix type fulldmatrix type ( groupmatrix ), allocatable :: gr (:) integer , allocatable :: nt (:), ntind (:), igr (:) character ( 1 ), allocatable :: err (:) integer ngr , ntotind , ntot ! number of groups, total number of independent terms and full terms end type fulldmatrix integer maxrank , maxgroups , itrans , irot , ihuang , enforce_inv integer nterms ( 4 ), maxterms ( 4 ), maxtermsindep ( 4 ), ngroups ( 4 ) ! integer ndindp(4),ndfull(4) parameter ( maxrank = 4 ) integer , allocatable :: nterm (:), ntermsindep (:) integer , allocatable :: iatomtermindep (:,:,:), ixyztermindep (:,:,:) integer , allocatable :: iatmtrm (:,:,:), ixyztrm (:,:,:) real ( 8 ), allocatable :: mapmat (:,:,:) real ( 8 ) svdcut , radius ( 4 ) integer , allocatable :: iatomterm_1 (:,:), ixyzterm_1 (:,:), igroup_1 (:), map_1 (:) integer , allocatable :: iatomterm_2 (:,:), ixyzterm_2 (:,:), igroup_2 (:), map_2 (:) integer , allocatable :: iatomterm_3 (:,:), ixyzterm_3 (:,:), igroup_3 (:), map_3 (:) integer , allocatable :: iatomterm_4 (:,:), ixyzterm_4 (:,:), igroup_4 (:), map_4 (:) character ( 1 ), allocatable :: err_1 (:), err_2 (:), err_3 (:), err_4 (:) type ( fulldmatrix ) map ( 4 ) real ( 8 ), allocatable :: ampterm_1 (:), fcs_1 (:) real ( 8 ), allocatable :: ampterm_2 (:), fcs_2 (:), grun_fc (:) real ( 8 ), allocatable :: ampterm_3 (:), fcs_3 (:) real ( 8 ), allocatable :: ampterm_4 (:), fcs_4 (:) real ( 8 ), allocatable :: amat (:,:), bmat (:), sigma (:), fcs (:), ahom (:,:), overl (:,:) real ( 8 ), allocatable :: a11ia12 (:,:), fc1 (:) real ( 8 ), allocatable :: arot (:,:), brot (:), atransl (:,:), ahuang (:,:), aforce (:,:), bforce (:) real ( 8 ), allocatable :: fc_ind (:) ! This is for getting force constant by reading FC2.dat file integer inv_constraints , force_constraints , dim_al , dim_ac , n_indep , newdim_al , dim_hom & & , transl_constraints , rot_constraints , huang_constraints , ngr contains subroutine set_maxterms maxterms ( 1 ) = 15 maxterms ( 2 ) = 200 maxterms ( 3 ) = 200 maxterms ( 4 ) = 600 maxtermsindep ( 1 ) = 5 maxtermsindep ( 2 ) = 30 maxtermsindep ( 3 ) = 30 maxtermsindep ( 4 ) = 60 maxgroups = 90 end subroutine set_maxterms end module svd_stuff !============================================================ function bring_to_prim_cell_cav ( a ) result ( w ) ! takes cartesian coordinates and returns cart coordinates within the primcell use lattice use geometry implicit none type ( vector ) v , w , bring_to_prim_cell_cv real ( 8 ) a ( 3 ) v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) w = bring_to_prim_cell_cv ( v ) end function bring_to_prim_cell_cav !----------------------------------------- function bring_to_super_cell_cav ( a ) result ( w ) ! takes cart coordinates and returns cart coordinates within the supercell use lattice use geometry implicit none type ( vector ) v , w , bring_to_super_cell_cv real ( 8 ) a ( 3 ) v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) w = bring_to_super_cell_cv ( v ) end function bring_to_super_cell_cav !----------------------------------------- function bring_to_prim_cell_caa ( a ) result ( b ) ! takes cartesian coordinates and returns cart coordinates within the primcell use lattice use geometry implicit none type ( vector ) v , w , bring_to_prim_cell_cv real ( 8 ) a ( 3 ), b ( 3 ) v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) w = bring_to_prim_cell_cv ( v ) b ( 1 ) = w % x ; b ( 2 ) = w % y ; b ( 3 ) = w % z end function bring_to_prim_cell_caa !----------------------------------------- function bring_to_super_cell_caa ( a ) result ( b ) ! takes cart coordinates and returns cart coordinates within the supercell use lattice use geometry implicit none type ( vector ) v , w , bring_to_super_cell_cv real ( 8 ) a ( 3 ), b ( 3 ) v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) w = bring_to_super_cell_cv ( v ) b ( 1 ) = w % x ; b ( 2 ) = w % y ; b ( 3 ) = w % z end function bring_to_super_cell_caa !----------------------------------------- function bring_to_prim_cell_cv ( v ) result ( w ) ! takes cartesian coordinates and returns cart coordinates within the primcell use lattice use geometry implicit none type ( vector ) v , w real ( 8 ) a1 , a2 , a3 ! get direct coordinates first a1 = v . dot . g01 a2 = v . dot . g02 a3 = v . dot . g03 ! bring into cell: between 0 and cell a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) ! convert to cartesian coordinates w = a1 * r01 + a2 * r02 + a3 * r03 end function bring_to_prim_cell_cv !----------------------------------------- function bring_to_super_cell_cv ( v ) result ( w ) ! takes cart coordinates and returns cart coordinates within the supercell use lattice use geometry implicit none type ( vector ) v , w real ( 8 ) a1 , a2 , a3 ! get direct coordinates first a1 = v . dot . g1 a2 = v . dot . g2 a3 = v . dot . g3 ! bring into cell: between 0 and cell a1 = a1 - floor ( a1 ) a2 = a2 - floor ( a2 ) a3 = a3 - floor ( a3 ) ! convert to cartesian coordinates w = a1 * r1 + a2 * r2 + a3 * r3 end function bring_to_super_cell_cv !----------------------------------- subroutine cart_to_direct_v ( v , w ) ! takes cart coordinates and returns cart coordinates within the supercell use lattice use geometry implicit none type ( vector ) v , w w % x = v . dot . g1 w % y = v . dot . g2 w % z = v . dot . g3 end subroutine cart_to_direct_v !----------------------------------- subroutine cart_to_direct_av ( a , w ) ! takes cart coordinates and returns cart coordinates within the supercell use lattice use geometry implicit none real ( 8 ) a ( 3 ) type ( vector ) v , w v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) call cart_to_direct_v ( v , w ) end subroutine cart_to_direct_av !----------------------------------- subroutine cart_to_direct_aa ( a , b ) ! takes cart coordinates and returns cart coordinates within the supercell use geometry use lattice implicit none real ( 8 ) a ( 3 ), b ( 3 ) type ( vector ) v , w v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) call cart_to_direct_v ( v , w ) b ( 1 ) = w % x ; b ( 2 ) = w % y ; b ( 3 ) = w % z end subroutine cart_to_direct_aa !----------------------------------- subroutine direct_to_cart_v ( v , w ) ! takes direct coordinates and returns cart coordinates use geometry use lattice implicit none type ( vector ) v , w w % x = v % x * r1 % x + v % y * r2 % x + v % z * r3 % x w % y = v % x * r1 % y + v % y * r2 % y + v % z * r3 % y w % z = v % x * r1 % z + v % y * r2 % z + v % z * r3 % z end subroutine direct_to_cart_v !----------------------------------- subroutine direct_to_cart_av ( a , w ) ! takes direct coordinates and returns cart coordinates use geometry use lattice implicit none real ( 8 ) a ( 3 ) type ( vector ) v , w v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) call direct_to_cart_v ( v , w ) end subroutine direct_to_cart_av !----------------------------------- subroutine direct_to_cart_aa ( a , b ) ! takes direct coordinates and returns cart coordinates use geometry use lattice implicit none real ( 8 ) a ( 3 ), b ( 3 ) type ( vector ) v , w v % x = a ( 1 ) ; v % y = a ( 2 ) ; v % z = a ( 3 ) call direct_to_cart_v ( v , w ) b ( 1 ) = w % x ; b ( 2 ) = w % y ; b ( 3 ) = w % z end subroutine direct_to_cart_aa !------------------------------------ subroutine dir2cart_g ( q , k ) ! takes q in direct coordinates and outputs k in cartesian use geometry use lattice real ( 8 ) q ( 3 ), k ( 3 ) k (:) = q ( 1 ) * g1 + q ( 2 ) * g2 + q ( 3 ) * g3 end subroutine dir2cart_g !=========================================================== module born real ( 8 ) epsil ( 3 , 3 ) real ( 8 ), allocatable :: zeu (:,:,:) real ( 8 ) rho integer born_flag end module born !===========================================================","tags":"","loc":"sourcefile/modules9.f90.html"},{"title":"others3_nshells.f90 – Example Project","text":"This file depends on sourcefile~~others3_nshells.f90~~EfferentGraph sourcefile~others3_nshells.f90 others3_nshells.f90 sourcefile~modules9.f90 modules9.f90 sourcefile~others3_nshells.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Functions voigt Subroutines set_translational_inv_constraints set_rotational_inv_constraints set_force_displacement_matrix setup_maps include_constraints homogeneous_constraints_overlap estimate_inv_constraints get_dim check_zero_column find_t compare2previous_lines set_huang_inv_constraints check_huang truncate Source Code others3_nshells.f90 Source Code !============================================================================= subroutine set_translational_inv_constraints !! sets the translational invariance part of the amatrx use svd_stuff use params use atoms_force_constants use ios use geometry use force_constants_module implicit none integer i0 , j , k , ired , counter , rnk , res integer al , be , ga , de , cnt2 , g , t , ti real ( 8 ), allocatable :: atemp (:,:), btemp (:), ared1d (:), zero (:) logical new write ( * , * ) 'entering translational invce constraints routine' write ( ulog , * ) ' SETTING TRANSLATIONAL INVARIANCE CONSTRAINTS *****************' ! set dimensions of ared matrix according to the number of constraints ! exact constraints from translational invariance ! only if include_fc=1 then add the ngroups in the number of columns ! ngr = (sum(ngroups(:)*include_fc(:)*(2-include_fc(:)))) ! ngr = (sum(ngroups(:))) dim_al = inv_constraints call write_out ( ulog , 'Estimated # of invariance constraints' , inv_constraints ) call write_out ( ulog , 'Total # of irreducible FCs=# of columns in Ared' , ngr ) allocate ( atemp ( dim_al , ngr ), btemp ( dim_al ), ared1d ( ngr ), zero ( ngr ) ) ! As for the mappings: if for a given term t=1,map(2)%nt(g) , we are looking ! for its corresponding atoms, we can find them according to the following ! say rank=2  ; !   map(2)%gr(g)%iat(1,t) =(0,taui)  map(2)%gr(g)%ixyz(1,t)=al !   map(2)%gr(g)%iat(2,t) =(nj,tauj)  map(2)%gr(g)%ixyz(2,t)=be ! Really the (n1,tau1)=(iatomcell(:,iatomterm(2,t)),iatomcell0(iatomterm(2,t))) ! We need to sum over the independent terms and find the corresponding FCs ! by using do ti=1,map(2)%ntind(g)  and multiply the indep fcs by map(2)%gr(g)%mat(t,ti) ! In this part supercell information is not needed, !------------------------------------------------------------------ !       TRANSLATIONAL INVARIANCES !------------------------------------------------------------------ atemp = 0 d0 ; counter = 0 ; zero = 0 d0 ; res = 0 ; rcut = 0 ! include translatnal invce constraints, otherwise calculate deviations from it write ( ulog , * ) ' TREATING TRANSLATIONAL INVARIANCES =======================' rnk = 1 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !if ( include_fc(rnk) .eq. 1 ) then ! mx=nterms(rnk) ! write(ulog,*)' Rank, alloc size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_i0 phi1_{i0,al} = 0 for all al=1,2,3 !if (mx.ne.0) then do al = 1 , 3 ared1d = zero cnt2 = 0 gloop1 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al ) cycle do ti = 1 , map ( rnk )% ntind ( g ) ired = cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'TI:rnk=1:ired=' , ired , '>ngr=' , ngr stop endif ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) enddo !     write(ulog,6)'i0,term,red_indx,ared=',iatomterm_1(1,t),t,ired,ared1d(ired) enddo enddo gloop1 !   write(ulog,11)'al,ared=',al,ared1d ! compare with previous lines of ared; write if ared1d not repeated if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = 0 d0 !      write(umatrx,7)(atemp(counter,dum),dum=1,ngr) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) ' DIM_AL TOO SMALL tr_inv rnk=' , rnk endif enddo if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) ! !endif write ( ulog , * ) ' RANK=1; residual index is=' , res endif rnk = 2 !------------------------------------------ !if ( include_fc(rnk) .ne. 0 ) then if ( include_fc ( rnk ) . eq . 1 ) then ! mx=nterms(rnk) ! write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_{n1 tau1} phi2_{tau al,n1 tau1 be} = 0 for all al,be,tau do i0 = 1 , natoms0 do al = 1 , 3 do be = al , 3 ! avoid redundancies in the constraints ared1d = zero cnt2 = 0 ! cnt2 counts the previous independent terms gloop2 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . & & map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al . or . map ( rnk )% gr ( g )% ixyz ( 2 , t ) . ne . be ) cycle do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'TI:rnk=2:ired=' , ired , '>ngr=' , ngr stop endif ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) enddo !     write(ulog,6)'term,ti,red_indx,ared=',t,ti,ired,ared1d(ired) enddo enddo gloop2 ! compare with previous lines of ared; write if ared1d not repeated if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = 0 d0 !      write(umatrx,7)(atemp(counter,dum),dum=1,ngr) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) ' DIM_AL TOO SMALL tr_inv rnk=' , rnk endif enddo enddo enddo ! res = res + sum(map(rnk)%ntind(:)) if ( map ( rnk )% ngr . gt . 0 . and . include_fc ( 2 ). eq . 1 ) res = res + sum ( map ( rnk )% ntind (:)) ! write ( ulog , * ) ' RANK=2; residual index is=' , res endif rnk = 3 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !if ( include_fc(rnk) .eq. 1 ) then ! mx=nterms(rnk) ! write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_{k} phi3_{i0 al,j be,k ga} = 0 ! for all al,be,ga and i0,j do i0 = 1 , natoms0 do j = 1 , natoms ! take only j atoms within the nshells'th neighbor shell of i0 !   if ( iatomneighbor(i0,j) .gt. nshells(rnk) ) cycle !   if ( iatomneighbor(i0,j) .eq. nshells(rnk) ) then if ( iatomneighbor ( i0 , j ) . gt . nshells ( rnk , i0 ) ) cycle if ( iatomneighbor ( i0 , j ) . eq . nshells ( rnk , i0 ) ) then rcut ( rnk ) = length ( atompos (:, j ) - atompos (:, i0 )) endif do al = 1 , 3 do be = al , 3 ! avoid redundancies in the constraints do ga = be , 3 ! avoid redundancies in the constraints ared1d = zero cnt2 = 0 gloop3 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al & & . or . map ( rnk )% gr ( g )% iat ( 2 , t ) . ne . j . or . map ( rnk )% gr ( g )% ixyz ( 2 , t ) . ne . be & & . or . map ( rnk )% gr ( g )% ixyz ( 3 , t ) . ne . ga ) cycle do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'TI:rnk=3:ired=' , ired , '>ngr=' , ngr stop endif ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) enddo !     write(ulog,6)'i0,term,red_indx,ared=',iatomterm_1(1,t),t,ired,ared1d(ired) enddo enddo gloop3 !   write(ulog,15)'i0,j,al,be,ga,ared=',i0,j,al,be,ga,ared1d ! compare with previous lines of ared; write if ared1d not repeated if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = 0 d0 !      write(umatrx,7)(atemp(counter,dum),dum=1,ngr) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) ' DIM_AL TOO SMALL tr_inv rnk=' , rnk endif enddo enddo enddo enddo enddo ! res = res + sum(map(rnk)%ntind(:)) if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) write ( ulog , * ) ' RANK=3; residual index is=' , res write ( ulog , * ) ' RANK=3 cnter for tr cnstr=' , counter endif rnk = 4 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !if ( include_fc(rnk) .eq. 1 ) then ! mx=nterms(rnk) ! write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_{n3 tau3} phi4_{tau al,n1 tau1 be,n2 tau2 ga,n3 tau3 de}=0 ! for all al,be,ga,de and tau n1 tau1 n2 tau2 do i0 = 1 , natoms0 do j = 1 , natoms ! take only j atoms within the nshells'th neighbor shell of i0 !   if ( iatomneighbor(i0,j) .gt. nshells(rnk) ) cycle !   if ( iatomneighbor(i0,j) .eq. nshells(rnk) ) then if ( iatomneighbor ( i0 , j ) . gt . nshells ( rnk , i0 ) ) cycle if ( iatomneighbor ( i0 , j ) . eq . nshells ( rnk , i0 ) ) then rcut ( rnk ) = length ( atompos (:, j ) - atompos (:, i0 )) endif do k = 1 , natoms ! take only j atoms within the nshells'th neighbor shell of i0 !   if ( iatomneighbor(i0,k) .gt. nshells(rnk) ) cycle if ( iatomneighbor ( i0 , k ) . gt . nshells ( rnk , i0 ) ) cycle do al = 1 , 3 do be = al , 3 ! avoid redundancies in the constraints do ga = be , 3 ! avoid redundancies in the constraints do de = ga , 3 ! avoid redundancies in the constraints ared1d = zero cnt2 = 0 gloop4 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al & & . or . map ( rnk )% gr ( g )% iat ( 2 , t ) . ne . j . or . map ( rnk )% gr ( g )% ixyz ( 2 , t ) . ne . be & & . or . map ( rnk )% gr ( g )% iat ( 3 , t ) . ne . k . or . map ( rnk )% gr ( g )% ixyz ( 3 , t ) . ne . ga & & . or . map ( rnk )% gr ( g )% ixyz ( 4 , t ) . ne . de ) cycle do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'TI:rnk=4:ired=' , ired , '>ngr=' , ngr stop endif ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) enddo !     write(ulog,6)'i0,term,red_indx,ared=',iatomterm_1(1,t),t,ired,ared1d(ired) enddo enddo gloop4 !   write(ulog,17)'i0,j,k,al,be,ga,de,ared=',i0,j,k,al,be,ga,de,ared1d ! compare with previous lines of ared; write if ared1d not repeated if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = 0 d0 !      write(umatrx,7)(atemp(counter,dum),dum=1,ngr) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) ' DIM_AL TOO SMALL tr_inv rnk=' , rnk endif enddo enddo enddo enddo enddo enddo enddo !res = res + sum(map(rnk)%ntind(:)) if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) write ( ulog , * ) ' RANK=4 res=tot# of groups=' , res write ( ulog , * ) ' RANK=4 cnter for tr cnstr=' , counter endif transl_constraints = counter write ( ulog , * ) ' NUMBER OF TRANSLATIONAL CONSTRAINTS =' , transl_constraints allocate ( atransl ( transl_constraints , ngr )) atransl ( 1 : transl_constraints , 1 : ngr ) = atemp ( 1 : transl_constraints , 1 : ngr ) deallocate ( atemp , ared1d , zero ) write ( * , * ) 'exiting translational invce constraints routine' !6 format(a,3(1x,i3),66(2x,f7.3)) !7 format(66(1x,f7.3)) !11 format(a,1(1x,i3),66(2x,f7.3)) end subroutine set_translational_inv_constraints !=========================================================================== subroutine set_rotational_inv_constraints !! sets the rotational invariance part of the amatrx use svd_stuff use params use atoms_force_constants use ios use geometry use force_constants_module implicit none integer i0 , j , k , l , t , ired , counter , rnk , res , res1 , g , ti , cnt2 , cnt3 integer al , be , ga , de , mu , nu integer lc ( 3 , 3 , 3 ) real ( 8 ), allocatable :: ared1d (:), zero (:), aux (:) real ( 8 ), allocatable :: atemp (:,:), btemp (:) real ( 8 ) junk logical new !----------------------------------------------------------------- !----------------------------------------------------------------- ! BEWARE: for include_fc=2; you may need to add res to cnt3 when defining ired ! res being from the previous rank !----------------------------------------------------------------- !----------------------------------------------------------------- write ( * , * ) 'entering rotational invce constraints routine' write ( ulog , * ) ' SETTING ROTATIONAL INVARIANCE CONSTRAINTS  ******************' ! set dimensions of ared matrix according to the number of constraints !------------------------------------------------------------------ !       ROTATIONAL INVARIANCES !------------------------------------------------------------------ allocate ( atemp ( dim_al , ngr ), btemp ( dim_al ), ared1d ( ngr ), zero ( ngr ) ) write ( ulog , * ) ' TREATING ROTATIONAL INVARIANCES =======================' ! initialize the Levi-Civita symbol here (called lc) lc = 0 ; counter = 0 ; zero = 0 d0 ; atemp = 0 d0 ; btemp = 0 d0 ; junk = 0 d0 lc ( 1 , 2 , 3 ) = 1 ; lc ( 2 , 3 , 1 ) = 1 ; lc ( 3 , 1 , 2 ) = 1 lc ( 1 , 3 , 2 ) = - 1 ; lc ( 2 , 1 , 3 ) = - 1 ; lc ( 3 , 2 , 1 ) = - 1 res = 0 ; res1 = 0 rnk = 1 !------------------------------------------ !if ( include_fc(rnk) .ne. 0 ) then if ( include_fc ( rnk ) . eq . 1 ) then ! sum of the torques is zero !   mx=nterms(rnk) !   write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_i0 phi1_{i0,al} .cross. X_{i0,be} = 0 do ga = 1 , 3 ared1d = zero cnt2 = 0 gloop1 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) !         write(*,*)'g,cnt2=',g,cnt2 do t = 1 , map ( rnk )% nt ( g ) i0 = map ( rnk )% gr ( g )% iat ( 1 , t ) ! should be in the primitive cell !         write(*,*)'ga,t,i0=',ga,t,i0 ! ADDED LINE BY K1 on JULY 10th &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& if ( i0 . ne . iatomcell0 ( i0 ) ) cycle ! restrict to atoms in the primitive cell ! ADDED LINE BY K1 on JULY 10th &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& al = map ( rnk )% gr ( g )% ixyz ( 1 , t ) do ti = 1 , map ( rnk )% ntind ( g ) ired = cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=1:ired=' , ired , '>ngr=' , ngr stop endif do be = 1 , 3 ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) * atompos ( be , i0 ) * lc ( al , be , ga ) enddo enddo if ( verbose ) write ( ulog , 5 ) 'i0,g,term,ired,ared=' , i0 , g , t , ired , ared1d ( ired ) enddo enddo gloop1 !      write(ulog,11)'al,ared=',al,ared1d ! compare with previous lines of ared; write if ared1d not repeated if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = 0 d0 !        write(umatrx,7)(atemp(counter,dum),dum=1,ngr),btemp(counter) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) 'DIM_AL TOO SMALL rot_inv rnk=' , rnk endif enddo if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) write ( ulog , * ) ' RANK=1; residual index is=' , res write ( ulog , * ) ' RANK=1 cnter for rot cntr=' , counter endif rnk = 2 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then ! .and. include_fc(1) .ne. 0 ) then !   mx=nterms(rnk) allocate ( aux ( ngroups ( 1 ))) !   write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx ! constraint is : sum_{n1 tau1} phi2_{tau al,n1 tau1 be} X_{n1 tau1 be'} + ! phi1_{tau be} delta_{al be'} symm wrt be<-> be'  for all tau,al,be,be' do i0 = 1 , natoms0 do al = 1 , 3 do de = 1 , 3 ared1d = zero cnt2 = 0 junk = 0 ; if ( include_fc ( 2 ) . eq . 1 ) then gloop12 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al ) cycle j = map ( rnk )% gr ( g )% iat ( 2 , t ) ; be = map ( rnk )% gr ( g )% ixyz ( 2 , t ) do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=2:ired=' , ired , '>ngr=' , ngr stop endif do ga = 1 , 3 ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) * atompos ( ga , j ) * lc ( be , ga , de ) enddo enddo if ( verbose ) write ( ulog , 5 ) 'i0,g,t,ired,ared=' , i0 , g , t , ired , ared1d ( ired ) enddo enddo gloop12 elseif ( include_fc ( 2 ) . eq . 2 ) then !if (include_fc(2) .eq. 2) then ! bring this piece to the RHS( bmat) !btemp(counter)=-sum(ared1d) !endif !      call read_fcs_2(2) gloop13 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al ) cycle j = map ( rnk )% gr ( g )% iat ( 2 , t ) ; be = map ( rnk )% gr ( g )% ixyz ( 2 , t ) do ti = 1 , map ( rnk )% ntind ( g ) ired = cnt2 + ti !  ired = res+cnt2+ti    ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=2:ired=' , ired , '>ngr=' , ngr stop endif do ga = 1 , 3 junk = junk - fc_ind ( ired ) * atompos ( ga , j ) * lc ( be , ga , de ) !UNCOMMENT      !map(rnk)%gr(g)%mat(t,ti)*atompos(ga,j)*lc(be,ga,de) !ared1d(ired) = ared1d(ired) + map(rnk)%gr(g)%mat(t,ti)*atompos(ga,j)*lc(be,ga,de) enddo enddo if ( verbose ) write ( ulog , 5 ) 'i0,g,t,ired,ared=' , i0 , g , t , ired , ared1d ( ired ) enddo enddo gloop13 endif ! TO CHECK------------ !   ared1d = -ared1d ! TO CHECK------------ aux = 0 ; ! junk = 0   ! junk goes to bmat (it already includes the - sign) cnt3 = 0 if ( include_fc ( 1 ) . eq . 1 . or . include_fc ( 1 ) . eq . 2 ) then do g = 1 , map ( rnk - 1 )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt3 = cnt3 + map ( rnk - 1 )% ntind ( g - 1 ) do t = 1 , map ( rnk - 1 )% nt ( g ) if ( map ( rnk - 1 )% gr ( g )% iat ( 1 , t ) . ne . i0 ) cycle be = map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) do ti = 1 , map ( rnk - 1 )% ntind ( g ) ired = cnt3 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=2 ired=' , ired , '>ngr=' , ngr stop endif ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( be , al , de ) enddo enddo enddo endif !     if(include_fc(1) .eq. 2) then  ! put it on the right hand side in b !       do g=1,map(rnk-1)%ngr       ! ngroups(1) !       do t=1,map(rnk-1)%nt(g)        !   t = map_1(j) !          junk = junk - aux(igroup_1(t))*fcs_1(igroup_1(t)) !       enddo !     endif ! now set ared1d properly !     if(include_fc(1) .eq. 1) then !      ared1d( 1:ngroups(1) ) = aux !     endif if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = junk !        write(umatrx,7)(atemp(counter,dum),dum=1,ngr),btemp(counter) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) 'DIM_AL TOO SMALL rot_inv rnk=' , rnk endif enddo enddo enddo deallocate ( aux ) if ( include_fc ( 2 ) . eq . 1 ) then if ( map ( rnk )% ngr . gt . 0 ) then write ( * , * ) \"RNK and RES1 are: \" , rnk , res1 !res1=res1+map(1)%ntotind(:) endif if ( map ( rnk - 1 )% ngr . gt . 0 ) then write ( * , * ) \"RNK and RES1 are: \" , rnk , res1 !res1 = res1 + map(1)%ntotind(:) endif elseif ( include_fc ( 2 ) . eq . 2 ) then if ( map ( rnk - 1 )% ngr . gt . 0 ) then write ( * , * ) \"RNK and RES1 are: \" , rnk , res1 !res1 = res1 + map(1)%ntotind(:) endif endif write ( ulog , * ) ' RI: RANK=2; residual index is=' , res write ( ulog , * ) ' RANK=2 cnter for rot cntr=' , counter endif rnk = 3 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !   mx=nterms(rnk) allocate ( aux ( map ( 2 )% ntotind )) !  allocate(aux(ngroups(2))) ! It was this before write ( ulog , * ) ' allocated size of aux is=' , map ( 2 )% ntotind do i0 = 1 , natoms0 do j = 1 , natoms !      if ( iatomneighbor(i0,j) .gt. nshells(rnk) ) cycle if ( iatomneighbor ( i0 , j ) . gt . nshells ( rnk , i0 ) ) cycle do al = 1 , 3 do be = 1 , 3 do nu = 1 , 3 ared1d = zero cnt2 = 0 gloop33 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors !two gloop13 here defined previously need to change previous one if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al ) cycle if ( map ( rnk )% gr ( g )% iat ( 2 , t ) . ne . j . or . map ( rnk )% gr ( g )% ixyz ( 2 , t ) . ne . be ) cycle k = map ( rnk )% gr ( g )% iat ( 3 , t ) ; ga = map ( rnk )% gr ( g )% ixyz ( 3 , t ) do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=3:ired=' , ired , '>ngr=' , ngr stop endif do de = 1 , 3 ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) * atompos ( de , k ) * lc ( ga , de , nu ) enddo enddo if ( verbose ) write ( ulog , 5 ) 'i0,g,t,ired,ared=' , i0 , g , t , ired , ared1d ( ired ) enddo enddo gloop33 ! TO CHECK------------ !   ared1d = -ared1d ! TO CHECK------------ aux = 0 ; junk = 0 ! junk goes to bmat (it already includes the - sign) cnt3 = 0 if ( include_fc ( 2 ) . eq . 1 ) then !  if(include_fc(2) .eq. 1 .or. include_fc(2) .eq. 2) then ! It was like this before do g = 1 , map ( rnk - 1 )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt3 = cnt3 + map ( rnk - 1 )% ntind ( g - 1 ) do t = 1 , map ( rnk - 1 )% nt ( g ) if ( map ( rnk - 1 )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk - 1 )% gr ( g )% iat ( 2 , t ) . ne . j ) cycle do ti = 1 , map ( rnk - 1 )% ntind ( g ) ired = res1 + cnt3 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=3 ired=' , ired , '>ngr=' , ngr stop endif if ( map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) . eq . be ) then ga = map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( ga , al , nu ) elseif ( map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) . eq . al ) then ga = map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( ga , be , nu ) endif enddo enddo enddo endif write ( * , * ) \"Value of include_fc(2) is: \" , include_fc ( 2 ) if ( include_fc ( 2 ) . eq . 2 ) then ! So in this case include_fc(2) equals 1 or 2 are separated see exactly above !     call read_fcs_2(2) write ( * , * ) \"value of map(rnk-1)%ngr is: \" , map ( rnk - 1 )% ngr do g = 1 , map ( rnk - 1 )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt3 = cnt3 + map ( rnk - 1 )% ntind ( g - 1 ) do t = 1 , map ( rnk - 1 )% nt ( g ) if ( map ( rnk - 1 )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk - 1 )% gr ( g )% iat ( 2 , t ) . ne . j ) cycle do ti = 1 , map ( rnk - 1 )% ntind ( g ) ired = cnt3 + ti ! this is the corresponding index of i in ared !          ired = res1+ cnt3+ti    ! this is the corresponding index of i in ared ! was this before write ( * , * ) \"value of ired is: \" , ired if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=3 ired=' , ired , '>ngr=' , ngr stop endif if ( map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) . eq . be ) then ga = map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) aux ( ired ) = aux ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( ga , al , nu ) ! ared1d(ired) = ared1d(ired) + map(rnk-1)%gr(g)%mat(t,ti)*lc(ga,al,nu) ! was this before elseif ( map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) . eq . al ) then ga = map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) aux ( ired ) = aux ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( ga , be , nu ) ! ared1d(ired) = ared1d(ired) + map(rnk-1)%gr(g)%mat(t,ti)*lc(ga,be,nu) ! was like this before endif enddo enddo enddo write ( * , * ) \"Junk before is given by this: \" , junk junk = junk - dot_product ( aux , fc_ind ) ! This is added here make sure fc_ind is declared global write ( * , * ) \"Junk after this is given by: \" , junk endif !     if(include_fc(2) .eq. 2) then  ! put it on the right hand side in b !       do k=1,ngroups(2) !          t = map_2(k) !          ired = igroup_2(t) !          junk = junk - aux(ired)*fcs_2(igroup_2(t)) !       enddo !     endif !     if(include_fc(2) .eq. 1) then !      ared1d( res-ngroups(2)+1:res ) = aux !     endif if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = junk !        write(umatrx,7)(atemp(counter,dum),dum=1,ngr),btemp(counter) if ( verbose ) write ( ulog , 5 ) 'ROT:new term for:i0,j,al,be,nu=' , i0 , j , al , be , real ( nu ) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) 'DIM_AL TOO SMALL rot_inv rnk=' , rnk endif enddo enddo enddo enddo enddo deallocate ( aux ) if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) if ( map ( rnk - 1 )% ngr . gt . 0 . and . include_fc ( 2 ). eq . 1 ) res1 = res1 + sum ( map ( rnk - 1 )% ntind (:)) write ( ulog , * ) ' RANK=3; residual index is=' , res write ( ulog , * ) ' RANK=3 cnter for rot cntr=' , counter endif rnk = 4 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !   mx=nterms(rnk) allocate ( aux ( ngroups ( 3 ))) !   write(ulog,*)' allocated size of igroup arrays, mx=nterms(rnk) is=',rnk,mx do i0 = 1 , natoms0 do j = 1 , natoms !     if ( iatomneighbor(i0,j) .gt. nshells(rnk) ) cycle if ( iatomneighbor ( i0 , j ) . gt . nshells ( rnk , i0 ) ) cycle do k = 1 , natoms !     if ( iatomneighbor(i0,k) .gt. nshells(rnk) ) cycle if ( iatomneighbor ( i0 , k ) . gt . nshells ( rnk , i0 ) ) cycle do al = 1 , 3 do be = 1 , 3 do ga = 1 , 3 do nu = 1 , 3 ared1d = zero cnt2 = 0 gloop14 : do g = 1 , map ( rnk )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( rnk )% nt ( g ) if ( map ( rnk )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk )% gr ( g )% ixyz ( 1 , t ) . ne . al ) cycle if ( map ( rnk )% gr ( g )% iat ( 2 , t ) . ne . j . or . map ( rnk )% gr ( g )% ixyz ( 2 , t ) . ne . be ) cycle if ( map ( rnk )% gr ( g )% iat ( 3 , t ) . ne . k . or . map ( rnk )% gr ( g )% ixyz ( 3 , t ) . ne . ga ) cycle l = map ( rnk )% gr ( g )% iat ( 4 , t ) ; de = map ( rnk )% gr ( g )% ixyz ( 4 , t ) do ti = 1 , map ( rnk )% ntind ( g ) ired = res + cnt2 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=4:ired=' , ired , '>ngr=' , ngr stop endif do mu = 1 , 3 ared1d ( ired ) = ared1d ( ired ) + map ( rnk )% gr ( g )% mat ( t , ti ) * atompos ( mu , l ) * lc ( de , mu , nu ) enddo enddo enddo enddo gloop14 ! TO CHECK------------ !   ared1d = -ared1d ! TO CHECK------------ aux = 0 ; junk = 0 ! junk goes to bmat (it already includes the - sign) cnt3 = 0 if ( include_fc ( 3 ) . eq . 1 . or . include_fc ( 3 ) . eq . 2 ) then do g = 1 , map ( rnk - 1 )% ngr ! ineq. terms and identify neighbors if ( g . gt . 1 ) cnt3 = cnt3 + map ( rnk - 1 )% ntind ( g - 1 ) do t = 1 , map ( rnk - 1 )% nt ( g ) if ( map ( rnk - 1 )% gr ( g )% iat ( 1 , t ) . ne . i0 . or . map ( rnk - 1 )% gr ( g )% iat ( 2 , t ) . ne . j & & . or . map ( rnk - 1 )% gr ( g )% iat ( 3 , t ) . ne . k ) cycle do ti = 1 , map ( rnk - 1 )% ntind ( g ) ired = res1 + cnt3 + ti ! this is the corresponding index of i in ared if ( ired . gt . ngr . or . ired . lt . 1 ) then write ( ulog , * ) 'rnk=4 ired=' , ired , '>ngr=' , ngr stop endif if ( map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) . eq . be . and . map ( rnk - 1 )% gr ( g )% ixyz ( 3 , t ) . eq . ga ) then de = map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( de , al , nu ) elseif ( map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) . eq . al . and . map ( rnk - 1 )% gr ( g )% ixyz ( 3 , t ) . eq . ga ) then de = map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( de , be , nu ) elseif ( map ( rnk - 1 )% gr ( g )% ixyz ( 1 , t ) . eq . al . and . map ( rnk - 1 )% gr ( g )% ixyz ( 2 , t ) . eq . be ) then de = map ( rnk - 1 )% gr ( g )% ixyz ( 3 , t ) ared1d ( ired ) = ared1d ( ired ) + map ( rnk - 1 )% gr ( g )% mat ( t , ti ) * lc ( de , ga , nu ) endif enddo enddo enddo endif !     if(include_fc(3) .eq. 2) then  ! put it on the right hand side in b !       do l=1,ngroups(3) !          t = map_3(l) !          ired = igroup_3(t) !          junk = junk - aux(ired)*fcs_3(igroup_3(t)) !       enddo !     endif !     if(include_fc(3) .eq. 1) then !      ared1d( res-ngroups(3)+1:res ) = aux !     endif if ( ared1d . myeqz . zero ) cycle call compare2previous_lines ( dim_al , ngr , ared1d , atemp , counter , new ) if ( new ) then counter = counter + 1 ; atemp ( counter ,:) = ared1d (:); btemp ( counter ) = junk !        write(umatrx,7)(atemp(counter,dum),dum=1,ngr),btemp(counter) if ( counter . eq . dim_al - 1 ) write ( ulog , * ) 'DIM_AL TOO SMALL rot_inv rnk=' , rnk endif enddo enddo enddo enddo enddo enddo enddo deallocate ( aux ) ! res = res + sum(map(rnk)%ntind(:)) if ( map ( rnk )% ngr . gt . 0 ) res = res + sum ( map ( rnk )% ntind (:)) write ( ulog , * ) ' RANK=4; residual index is=' , res write ( ulog , * ) ' RANK=4 cnter for rot cntr=' , counter endif rot_constraints = counter write ( ulog , * ) ' NUMBER OF ROTATIONAL CONSTRAINTS =' , rot_constraints allocate ( arot ( rot_constraints , ngr ), brot ( rot_constraints )) arot ( 1 : rot_constraints , 1 : ngr ) = atemp ( 1 : counter , 1 : ngr ) brot ( 1 : rot_constraints ) = btemp ( 1 : counter ) write ( ulog , * ) ' res=' , res , ' must be equal to # of indepdt FCs ' , ngr inv_constraints = rot_constraints + transl_constraints write ( ulog , * ) ' TOTAL NUMBER OF INVARIANCE CONSTRAINTS =' , inv_constraints write ( umatrx , * ) '**********************************************' write ( umatrx , * ) ' sym constr part of amatrix size has ' , inv_constraints , ' lines' write ( umatrx , * ) '**********************************************' deallocate ( atemp , btemp , ared1d , zero ) write ( * , * ) 'exiting rotational invce constraints routine' !3 format(a,2(1x,i6),66(1x,i3)) !4 format(a,66(1x,i3)) 5 format ( a , 4 ( 1 x , i3 ), 66 ( 2 x , f7 . 3 )) !6 format(a,3(1x,i3),66(2x,f7.3)) !7 format(66(1x,f7.3)) !8 format(i8,1x,i8,3x,f25.15,3x,f25.15) !9 format(i8,1x,99(1x,f8.4)) !11 format(a,1(1x,i3),66(2x,f7.3)) !13 format(a,3(1x,i3),66(2x,f7.3)) !15 format(a,5(1x,i3),66(2x,f7.3)) !17 format(a,7(1x,i3),66(2x,f7.3)) end subroutine set_rotational_inv_constraints !=========================================================================== subroutine set_force_displacement_matrix ( frc_constr , afrc , bfrc ) use svd_stuff use params use atoms_force_constants use ios use geometry use force_constants_module implicit none integer l , t , ired , counter , rnk , nat , confg , jatom , katom , latom , res , cnt2 , a , b , c , d , e , f , i , reason integer al , be , ga , de , taui , tauj , tauk , taul , ni ( 3 ), nj ( 3 ), nk ( 3 ), nl ( 3 ), ti , frc_constr real ( 8 ), allocatable :: ared1d (:), aux (:) !, fc_ind(:) real ( 8 ) afrc ( frc_constr , ngr ), bfrc ( frc_constr ), rij , amp , rijs ! real(8) junk logical ex !new write ( * , * ) 'entering set_force_displacements routine' write ( ulog , * ) ' SETUP_AMATRICES : ************************************' ! l is group index, t: general term index, and ti: independent term index ! this convention is followed in all setting constraint or amat subroutines ! set dimensions of ared matrix according to the number of constraints !------------------------------------------------------------------ !       FORCE-DISPLACEMENT CONSTRAINTS !------------------------------------------------------------------ ! allocate(aforce(force_constraints,ngr),bforce(force_constraints)) allocate ( ared1d ( ngr ) ) !allocate(rfcs_2(map(2)%ntotind)) afrc = 0 d0 ; bfrc = 0 d0 !5 format(a,9(i5)) write ( ulog , 6 ) '********************************************************' write ( ulog , 6 ) ' Now making the force-displacement part of the A matrix' write ( ulog , * ) ' Force_constraints     =' , frc_constr ! now compute the force constraints on the FCs. The equation is: ! -F_ia = phi1_ia + phi2_{ia,jb} u_jb + 0.5 phi3_{ia,jb,kc} u_jb u_kc + ... !   iatomterm(1,t)=(0,tau)   iatomterm(2,t)=(n1,tau1) !   ixyzterm (1,t)=alpha     ixyzterm (2,t)=beta ! Really the (n1,tau1)=(iatomcell(:,iatomterm(2,t)),iatomcell0(iatomterm(2,t))) counter = 0 if ( include_fc ( 2 ) . eq . 2 ) then write ( * , * ) \"ALLOCATION CONDITION FC_IND\" !  allocate(fc_ind(map(2)%ngr)) endif do confg = 1 , nconfigs do nat = 1 , natom_super_cell do al = 1 , 3 ! this is how we order each line counter = counter + 1 ! this is basically the line number bfrc ( counter ) = - force ( al , nat , confg ) ! find the corresponding atom in the primitive cell taui = atom_sc ( nat )% cell % tau ni = atom_sc ( nat )% cell % n !       write(ulog,3)'line#,confg,i,alfa,tau,n =',counter,confg,nat,al,taui,ni ! now set up ared1d: rank by rank ared1d = 0 d0 ; res = 0 rnk = 1 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !           allocate(aux(ndindp(rnk))) ! size of aux =  # of independent FCs for that rank allocate ( aux ( map ( rnk )% ntotind )) ! size of aux =  # of independent FCs for that rank cnt2 = 0 ! cnt2 is the size of previous groups aux = 0 do l = 1 , map ( rnk )% ngr ! sum over groups if ( l . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( l - 1 ) do t = 1 , map ( rnk )% nt ( l ) ! sum over all therms in that group if ( taui . eq . map ( rnk )% gr ( l )% iat ( 1 , t ) . and . & & al . eq . map ( rnk )% gr ( l )% ixyz ( 1 , t ) ) then do ti = 1 , map ( rnk )% ntind ( l ) ! this is the index of the indep FC coming in the A*FC=b matrix product ired = cnt2 + ti !                       write(ulog,5)'l,cnt2,ti,ired=',l,cnt2,ti,ired aux ( ired ) = map ( rnk )% gr ( l )% mat ( t , ti ) enddo endif enddo enddo if ( include_fc ( rnk ) . eq . 1 ) then !              ared1d(res+1:res+ndindp(rnk)) = aux(1:ndindp(rnk)) !              res = res + ndindp(rnk) ared1d ( res + 1 : res + map ( rnk )% ntotind ) = aux ( 1 : map ( rnk )% ntotind ) res = res + map ( rnk )% ntotind !          elseif ( include_fc(rnk) .eq. 2 ) then !             do j=1,map(rnk)%ngr !                t = map_1(j) !                bfrc(counter)=bfrc(counter)-fcs_1(igroup_1(t))*aux(igroup_1(t)) !             enddo endif deallocate ( aux ) endif rnk = 2 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then ! the force on atom i is from j in the supercell and all of its images for which the corresponding FC needs to be identified !           allocate(aux(ndindp(rnk))) allocate ( aux ( map ( rnk )% ntotind )) ! ntotind is the total number of independent terms ! for given (ni,taui,al) find its neighbors within nshells(2) cnt2 = 0 ! cnt2 is the size of previous groups aux = 0 groups : do l = 1 , map ( rnk )% ngr ! sum over groups if ( l . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( l - 1 ) l8 : do t = 1 , map ( rnk )% nt ( l ) ! sum over all terms in that group if ( taui . eq . map ( rnk )% gr ( l )% iat ( 1 , t ) . and . & & al . eq . map ( rnk )% gr ( l )% ixyz ( 1 , t ) ) then tauj = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 2 , t )) nj (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 2 , t )) + ni (:) ! translate by ni be = map ( rnk )% gr ( l )% ixyz ( 2 , t ) ! Identify neighbor j within the SCell, and its images, find its displacement and add to ared call findatom_sc ( nj , tauj , jatom ) if ( jatom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:jatom not found: tau,n ' , tauj , nj write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif ! K1 NEW -------------------------- !              rij=length(atompos(:,nat)-atompos(:,jatom)) !              if (rij.gt.radius(rnk)) cycle l8 ! need to find how many images of j are connected to i with the same force constant. ! K1 NEW -------------------------- do ti = 1 , map ( rnk )% ntind ( l ) ! this is the index of the indep FC coming in the A*FC=b matrix product ired = cnt2 + ti ! this is the corresponding index of aux !                   write(ulog,5)'l,cnt2,ti,ired=',l,cnt2,ti,ired aux ( ired ) = aux ( ired ) + displ ( be , jatom , confg ) * map ( rnk )% gr ( l )% mat ( t , ti ) enddo rij = atom_sc ( nat )% equilibrium_pos . dot . atom_sc ( nat )% equilibrium_pos ! if(l.ge.11 .and. l.le.14 .and. displ(be,jatom,confg).ne.0) then !      write(*,9) nat,jatom,l,t, aux(11:14),rij ! if(l.ge.4 .and. l.le.7 .and. displ(be,jatom,confg).ne.0) then !      write(*,9) nat,jatom,l,t, aux(4:7),rij !endif !             write(ulog,22)'term,red_indx,ared=',t,iatomterm_2(1,t),  & ! &    ixyzterm_2(1,t),iatomterm_2(2,t),ixyzterm_2(2,t),ired,ared1d(ired) endif enddo l8 enddo groups if ( include_fc ( rnk ) . eq . 1 ) then ared1d ( res + 1 : res + map ( rnk )% ntotind ) = aux ( 1 : map ( rnk )% ntotind ) !              ared1d(res+1:res+ndindp(rnk)) = aux(1:ndindp(rnk)) res = res + map ( rnk )% ntotind !              res = res + ndindp(rnk) elseif ( include_fc ( rnk ) . eq . 2 ) then write ( * , * ) \"Check for include_fc(rnk) 2: \" !             inquire ( file=\"fc2_fit.dat\", exist=ex) !             if (ex) then !               open(473,file=\"fc2_fit.dat\") !                  do i=1, map(2)%ngr !                     read(473,*,iostat=reason) a, b, c, d, e, f, fc_ind(i), amp, rijs !                     if (reason > 0) then !                        write(*,*) \"something is wrong\" !                     elseif (reason < 0) then !                        write(*,*) \"END OF FILE REACHED\" !                     else !                        write(*,*) a,b,c,d,e,f,fc_ind(i),amp,rijs !                     endif !                  enddo !               close(473) !             endif !   write(*,*) \"The value for rfcsind_2 call is: \", fc_ind !   allocate(map_2(map(rnk)%ngr)) !    write(*,*) \"The value for aux is: \", aux !          call read_fcs_2(2) do l = 1 , map ( rnk )% ngr !   t = map_2(l) !   write(*,*) \"Check shape of aux and rfcsind_2: \", shape(aux), shape(rfcsind_2) write ( * , * ) \"Check for the value of BFRCS counter before: \" , bfrc ( counter ) bfrc ( counter ) = bfrc ( counter ) - dot_product ( aux , fc_ind ) ! Have to uncomment this line write ( * , * ) \"Check for the value of BFRCS counter in this case: \" , bfrc ( counter ) !  bfrc(counter)=bfrc(counter)-fcs_2(igroup_2(t))*aux(igroup_2(t)) ! shouldn't this line simply be: bf = bf - fcs_2(j) * aux(j) ?? enddo endif deallocate ( aux ) endif rnk = 3 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !           allocate(aux(ndindp(rnk))) allocate ( aux ( map ( rnk )% ntotind )) ! for given (ni,taui,al) find its two neighbors within nshells(3) cnt2 = 0 ! cnt2 is the size of previous groups aux = 0 do l = 1 , map ( rnk )% ngr ! sum over groups if ( l . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( l - 1 ) do t = 1 , map ( rnk )% nt ( l ) ! sum over all therms in that group if ( taui . eq . map ( rnk )% gr ( l )% iat ( 1 , t ) . and . & & al . eq . map ( rnk )% gr ( l )% ixyz ( 1 , t ) ) then tauj = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 2 , t )) nj (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 2 , t )) + ni (:) be = map ( rnk )% gr ( l )% ixyz ( 2 , t ) tauk = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 3 , t )) nk (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 3 , t )) + ni (:) ga = map ( rnk )% gr ( l )% ixyz ( 3 , t ) ! Identify neighbor j within the SCell, find its displacement and add to ared call findatom_sc ( nj , tauj , jatom ) if ( jatom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:jatom not found: tau,n ' , tauj , nj write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif call findatom_sc ( nk , tauk , katom ) if ( katom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:katom not found: tau,n ' , tauk , nk write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif ! K1 NEW -------------------------- !           rij=length(atompos(:,nat)-atompos(:,jatom)) !           rik=length(atompos(:,nat)-atompos(:,katom)) !           rjk=length(atompos(:,jatom)-atompos(:,katom)) !   ! cycle if two of the pair distances is larger than radius !           if (rij.gt.radius(rnk)) then !              if (rik.gt.radius(rnk) .or. rjk.gt.radius(rnk) ) cycle !           else !              if (rik.gt.radius(rnk) .and. rjk.gt.radius(rnk) ) cycle !           endif ! K1 NEW -------------------------- do ti = 1 , map ( rnk )% ntind ( l ) ! this is the index of the indep FC coming in the A*FC=b matrix product ired = cnt2 + ti ! this is the corresponding index of aux !                   write(ulog,5)'l,cnt2,ti,ired=',l,cnt2,ti,ired aux ( ired ) = aux ( ired ) + map ( rnk )% gr ( l )% mat ( t , ti ) * & & displ ( be , jatom , confg ) * displ ( ga , katom , confg ) / 2 d0 enddo endif enddo enddo if ( include_fc ( rnk ) . eq . 1 ) then !              ared1d(res+1:res+ndindp(rnk)) = aux(1:ndindp(rnk)) !              res = res + ndindp(rnk) ared1d ( res + 1 : res + map ( rnk )% ntotind ) = aux ( 1 : map ( rnk )% ntotind ) res = res + map ( rnk )% ntotind endif deallocate ( aux ) endif rnk = 4 !------------------------------------------ if ( include_fc ( rnk ) . ne . 0 ) then !           allocate(aux(ndindp(rnk))) allocate ( aux ( map ( rnk )% ntotind )) cnt2 = 0 ! cnt2 is the size of previous groups aux = 0 do l = 1 , map ( rnk )% ngr ! sum over groups if ( l . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( l - 1 ) do t = 1 , map ( rnk )% nt ( l ) ! sum over all therms in that group if ( taui . eq . map ( rnk )% gr ( l )% iat ( 1 , t ) . and . & & al . eq . map ( rnk )% gr ( l )% ixyz ( 1 , t ) ) then tauj = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 2 , t )) nj (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 2 , t )) + ni (:) be = map ( rnk )% gr ( l )% ixyz ( 2 , t ) tauk = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 3 , t )) nk (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 3 , t )) + ni (:) ga = map ( rnk )% gr ( l )% ixyz ( 3 , t ) taul = iatomcell0 ( map ( rnk )% gr ( l )% iat ( 4 , t )) nl (:) = iatomcell (:, map ( rnk )% gr ( l )% iat ( 4 , t )) + ni (:) de = map ( rnk )% gr ( l )% ixyz ( 4 , t ) ! Identify neighbor j within the SCell, find its displacement and add to ared call findatom_sc ( nj , tauj , jatom ) if ( jatom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:jatom not found: tau,n ' , tauj , nj write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif call findatom_sc ( nk , tauk , katom ) if ( katom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:katom not found: tau,n ' , tauk , nk write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif call findatom_sc ( nl , taul , latom ) if ( latom . eq . 0 ) then write ( ulog , 4 ) 'SET_ARED:katom not found: tau,n ' , taul , nl write ( ulog , 4 ) 'for rank,term ' , rnk , t write ( ulog , 4 ) 'atom,xyz,cnfg ' , nat , al , confg stop endif ! K1 NEW -------------------------- !           rij=length(atompos(:,nat)-atompos(:,jatom)) !           rik=length(atompos(:,nat)-atompos(:,katom)) !           rjk=length(atompos(:,jatom)-atompos(:,katom)) !   ! cycle if two of the pair distances is larger than radius !           if (rij.gt.radius(rnk)) then !              if (rik.gt.radius(rnk) .or. rjk.gt.radius(rnk) ) cycle !           else !              if (rik.gt.radius(rnk) .and. rjk.gt.radius(rnk) ) cycle !           endif ! K1 NEW -------------------------- do ti = 1 , map ( rnk )% ntind ( l ) ! this is the index of the indep FC coming in the A*FC=b matrix product ired = cnt2 + ti ! this is the corresponding index of aux !                   write(ulog,5)'l,cnt2,ti,ired=',l,cnt2,ti,ired aux ( ired ) = aux ( ired ) + map ( rnk )% gr ( l )% mat ( t , ti ) * & & displ ( be , jatom , confg ) * displ ( ga , katom , confg ) * displ ( de , latom , confg ) / 6 d0 enddo endif enddo enddo if ( include_fc ( rnk ) . eq . 1 ) then !              ared1d(res+1:res+ndindp(rnk)) = aux(1:ndindp(rnk)) !              res = res + ndindp(rnk) ared1d ( res + 1 : res + map ( rnk )% ntotind ) = aux ( 1 : map ( rnk )% ntotind ) res = res + map ( rnk )% ntotind endif deallocate ( aux ) endif ! now write into the ared matrix ( we assume force terms are not redundant ! otherwise after the SVD, w matrix will have very small or zero elements) afrc ( counter ,:) = ared1d (:) !        if(verbose) write(umatrx,7)(afrc(counter,l),l=1,ngr),bfrc(counter) !make sure the index ired is not repeated for each rank and is increased !from a given rank to a higher rank enddo enddo enddo write ( umatrx , * ) '**********************************************' write ( umatrx , * ) ' Force-displ constraints part of amatrix size is ' , counter write ( umatrx , * ) '**********************************************' deallocate ( ared1d ) write ( * , * ) 'exiting set_force_displacements routine' 4 format ( a , 4 ( 1 x , i6 )) 6 format ( a , 3 ( 1 x , i3 ), 66 ( 2 x , f7 . 3 )) !7 format(66(1x,g9.2)) !9 format(4(i4),66(1x,g9.2)) !12 format(a,2(1x,i3),66(2x,g11.4)) !22 format(a,6(1x,i3),66(2x,f9.5)) end subroutine set_force_displacement_matrix !=============================================================================== subroutine setup_maps !! maps the output of collect_fcs to the new arrays for each rank, !! with the proper (allocatable) dimensions use svd_stuff use params use atoms_force_constants use ios use geometry implicit none character lineout * 80 integer j , i , n , m , mx , mxi , mxzero , rnk & & , ntermszero , nd , ntindp , ierz , iert , ieri , ierg , jnk integer , allocatable :: iatomtermzero (:,:), ixyztermzero (:,:) ! logical new write ( * , * ) 'entering setup_maps routine' !write(*,*) \"The value of include_fc(2) isbikash: \", include_fc(2) call write_out ( ulog , ' #include_FCs ' , include_fc ) call write_out ( ulog , ' #   maxterms ' , maxterms ) call write_out ( ulog , ' #r=1 nshells ' , nshells ( 1 ,:)) call write_out ( ulog , ' #r=2 nshells ' , nshells ( 2 ,:)) call write_out ( ulog , ' #r=3 nshells ' , nshells ( 3 ,:)) call write_out ( ulog , ' #r=4 nshells ' , nshells ( 4 ,:)) write ( ulog , * ) '# trans,rot,huang,enforce_inv=' , itrans , irot , ihuang , enforce_inv nd = sum ( include_fc ) if ( nd . gt . 4 ) then write ( ulog , * ) 'SETUP_MAPS: nd>4, check your include_fc array ' , nd write ( * , * ) 'SETUP_MAPS: nd>4, check your include_fc array ' , nd , include_fc ( 2 ) if ( include_fc ( 2 ) . eq . 2 ) then write ( * , * ) \"SUM OF INCLUDE FORCE_CONSTANT IS GREATER THAN 4\" !   call read_harm_fcs(2) endif !    stop endif write ( ulog , * ) ' SETUP_MAPS: ********************************' ! loop over ranks that are supposed to be included !if(include_fc(2) .eq. 2) then  ! This is what you have to do in order for to get force constant and declare fc_ind as global !call read_fcs_2(2) !endif ! ----------------------------------- rankloop : do rnk = 1 , 4 !,1,-1 if ( include_fc ( rnk ) . ne . 0 ) then write ( * , * ) \"This condition is satisfied:::\" mx = maxterms ( rnk ) mxi = maxtermsindep ( rnk ) write ( ulog , 4 ) 'rank,mx,mxi,maxgrps=' , rnk , mx , mxi , maxgroups mxzero = 90 iert = 1 ; ieri = 1 ; ierz = 1 write ( * , * ) \"The value for ierg is: \" , ierg , iert , ieri , ierz ! start from a small maxterms and maxtermszero and increase by 100 if too small checkloop : do while ( ierg + ierz + iert + ieri . ne . 0 ) write ( * , * ) \"IF IERGIERZ is satisfied::\" !write(*,*) \"VALUES: nterm, ntermsindep, mapmat, iatmtrm, ixyzterm, iatomtermindep, ixyztermindep, iatomtermzero, ixyztermzero\", & !& nterm, ntermsindep, mapmat, iatmtrm, iatomtermindep, ixyztermindep, iatomtermzero, ixyztermzero write ( * , 4 ) 'maxtrmzero,maxtrm,maxtrmindp,maxgrp=' , mxzero , mx , mxi , maxgroups !    allocate(mapmat(mx,mxi,maxgroups) & !    &     ,iatmtrm(rnk,mx,maxgroups),ixyztrm(rnk,mx,maxgroups)  & !    &     ,iatomtermindep(rnk,mx,maxgroups),ixyztermindep(rnk,mx,maxgroups)  ) if (. not . allocated ( nterm )) allocate ( nterm ( maxgroups )) if (. not . allocated ( ntermsindep )) allocate ( ntermsindep ( maxgroups )) if (. not . allocated ( mapmat )) allocate ( mapmat ( mx , mxi , maxgroups )) if (. not . allocated ( iatmtrm )) allocate ( iatmtrm ( rnk , mx , maxgroups )) if (. not . allocated ( ixyztrm )) allocate ( ixyztrm ( rnk , mx , maxgroups )) if (. not . allocated ( iatomtermindep )) allocate ( iatomtermindep ( rnk , mx , maxgroups )) if (. not . allocated ( ixyztermindep )) allocate ( ixyztermindep ( rnk , mx , maxgroups )) if (. not . allocated ( iatomtermzero )) allocate ( iatomtermzero ( rnk , mxzero )) if (. not . allocated ( ixyztermzero )) allocate ( ixyztermzero ( rnk , mxzero )) write ( ulog , 4 ) ' calling collect_force_constants for rank,ier:ztig=' , rnk , ierz , iert , ieri , ierg call collect_force_constants ( rnk , nshells ( rnk ,:), ngroups ( rnk ), ntermsindep , & & iatomtermindep , ixyztermindep , nterm , iatmtrm , ixyztrm , & & mapmat , ntermszero , iatomtermzero , ixyztermzero , rnk , mx , & & mxi , mxzero , maxgroups , ierz , iert , ieri , ierg ) write ( ulog , 4 ) ' collect_force_constants called with ier:ztig=' , ierz , iert , ieri , ierg 4 format ( a , 9 ( i5 )) if ( ierz . ne . 0 ) then !     mxzero = mxzero+30*(4**rnk) mxzero = mxzero + 333 * rnk write ( ulog , * ) ' mxtermszero   increased to ' , mxzero if ( allocated ( iatomtermzero )) deallocate ( iatomtermzero ) if ( allocated ( ixyztermzero )) deallocate ( ixyztermzero ) endif if ( iert . ne . 0 ) then !        mx = mx*2 !+(5**rnk)*natoms0 mx = mx + 30 * rnk * natoms0 write ( ulog , * ) ' maxterms      increased to ' , mx if ( allocated ( mapmat )) deallocate ( mapmat ) if ( allocated ( iatmtrm )) deallocate ( iatmtrm ) if ( allocated ( ixyztrm )) deallocate ( ixyztrm ) if ( allocated ( iatomtermindep )) deallocate ( iatomtermindep ) if ( allocated ( ixyztermindep )) deallocate ( ixyztermindep ) endif if ( ieri . ne . 0 ) then !        mxi= mxi*2 ! +50*(2**rnk)*natoms0 mxi = mxi + 10 * rnk * natoms0 write ( ulog , * ) ' maxtermsindep increased to ' , mxi if ( allocated ( mapmat )) deallocate ( mapmat ) endif if ( ierg . ne . 0 ) then !        maxgroups= maxgroups*2 !+100*rnk*natoms0 maxgroups = maxgroups + 10 * rnk * natoms0 write ( ulog , * ) ' maxgroups     increased to ' , maxgroups if ( allocated ( mapmat )) deallocate ( mapmat ) if ( allocated ( iatmtrm )) deallocate ( iatmtrm ) if ( allocated ( ixyztrm )) deallocate ( ixyztrm ) if ( allocated ( iatomtermindep )) deallocate ( iatomtermindep ) if ( allocated ( ixyztermindep )) deallocate ( ixyztermindep ) if ( allocated ( nterm )) deallocate ( nterm ) if ( allocated ( ntermsindep )) deallocate ( ntermsindep ) endif write ( * , * ) \"map(2)%ngr value is: \" , map ( 2 )% ngr !if ( rnk .eq. 2) then !   if(include_fc(rnk) .eq. 2) then  ! This is what you have to do in order for to get force constant and declare fc_ind as global !      call read_fcs_2(2) !   endif !endif enddo checkloop write ( umap , '(a,i1,a,10(1x,i2),a,i8,a,i5,a)' ) & & '************ rank ' , rnk , ', shell ' , nshells ( rnk ,:), ', groups ' , ngroups ( rnk ) if ( ngroups ( rnk ). gt . 0 ) then write ( umap , '(a,i2,a,99(i5))' ) 'rank=' , rnk , ' indepterms=' , ntermsindep ( 1 : ngroups ( rnk )) write ( umap , '(a,i2,a,99(i5))' ) 'rank=' , rnk , ' all  terms=' , nterm ( 1 : ngroups ( rnk )) write ( ulog , * ) 'Rank, size of allocated array, real size=' , rnk , mx , nterm ( ngroups ( rnk )) allocate ( map ( rnk )% gr ( ngroups ( rnk )), & & map ( rnk )% nt ( ngroups ( rnk )), & & map ( rnk )% ntind ( ngroups ( rnk )) ) map ( rnk )% ngr = ngroups ( rnk ) map ( rnk )% nt (:) = nterm ( 1 : ngroups ( rnk )) map ( rnk )% ntind (:) = ntermsindep ( 1 : ngroups ( rnk )) jnk = sum ( map ( rnk )% ntind (:)) allocate ( map ( rnk )% err ( jnk )) write ( ulog , * ) 'ngroups(rnk)=' , ngroups ( rnk ) do i = 1 , ngroups ( rnk ) write ( ulog , * ) 'i, nterm(i),ntindp(i)=' , i , nterm ( i ), ntermsindep ( i ) allocate ( map ( rnk )% gr ( i )% mat ( nterm ( i ), ntermsindep ( i )), & & map ( rnk )% gr ( i )% iat ( rnk , nterm ( i )), & & map ( rnk )% gr ( i )% ixyz ( rnk , nterm ( i )), & & map ( rnk )% gr ( i )% iatind ( rnk , ntermsindep ( i )) , & & map ( rnk )% gr ( i )% ixyzind ( rnk , ntermsindep ( i )) ) enddo write ( ulog , * ) ' allocation of MAP done! ' map ( rnk )% err = 'C' ! copy from temp array into real arrays with actual size do i = 1 , map ( rnk )% ngr !  = ngroups(rnk) map ( rnk )% gr ( i )% mat (:,:) = mapmat ( 1 : nterm ( i ), 1 : ntermsindep ( i ), i ) map ( rnk )% gr ( i )% iat (:,:) = iatmtrm ( 1 : rnk , 1 : nterm ( i ), i ) map ( rnk )% gr ( i )% ixyz (:,:) = ixyztrm ( 1 : rnk , 1 : nterm ( i ), i ) map ( rnk )% gr ( i )% iatind (:,:) = iatomtermindep ( 1 : rnk , 1 : ntermsindep ( i ), i ) map ( rnk )% gr ( i )% ixyzind (:,:) = ixyztermindep ( 1 : rnk , 1 : ntermsindep ( i ), i ) enddo m = 0 do i = 0 , nshells ( rnk , 1 ) m = m + atom0 ( 1 )% shells ( i )% no_of_neighbors enddo write ( ulog , * ) 'atm 1 has ' , m , 'inclusve nghbrs within ' , nshells ( rnk , 1 ), ' shell' inv_constraints = inv_constraints + natoms0 * 12 * m write ( ulog , * ) ' rank=' , rnk , ' groups=' , ngroups ( rnk ) write ( ulog , '(a,99(i4))' ) ' nterm=' , nterm ( 1 : ngroups ( rnk )) write ( ulog , * ) ' Cumulative invce_cnstrnts for this shell ' , inv_constraints endif deallocate ( iatmtrm , ixyztrm , mapmat , & & iatomtermzero , ixyztermzero , iatomtermindep , ixyztermindep ) write ( ulog , * ) 'iattrm,ixyztrm,mapmat, iattrm0,ixyztrm0,iattrmindp,ixyztrmindp deallocated' else map ( rnk )% ngr = 0 ! So with this it goes to map(rnk)%ngr in this line and assign it to zero write ( ulog , * ) 'Allocating map(rank=' , rnk , ')' allocate ( map ( rnk )% nt ( 1 ), map ( rnk )% ntind ( 1 ) ) map ( rnk )% nt ( 1 ) = 0 map ( rnk )% ntind ( 1 ) = 0 endif enddo rankloop write ( * , * ) 'SETUP_MAPS: Exited the main rank loop , and going to write by calling ustring' do rnk = 1 , 4 if ( include_fc ( rnk ) . ne . 0 ) then if ( ngroups ( rnk ). gt . 0 ) then n = 7 + 4 * rnk !   do i=1,min(5000,nterm(maxgroups))   ! for now write out at most 5000 terms do j = 1 , map ( rnk )% ngr write ( umap , '(a,2i4)' ) ' ============== RANK, GROUP ===============' , rnk , j write ( umap , '(a,i4)' ) ' ---- # OF INDEPENDENT TERMS ------ ' , map ( rnk )% ntind ( j ) do i = 1 , map ( rnk )% ntind ( j ) m = 0 lineout = ' ' !           write(ulog,*) 'iat=',map(rnk)%gr(j)%iatind(1:rnk,i) !           write(ulog,*) 'ixy=',map(rnk)%gr(j)%ixyzind(1:rnk,i) call ustring ( m , lineout , rnk , map ( rnk )% gr ( j )% iatind (:, i ), map ( rnk )% gr ( j )% ixyzind (:, i )) write ( umap , '(4x,a)' ) lineout ( 1 : m ) enddo write ( umap , '(a,i4)' ) ' ---- # OF ALL TERMS, MAT   ------- ' , map ( rnk )% nt ( j ) ntindp = map ( rnk )% ntind ( j ) do i = 1 , map ( rnk )% nt ( j ) m = 0 lineout = ' ' !           write(ulog,*) 'iat=',map(rnk)%gr(j)%iat(1:rnk,i) !           write(ulog,*) 'ixy=',map(rnk)%gr(j)%ixyz(1:rnk,i) call ustring ( m , lineout , rnk , map ( rnk )% gr ( j )% iat (:, i ), map ( rnk )% gr ( j )% ixyz (:, i )) write ( umap , '(4x,a,90f7.3)' ) lineout ( 1 : 25 ), map ( rnk )% gr ( j )% mat ( i , 1 : ntindp ) enddo enddo endif endif enddo !rankloop ngr = 0 do rnk = 1 , 4 !    if ( include_fc(rnk) .ne. 0 ) then ! get the total number of independent and full terms for each rank !       call get_dim(map(rnk),map(rnk)%ntotind,map(rnk)%ntot) !       write(ulog,*)'SETUP_MAPS: RANK, NDINDEP, NDFULL=',rnk,map(rnk)%ntotind,map(rnk)%ntot !       ngr = ngr + map(rnk)%ntotind !    endif if ( include_fc ( rnk ) . ne . 0 ) then ! get the total number of independent and full terms for each rank call get_dim ( map ( rnk ), map ( rnk )% ntotind , map ( rnk )% ntot ) write ( ulog , * ) 'SETUP_MAPS: RANK, NDINDEP, NDFULL=' , rnk , map ( rnk )% ntotind , map ( rnk )% ntot if ( include_fc ( rnk ) . eq . 1 ) ngr = ngr + map ( rnk )% ntotind endif enddo write ( ulog , * ) 'END OF SETUP_MAPS: NGR=' , ngr write ( * , * ) 'exiting setup_maps routine' if ( include_fc ( 2 ) . eq . 2 ) then ! This is what you have to do in order for to get force constant and declare fc_ind as global call read_fcs_2 ( 2 ) ! You need to put this here endif end subroutine setup_maps !=============================================================================== subroutine include_constraints !! now that we have the 3 matrices atransl,arot,ahuang and aforce, here we decide !! how to put them together to do the SVD !! outputs are amat and bmat and their dimensions:dim_al,dim_ac, which go to SVD use svd_stuff use params use ios implicit none integer n_constr ! real(8), allocatable:: w(:),v(:,:) ! real(8), allocatable:: a11(:,:),b1(:),a12(:,:),a11i(:,:),b2(:) !----------------------------------------------------------------------- ! in this case, invariances are obtained in a rms sense and are not exact. dim_al = force_constraints dim_ac = ngr ! we put the invariance constraints into A write ( ulog , * ) 'INCLUDE_CONSTRAINTS :c(forces),dim(A)=' , force_constraints , dim_al write ( ulog , * ) 'INCLUDE_CONSTRAINTS :c(transl),dim(A)=' , transl_constraints , dim_al write ( ulog , * ) 'INCLUDE_CONSTRAINTS :c(rotatn),dim(A)=' , rot_constraints , dim_al write ( ulog , * ) 'INCLUDE_CONSTRAINTS :c(huang ),dim(A)=' , huang_constraints , dim_al write ( * , * ) \"The dimension of the AMATRIX, dima_al, dim_ac is: \" , dim_al , ngr if ( itrans . ne . 0 ) dim_al = dim_al + transl_constraints if ( irot . ne . 0 ) dim_al = dim_al + rot_constraints if ( ihuang . ne . 0 ) dim_al = dim_al + huang_constraints !if ( include_fc(2) .ne. 2) then allocate ( amat ( dim_al , dim_ac ), bmat ( dim_al )) !endif !if (include_fc(2) .eq. 2) then !   allocate(amat(dim_al,map(2)%ngr:dim_ac),bmat(map(2)%ngr:dim_al)) !endif amat = 0 d0 ; bmat = 0 d0 write ( ulog , * ) ' size(a) nlines,ncolumn=(dim(a1d))=' , dim_al , dim_ac n_constr = 1 ! BEWARE these change if some of the FCS are read in and not fitted, bmat has to change if ( itrans . ne . 0 ) then !  if (include_fc(2) .ne. 2) then !write(*,*) \"Size for AMAT is: n_constr, n_constr-1+transl_constraints, ngr \", n_constr, n_constr-1+transl_constraints, ngr amat ( n_constr : n_constr - 1 + transl_constraints , 1 : ngr ) = & & atransl ( 1 : transl_constraints , 1 : ngr ) bmat ( n_constr : n_constr - 1 + transl_constraints ) = 0 d0 n_constr = n_constr + transl_constraints ! endif !if (include_fc(2) .eq. 2) then !write(*,*) \"Size for AMAT is: n_constr, n_constr-1+transl_constraints, ngr \", n_constr, n_constr-1+transl_constraints, ngr !  amat(n_constr:n_constr-1+transl_constraints,map(2)%ngr:ngr) =  & !&                    atransl(1:transl_constraints,map(2)%ngr:ngr) !     bmat(map(2)%ngr:map(2)%ngr-1+transl_constraints)       = 0d0 !    n_constr = n_constr + transl_constraints !endif endif if ( irot . ne . 0 ) then !  if ( include_fc(2) .ne. 2) then amat ( n_constr : n_constr - 1 + rot_constraints , 1 : ngr ) = & & arot ( 1 : rot_constraints , 1 : ngr ) bmat ( n_constr : n_constr - 1 + rot_constraints ) = brot ( 1 : rot_constraints ) n_constr = n_constr + rot_constraints ! endif !if ( include_fc(2) .eq. 2) then !    amat(n_constr:n_constr-1+   rot_constraints,map(2)%ngr:ngr) =  & ! &                          arot(1:rot_constraints,map(2)%ngr:ngr) !    bmat(map(2)%ngr:map(2)%ngr-1+rot_constraints) = brot(map(2)%ngr:map(2)%ngr+rot_constraints) !   n_constr = n_constr + rot_constraints !  endif endif if ( ihuang . ne . 0 ) then !   if ( include_fc(2) .ne. 2) then amat ( n_constr : n_constr - 1 + huang_constraints , 1 : ngr ) = & & ahuang ( 1 : huang_constraints , 1 : ngr ) bmat ( n_constr : n_constr - 1 + huang_constraints ) = 0 d0 n_constr = n_constr + huang_constraints !  endif ! if ( include_fc(2) .eq. 2) then !      amat(n_constr:n_constr-1+ huang_constraints,map(2)%ngr:ngr) =  & ! &                          ahuang(1:huang_constraints,map(2)%ngr:ngr) !      bmat(map(2)%ngr:map(2)%ngr-1+huang_constraints)        = 0d0 !      n_constr = n_constr + huang_constraints !      endif endif !   if (include_fc(2) .ne. 2) then amat ( n_constr : n_constr - 1 + force_constraints , 1 : ngr ) = & & aforce ( 1 : force_constraints , 1 : ngr ) bmat ( n_constr : n_constr - 1 + force_constraints ) = bforce ( 1 : force_constraints ) ! endif !  write(*,*) \"Value for force_constraints is: \", force_constraints ! if (include_fc(2) .eq. 2) then !    amat(n_constr:n_constr-1+force_constraints,map(2)%ngr:ngr) =  & !&                  aforce(1:force_constraints,map(2)%ngr:ngr) !  bmat(map(2)%ngr:force_constraints) = bforce(map(2)%ngr:force_constraints) ! endif deallocate ( aforce , bforce ) write ( ulog , * ) ' aforce,bforce written into amat,bmat, and deallocated' end subroutine include_constraints !=============================================================================== subroutine homogeneous_constraints_overlap ( n_constr ) ! now that we have the 3 matrices atransl,arot,ahuang, ! we put them together to do the SVD ! outputs are amat and bmat and their dimensions:dim_al,dim_ac, which go to SVD use svd_stuff use params use ios implicit none integer i , j , n_constr !----------------------------------------------------------------------- ! in this case, invariances are obtained in a rms sense and are not exact. dim_hom = 0 dim_ac = ngr ! we put the invariance constraints into A if ( itrans . ne . 0 ) dim_hom = dim_hom + transl_constraints if ( irot . ne . 0 ) dim_hom = dim_hom + rot_constraints if ( ihuang . ne . 0 ) dim_hom = dim_hom + huang_constraints allocate ( ahom ( dim_hom , dim_ac )) ahom = 0 d0 write ( ulog , * ) ' size(ahom) nlines,ncolumn=(dim(a1d))=' , dim_hom , dim_ac n_constr = 1 if ( itrans . ne . 0 ) then ahom ( n_constr : n_constr - 1 + transl_constraints , 1 : ngr ) = & & atransl ( 1 : transl_constraints , 1 : ngr ) n_constr = n_constr + transl_constraints endif if ( irot . ne . 0 ) then ahom ( n_constr : n_constr - 1 + rot_constraints , 1 : ngr ) = & & arot ( 1 : rot_constraints , 1 : ngr ) n_constr = n_constr + rot_constraints endif if ( ihuang . ne . 0 ) then ahom ( n_constr : n_constr - 1 + huang_constraints , 1 : ngr ) = & & ahuang ( 1 : huang_constraints , 1 : ngr ) n_constr = n_constr + huang_constraints endif n_constr = n_constr - 1 write ( ulog , * ) ' ahom is setup with ' , n_constr , ' lines' if ( dim_hom . ne . n_constr ) then write ( ulog , * ) ' dim_hom, n_constr are not equal! ' , dim_hom , n_constr stop ! The program goes upto here and stops. This line is endif ! now form the overlap matrix from the constraints allocate ( overl ( n_constr , n_constr )) do i = 1 , n_constr do j = 1 , n_constr overl ( i , j ) = dot_product ( ahom ( i ,:), ahom ( j ,:)) enddo enddo end subroutine homogeneous_constraints_overlap ! ============================================ function voigt ( i , j ) integer i , j , voigt if ( i . eq . j ) then voigt = i else voigt = 9 - i - j endif end function voigt ! ============================================ subroutine estimate_inv_constraints use atoms_force_constants use ios use geometry use params use svd_stuff implicit none integer i , m , rnk do rnk = 1 , 4 ! count the neighbors within a shell to get an estimate of invariance constraints m = 0 do i = 0 , nshells ( rnk , 1 ) m = m + atom0 ( 1 )% shells ( i )% no_of_neighbors enddo write ( ulog , * ) 'atm 1 has ' , m , 'inclusve nghbrs within ' , nshells ( rnk , 1 ), ' shell' inv_constraints = inv_constraints + natoms0 * 6 * m write ( ulog , * ) ' Cumulative invce_cnstrnts for this shell ' , inv_constraints enddo end subroutine estimate_inv_constraints ! ============================================ subroutine get_dim ( mapd , ndimindep , ndimfull ) !! calculate the number of in/dependent fcs for all groups to fillup map%ntot and %ntotind use svd_stuff implicit none integer g , ndimindep , ndimfull type ( fulldmatrix ) mapd ndimindep = 0 ; ndimfull = 0 do g = 1 , mapd % ngr ndimindep = ndimindep + mapd % ntind ( g ) ndimfull = ndimfull + mapd % nt ( g ) enddo end subroutine get_dim ! ============================================ subroutine check_zero_column ( line , col , afrc ) !! check if there is any column that is zero (the corresponding FC can not be extracted) use ios use params use svd_stuff implicit none integer line , col , i , j , noforc , nosym , rnk , dum real ( 8 ) afrc ( line , col ) write ( ulog , * ) '==== CHECK_ZERO_COLUMN: lines and columns are:' , line , col main : do i = 1 , col ! separate the contribution of symmetries from the force-displacements nosym = 0 col_loop : do j = 1 , line - force_constraints write ( * , * ) 'j=' , j , line - force_constraints if ( abs ( afrc ( j , i )) . gt . 1 d - 8 ) then nosym = 1 + nosym exit col_loop endif enddo col_loop ! now the contribution of force-displacements noforc = 0 col_loop2 : do j = 1 + line - force_constraints , line if ( abs ( afrc ( j , i )) . gt . 1 d - 8 ) then noforc = 1 + noforc exit col_loop2 endif enddo col_loop2 !   if (nosym .eq. 0) then  ! column i was all = zero in the symmetry constraints !      write(6,*)' The FC #',i,' is not involved in the symmetry constraints' !      write(ulog,*)' The FC #',i,' is not involved in the symmetry constraints' !   endif if ( noforc . eq . 0 ) then ! column i was all = zero in the symmetry constraints write ( 6 , * ) ' The FC #' , i , ' is not involved in the force-displacements data' write ( 6 , * ) ' Thus it might only be fixed from the enforced symmetry constraints' write ( ulog , * ) ' The FC #' , i , ' is not involved in the force-displacements data' write ( ulog , * ) ' Thus it might only be fixed from the enforced symmetry constraints' endif if (( noforc . eq . 0 ) . and . ( nosym . eq . 0 )) then ! column i was all = zero in the symmetry constraints call warn ( 6 ) write ( 6 , * ) ' The column no. ' , i , ' of Amatrix is 0, the corresponding ' // & & ' FC will not be evaluated correctly because it does not appear in' // & & ' any of the constraints or force-displacement data ' // & & ' perhaps a larger supercell or one of different symmetry is needed' ! for a given col number,i ,get corresponding rank and  ntindp number=dum call find_t ( i , rnk , dum ) if ( include_fc ( rnk ). ne . 1 ) then write ( ulog , * ) 'ARE YOU SURE THIS RANK WAS INCLUDED?! col,rnk,gr=' , i , rnk , dum endif map ( rnk )% err ( dum ) = '*' write ( ulog , * ) ' WARNINIG: column no. ' , i , ' of Amatrix is 0, the corresponding ' // & & ' FC will not be evaluated correctly because it does not appear in' // & & ' any of the constraints or force-displacement data ' // & & ' perhaps a larger supercell or one of different symmetry is needed' , & & ' rank and group no. are ' , rnk , dum endif enddo main write ( ulog , * ) ' ============  END OF CHECK_ZERO_COLUMN ==============' end subroutine check_zero_column !============================================================================= subroutine find_t ( t , rnk , nti ) !! for a given t in {1,...,ngr} find its corresponding rank and ntindp number nti use svd_stuff use ios ! for the ulog file implicit none integer , intent ( in ) :: t integer , intent ( out ) :: rnk , nti integer i , m ( 4 ), gr m = 0 do i = 1 , 4 do gr = 1 , map ( i )% ngr m ( i ) = m ( i ) + map ( i )% ntind ( gr ) enddo enddo write ( ulog , * ) 'FIND_T: ntindep(rnk)=' , m if ( t . ge . 1 . and . t . le . m ( 1 ) ) then ! because by default nterms(1)=1 rnk = 1 nti = t elseif ( t . gt . m ( 1 ) . and . t . le . m ( 1 ) + m ( 2 ) ) then rnk = 2 nti = t - m ( 1 ) elseif ( t . gt . m ( 1 ) + m ( 2 ) . and . t . le . m ( 1 ) + m ( 2 ) + m ( 3 ) ) then rnk = 3 nti = t - m ( 1 ) - m ( 2 ) elseif ( t . gt . m ( 1 ) + m ( 2 ) + m ( 3 ) . and . t . le . m ( 1 ) + m ( 2 ) + m ( 3 ) + m ( 4 ) ) then rnk = 4 nti = t - m ( 1 ) - m ( 2 ) - m ( 3 ) else print * , 'FIND_T: error: t=' , t , ' must be less than ' , & & m ( 1 ) + m ( 2 ) + m ( 3 ) + m ( 4 ) write ( ulog , * ) 'FIND_T: error: t=' , t , ' must be less than ' , & & m ( 1 ) + m ( 2 ) + m ( 3 ) + m ( 4 ) stop endif ! if (t.ge.1 .and. t.le.map(1)%ngr ) then   ! because by default nterms(1)=1 !    rnk=1 !    gr = t ! elseif (t.gt.map(1)%ngr .and. t.le.map(1)%ngr+map(2)%ngr ) then !    rnk=2 !    gr = t-map(1)%ngr ! elseif (t.gt.map(1)%ngr+map(2)%ngr .and. t.le.map(1)%ngr+map(2)%ngr+map(3)%ngr ) then !    rnk=3 !    gr = t-map(1)%ngr-map(2)%ngr ! elseif (t.gt.map(1)%ngr+map(2)%ngr+map(3)%ngr .and. t.le.  & ! &            map(1)%ngr+map(2)%ngr+map(3)%ngr+map(4)%ngr ) then !    rnk=4 !    gr = t-map(1)%ngr-map(2)%ngr-map(3)%ngr ! else !    print*,'FIND_T: error: t=',t,' must be less than ',  & !    &    map(1)%ngr+map(2)%ngr+map(3)%ngr+map(4)%ngr !    write(ulog,*)'FIND_T: error: t=',t,' must be less than ',  & !    &    map(1)%ngr+map(2)%ngr+map(3)%ngr+map(4)%ngr !    stop ! endif end subroutine find_t !============================================================ subroutine compare2previous_lines ( m , n , a1d , a , counter , new ) !use atoms_force_constants use geometry use params use ios implicit none integer j , t , counter , m , n , j0 , i logical new real ( 8 ) junk , zero real ( 8 ), dimension ( n ) :: a1d , b real ( 8 ), dimension ( m , n ) :: a zero = 0 d0 new = . true . j0 = 0 checkloop : do t = 1 , counter ! check to see if they are multiples of each other !   write(ulog,*)' comparing with line ',t,' in ared matrix' do j = 1 , n ! = no of columns in ared; it's really ngr if ( a1d ( j ) . myeqz . zero ) cycle j0 = j ! it is the first nonzero index !    write(ulog,*)' found j0=',j0 exit enddo if ( j . gt . n . and . verbose ) then write ( ulog , * ) ' this line of ared1d is all=0' write ( ulog , 4 )( a1d ( i ), i = 1 , n ) !            stop endif junk = a ( t , j0 ) / a1d ( j0 ) b = a1d * junk ! this is to avoid repeating amat and -amat if ( a ( t ,:) . myeqz . b (:) ) then new = . false . exit checkloop endif enddo checkloop if ( verbose ) then if ( new ) then write ( ulog , 5 ) 'NEW ' , counter + 1 , a1d else write ( ulog , 5 ) 'COMPARE2PREVIOUS: LINE EXISTED ' , counter + 1 , a1d endif endif 4 format ( 99 ( 1 x , g11 . 4 )) 5 format ( a , i5 , 99 ( 1 x , f7 . 3 )) end subroutine compare2previous_lines !====================================================================================== subroutine set_huang_inv_constraints use params use atoms_force_constants use svd_stuff use ios ! use geometry use force_constants_module implicit none integer i , j , al , be , ga , de , t , ti , mterm , cnt2 , g , rnk , voigt , vab , vcd , counter , ired , res !,nterm real ( 8 ) huang , rr ( 3 ) real ( 8 ), allocatable :: ared1d (:), zero (:) if ( ihuang . ne . 0 ) then rnk = 2 ; huang_constraints = 15 !  res = sum(map(1)%ntind(:)) if ( map ( 1 )% ngr . gt . 0 ) then res = sum ( map ( 1 )% ntind (:)) else res = 0 endif write ( ulog , * ) ' SETTING HUANG INVARIANCE CONSTRAINTS *****************' dim_al = huang_constraints !   ngr = (sum(ngroups(:))) allocate ( ahuang ( dim_al , ngr ), ared1d ( ngr ), zero ( ngr ) ) counter = 0 ; zero = 0 d0 ; ahuang = 0 d0 ared1d = zero do al = 1 , 3 do be = al , 3 do ga = 1 , 3 do de = ga , 3 vab = voigt ( al , be ) vcd = voigt ( ga , de ) if ( vab . le . vcd ) cycle huang = 0 mterm = 0 atomloop : do i = 1 , natoms0 cnt2 = 0 ! cnt2 counts the previous independent terms do g = 1 , map ( 2 )% ngr if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( 2 )% nt ( g ) if ( map ( 2 )% gr ( g )% iat ( 1 , t ). ne . i ) cycle if ( map ( 2 )% gr ( g )% ixyz ( 1 , t ). eq . al . and . map ( 2 )% gr ( g )% ixyz ( 2 , t ). eq . be ) then mterm = mterm + 1 j = map ( 2 )% gr ( g )% iat ( 2 , t ) !           tauj=iatomcell0(j) !           nj=iatomcell(:,j) rr = atompos (:, j ) - atompos (:, i ) do ti = 1 , map ( 2 )% ntind ( g ) ired = res + cnt2 + ti ! the corresponding index of i in ared ared1d ( ired ) = ared1d ( ired ) + rr ( ga ) * rr ( de ) * map ( 2 )% gr ( g )% mat ( t , ti ) !               huang = huang + rr(ga)*rr(de)*map(2)%gr(g)%mat(t,ti)*fcs(res+cnt2+ti) enddo elseif ( map ( 2 )% gr ( g )% ixyz ( 1 , t ). eq . ga . and . map ( 2 )% gr ( g )% ixyz ( 2 , t ). eq . de ) then mterm = mterm + 1 j = map ( 2 )% gr ( g )% iat ( 2 , t ) rr = atompos (:, j ) - atompos (:, i ) do ti = 1 , map ( 2 )% ntind ( g ) ired = res + cnt2 + ti ! the corresponding index of i in ared ared1d ( ired ) = ared1d ( ired ) - rr ( al ) * rr ( be ) * map ( 2 )% gr ( g )% mat ( t , ti ) enddo endif enddo enddo enddo atomloop counter = counter + 1 if ( verbose ) write ( ulog , 6 ) 'counter,mterm,vab,vcd=' , counter , mterm , al , be , ga , de , vab , vcd if ( counter . eq . dim_al + 1 ) then write ( ulog , * ) ' DIM_AL TOO SMALL, huang_inv=15, counter= ' , counter stop endif ahuang ( counter ,:) = ared1d (:) !     write(umatrx,7)(ahuang(counter,dum),dum=1,ngr) enddo enddo enddo enddo deallocate ( ared1d , zero ) endif 6 format ( a , 8 ( 1 x , i4 ), 9 ( 2 x , f7 . 3 )) !7 format(66(1x,g9.2)) end subroutine set_huang_inv_constraints !=============================================================================== subroutine check_huang ! this subroutine checks Huang invariance relations: ! sum_r ( phi_0,r&#94;al,be r&#94;ga r&#94;de -  phi_0,r&#94;ga,de r&#94;al r&#94;be ) = 0 use params use atoms_force_constants use svd_stuff use ios ! use geometry use force_constants_module implicit none integer i , j , al , be , ga , de , t , ti , cnt2 , mterm , rnk , voigt , g , vab , vcd , res real ( 8 ) huang , rr ( 3 ) write ( ulog , * ) 'CHECKING HUANG INVARIANCE RELATIONS       ###############################' res = sum ( map ( 1 )% ntind (:)) write ( ulog , * ) ' # of indep terms of rank 1 = res=' , res rnk = 2 !----------------------------------------------------- write ( ulog , * ) ' i0 , al , be , ga , de ,mterm, I_huang ' do al = 1 , 3 do be = al , 3 do ga = 1 , 3 do de = ga , 3 vab = voigt ( al , be ) vcd = voigt ( ga , de ) if ( vab . le . vcd ) cycle huang = 0 mterm = 0 do i = 1 , natoms0 cnt2 = 0 do g = 1 , map ( 2 )% ngr if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( 2 )% nt ( g ) if ( map ( 2 )% gr ( g )% iat ( 1 , t ). ne . i . or . map ( 2 )% gr ( g )% ixyz ( 1 , t ). ne . al & & . or . map ( 2 )% gr ( g )% ixyz ( 2 , t ). ne . be ) cycle mterm = mterm + 1 j = map ( 2 )% gr ( g )% iat ( 2 , t ) !         tauj=iatomcell0(j) !         nj=iatomcell(:,j) rr = atompos (:, j ) - atompos (:, i ) do ti = 1 , map ( 2 )% ntind ( g ) huang = huang + rr ( ga ) * rr ( de ) * map ( 2 )% gr ( g )% mat ( t , ti ) * fcs ( res + cnt2 + ti ) enddo enddo enddo cnt2 = 0 do g = 1 , map ( 2 )% ngr if ( g . gt . 1 ) cnt2 = cnt2 + map ( rnk )% ntind ( g - 1 ) do t = 1 , map ( 2 )% nt ( g ) if ( map ( 2 )% gr ( g )% iat ( 1 , t ). ne . i . or . map ( 2 )% gr ( g )% ixyz ( 1 , t ). ne . ga & & . or . map ( 2 )% gr ( g )% ixyz ( 2 , t ). ne . de ) cycle mterm = mterm + 1 j = map ( 2 )% gr ( g )% iat ( 2 , t ) rr = atompos (:, j ) - atompos (:, i ) do ti = 1 , map ( 2 )% ntind ( g ) huang = huang - rr ( al ) * rr ( be ) * map ( 2 )% gr ( g )% mat ( t , ti ) * fcs ( res + cnt2 + ti ) enddo enddo enddo enddo write ( ulog , 5 ) i , al , be , ga , de , vab , vcd , mterm , huang enddo enddo enddo enddo write ( ulog , * ) 'HUANG INVARIANCE RELATIONS CHECKED        ###############################' 5 format ( 8 ( 1 x , i4 ), 9 ( 1 x , g13 . 6 )) end subroutine check_huang ! ============================================ subroutine truncate ( n , ws , n_kept ) !! find a gap in the ws and drop the small ws values implicit none integer n , n_kept , i , i1 real ( 8 ) ws ( n ), logws ( n ), gap ( n - 1 ), maxgap1 , wmax wmax = maxval ( ws ) ws = ws / wmax logws = log ( ws ) / log ( 1 0. ) ! decimal log of ws if ( logws ( 1 ) . ne . 0 ) then write ( * , * ) 'TRUNCATE: ws(1),logws(1)=' , ws ( 1 ), logws ( 1 ) stop endif write ( * , * ) 'TRUNCATE: dimension of ws is n=' , n ! calculate the level separations do i = 1 , n - 1 gap ( i ) = logws ( i ) - logws ( i + 1 ) write ( * , 5 ) 'TRUNCATE: i, ws,logws, gap(i)' , i , ws ( i ), logws ( i ), gap ( i ) enddo 5 format ( a , i4 , 9 ( 1 x , g11 . 4 )) do i = 1 , n if ( logws ( i ). gt . - 5 ) cycle exit enddo n_kept = i ! any logws above -5, i.e. ws>10&#94;-5 is kept maxgap1 = maxval ( gap ( i + 1 : n - 1 )) i1 = maxloc ( gap ( i + 1 : n - 1 ), n - i - 1 ) n_kept = i1 ws = ws * wmax ! if(i1.lt.n_kept) then ! the largest gap is before n_kept , ie larger than 10&#94;-6 ! use the second largest gap !   i2=maxloc(gap(i1+1:n-1)) !else ! the largest gap comes after, and so that's where we will truncate !   n_kept=i1 !   return ! endif end subroutine truncate","tags":"","loc":"sourcefile/others3_nshells.f90.html"},{"title":"fc234.f90 – Example Project","text":"This file depends on sourcefile~~fc234.f90~~EfferentGraph sourcefile~fc234.f90 fc234.f90 sourcefile~modules9.f90 modules9.f90 sourcefile~fc234.f90->sourcefile~modules9.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs FC234 Subroutines remove_zeros eliminate_fcs invsort Source Code fc234.f90 Source Code program FC234 ! ! todo: supress redundant parameters lines maxshell. The latter ! should be based on the number of requested shells by fc2 ! Same for error tolerances ! add option of reading existing fc files and fitting the remaining ones. ! ! if a line of amat is zero, then check whether the corresponding line ! in bmat is zero or not. if it is remove the line from amat, else ! print in log file the inconsistency and remove it anyways. ! CHECK THE iatomxyz PART OF FC4, THERE ARE SOME large NUMBERS IN IT!! ! also compare the si data with other papers (quteish...) ! allow some of the fcs of a given rank to be fixed and read from the ! file if include_fc=2, and the rest to be fitted and appended to the ! file for further use. ! !------------------------------------------------ ! program to extract force constants from ab initio force-displacement data ! eventually with (linear) constraints of symmetry ! INPUT FILES : param.in, POSCAR, OUTCAR ! in params.inp file user specifies the specifications of the primitive cell ! what potential parameters will be kept how many shells are included, ! whether or not transl and rot inv constraints are imposed ! the tolerance for equating two coordinates ! specifications(type mass name) of the atoms in prim cell and their red coord ! In POSCAR file the same specifications but for the super cell are read. ! Finally OUTCAR constains the force-displacements data ! OUTPUT FILES: log.dat contains log of the runs and intermediate outputs ! fcs.dat : contains the obtained force constants ! amatrx.dat : is the matrix A and column b to be solved by SVD ! svd-results.dat: contains the output of SVD algorithm, errors, array w ! maps.dat: contains the map taking the oned array of terms to atom i,xyz ! by K. Esfarjani December 2006 !------------------------------------------------ !* need to treat cases where equilibrium positions are not known but are ! calculated as outputs of this program. For this purpose, we need to be ! able to adjust the FCs to equilibrium points as they are calculated at the ! points defined in POSCAR : First need to solve F(u)=0 to get u and then use: ! phi3 = phi3 + u0 phi4; phi2 = phi2+ u0 phi3 + u0 u0 phi4/2; ! phi1 = phi1 + u0 phi2 + u0 u0 phi3/2 + u0 u0 u0 phi4/6; phi4 unchanged. ! and also apply the iterative Newton's algorithm to find the eq. positions !* must also give as output the equilibrium volume by calculating the stress. ! check consistency of POSCAR and OUTCAR: differences must be less than 10% ! show which FCs are included in a given group ! ! this new version separates the invariance constraints from the force-displacement ! data and enforces the former \"exactly\" using a separate svd algorithm. ! we need to first subtract from the forces the long-range Coulombic part in order ! to insure the remaining part is short-ranged. ! needs to read params.born to get dielectric constant and Born charges; the long-range ! part of the FCs is (Zi.q)(Zj.q)/eps q&#94;2 corresponding to force: Fi=- sum_q (Zi.q)(Zj.q)/eps q&#94;2 e&#94;iq.Rij u_j ! need to calculate this force, subtract it from the DFT input force, and fit the remainder. ! use lattice use params use ios use atoms_force_constants use force_constants_module use svd_stuff use geometry implicit none ! type(vector) v integer i , j , n3 , rank , iunit , tra , rot , hua , eliminate_fc , fcalloc !g, t character xt * 1 , fn * 11 , poscar * 7 , outcar * 7 logical ex real ( 8 ), allocatable :: newamat (:,:), newbmat (:), afrc (:,:), bfrc (:), aux1 (:,:) integer , allocatable :: frc_constr (:), auxi (:,:) real ( 8 ) error , ermax , sd ( 4 ), sig !,a1,a2,a3 real tim character now * 10 , today * 8 , zone * 5 call date_and_time ( date = today , time = now , zone = zone ) call cpu_time ( tim ) open ( ulog , file = 'log.dat' , status = 'unknown' ) open ( utimes , file = 'times.dat' , status = 'unknown' ) open ( umap , file = 'maps.dat' , status = 'unknown' ) open ( umatrx , file = 'amatrx.dat' , status = 'unknown' ) open ( ucor , file = 'corresp.dat' , status = 'unknown' ) open ( ufco , file = 'lat_fc.dat' , status = 'unknown' ) open ( ufit1 , file = 'fc1_fit.dat' , status = 'unknown' ) open ( ufit2 , file = 'fc2_fit.dat' , status = 'unknown' ) open ( ufit3 , file = 'fc3_fit.dat' , status = 'unknown' ) open ( ufit4 , file = 'fc4_fit.dat' , status = 'unknown' ) write ( ulog , '(a30,3x,a10,3x,a12,3x,a)' ) ' Program FC234 was launched at ' , today ( 1 : 4 ) // '/' & & // today ( 5 : 6 ) // '/' // today ( 7 : 8 ), now ( 1 : 2 ) // ':' // now ( 3 : 4 ) // ':' // now ( 5 : 10 ), zone write ( ulog , '(a,f10.4)' ) ' STARTING TIME OF THE PROGRAM                   IS ' , tim write ( utimes , '(a30,3x,a10,3x,a12,3x,a)' ) ' This program was launched at ' , today ( 1 : 4 ) // '/' & & // today ( 5 : 6 ) // '/' // today ( 7 : 8 ), now ( 1 : 2 ) // ':' // now ( 3 : 4 ) // ':' // now ( 5 : 10 ), zone write ( utimes , '(a,f10.4)' ) ' At the start of the Program FC234 the  TIME IS ' , tim call set_maxterms ! no need to read them anymore, they are incremented if necessary ! read from params.inp the atoms in prim cell in reduced units, assign their ! mass, type, tau; also read specs of the prim cell, and max no of neighborshells call read_input ! outputs: lattparams,primlat,nshells,include_fc,itrans,irot,natoms0,mas,atname, ! atompos0 (reduced coords within the primitive cell) maxshells = maxneighbors call write_out ( ulog , 'latticeparameters' , latticeparameters ) call write_out ( ulog , 'primitive lattice' , 3 , 3 , primitivelattice ) write ( ulog , * ) 'atompos0_d' do i = 1 , natoms0 !    call write_out(ulog,'atom0 ',3,atompos0(:,i)) write ( ulog , 8 ) i , atompos0 (:, i ) enddo call write_out ( ulog , '# of different atom types ' , natom_type ) call write_out ( ulog , '# of each type in primcel ' , natom ) call write_out ( ulog , '# mass of different types ' , mas ) ! get from lattparam and atompos0 previously read the cartesian coordinates ! of the atoms in the primitive cell(+neighbors) stored in atompos; ! also find symmetry of the crystal and its matrices and generates neighbors call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' READ_INPUT CALLED, TIME                       IS ' , tim ! This does not work: fcinit must be called once or latparam(4:6) will be overwritten maxatoms = 20 ; imaxat = 1 do while ( imaxat . ne . 0 ) maxatoms = maxatoms + 300 write ( 6 , * ) ' maxatoms=' , maxatoms write ( ulog , * ) ' maxatoms=' , maxatoms if ( allocated ( iatomcell0 )) deallocate ( iatomcell0 ) if ( allocated ( iatomcell )) deallocate ( iatomcell ) if ( allocated ( atompos )) deallocate ( atompos ) allocate ( atompos ( 3 , maxatoms ), iatomcell ( 3 , maxatoms ), iatomcell0 ( maxatoms )) ! inputs: natoms0,latticeparameters,primitivelattice,atom_type,atompos0 ! outputs: r0i, atompos (cart coord of atoms and natoms neighbor shells), ! iatomcell, iatomcell0, iatomneighbor, iatomop, ... call force_constants_init ( latticeparameters , primitivelattice , natoms0 , & & atom_type , atompos0 ) !(n,natom_type,atompos0) enddo ! reallocate atompos,iatomcell and iatomcell0 allocate ( auxi ( 3 , natoms ), aux1 ( 3 , natoms )) auxi ( 1 : 3 , 1 : natoms ) = iatomcell ( 1 : 3 , 1 : natoms ) aux1 ( 1 : 3 , 1 : natoms ) = atompos ( 1 : 3 , 1 : natoms ) deallocate ( atompos , iatomcell ) allocate ( atompos ( 3 , natoms ), iatomcell ( 3 , natoms )) atompos = aux1 ; iatomcell = auxi auxi ( 1 , 1 : natoms ) = iatomcell0 ( 1 : natoms ) deallocate ( iatomcell0 ) allocate ( iatomcell0 ( natoms )) iatomcell0 = auxi ( 1 ,:) maxatoms = natoms deallocate ( aux1 , auxi ) call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' FC_INIT CALLED, TIME                          IS ' , tim write ( utimes , * ) ' FC_init called, atmpos, neighbs, iatmcell calculated' ! r01,r02,r03 translation vectors of the primitive lattice were just defined call write_out ( ulog , 'r01=' , r01 ) call write_out ( ulog , 'r02=' , r02 ) call write_out ( ulog , 'r03=' , r03 ) call write_out ( ulog , ' number of neighboring atoms, natoms' , natoms ) write ( ulog , * ) ' i, atompos(i), tau(i), n(i) ' do i = 1 , natoms write ( ulog , 8 ) i , atompos (:, i ), iatomcell0 ( i ), iatomcell (:, i ) enddo 5 format ( 9 ( 1 x , f11 . 6 )) 8 format ( i4 , 3 ( 2 x , f10 . 5 ), 3 x , i2 , 2 x , '(' , 3 ( 1 x , i2 ), 1 x , ')' , 2 x , i4 ) 9 format ( i5 , 9 ( 1 x , f9 . 4 )) call make_reciprocal_lattice ( r01 , r02 , r03 , g01 , g02 , g03 ) ! beware of the factor of 2pi in g0 call set_neighbor_list ! inputs: atompos, ! outpus: atom0%equilb_pos,shells%no_of_neighbors , rij, neighbors(:)%tau and n call write_neighbors write ( * , * ) \"The value of map(2)%ngr is: \" , map ( 2 )% ngr ! define the dimensions of the FC arrays, for each rank if include_fc.ne.0 ! collects identical force_constants call setup_maps ! inputs: outputs of force_constants_init: iatomop etc... ! outputs: map structure including for rank, the groups of indep FCs and the full FCs ! maxterms, nshells, ngroups, nterms, inv_constraints, ngr write ( * , * ) \"The value of map(2)%ngr is: \" , map ( 2 )% ngr write ( * , * ) \"The value of map(2)%ntotind is: \" , map ( 2 )% ntotind call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after setup_maps and before write_correspondance IS ' , tim !-------------------------------------------------------------------- ! eventually read FCs from a file if already present do rank = 1 , 4 write ( xt , '(i1)' ) rank fn = 'fc' // xt // '.dat' iunit = ufco + rank if ( include_fc ( rank ) . eq . 2 ) then ! this rank is not to be included fcalloc = 0 write ( * , * ) \"The value of RFCS2 allocation is: \" , fcalloc ! in the fit, read the fcs from a file fn = 'fc' // xt // '_fit.dat' inquire ( file = \"fc2.dat\" , exist = ex ) if ( ex ) then !open(iunit ,file=fn ,status='old') !     call read_harm_fcs(2) else write ( * , * ) 'For this rank there is no FC data file present ' , rank write ( * , * ) 'check your inputs and run the program again' write ( ulog , * ) 'For this rank there is no FC data file present ' , rank write ( ulog , * ) 'check your inputs and run the program again' stop endif elseif ( include_fc ( rank ) . eq . 1 ) then open ( iunit , file = fn , status = 'unknown' ) endif enddo !-------------------------------------------------------------------- ! depending on the constraints, setup the lines of the A and B matrices: call set_translational_inv_constraints write ( ulog , * ) 'Number of translational invce constraints is=' , transl_constraints call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after set_translational_inv_constraints IS ' , tim call set_rotational_inv_constraints write ( ulog , * ) 'Number of rotational invarnce constraints is=' , rot_constraints call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after set_rotational_inv_constraints    IS ' , tim call set_huang_inv_constraints write ( ulog , * ) 'Number of Huang    invariance constraints is=' , huang_constraints call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after set_Huang_inv_constraints         IS ' , tim call write_lat_fc ( map (:)% ntotind , map (:)% ntot ) !ngroups,nterms) !!  call homogeneous_constraints_overlap(n_constr) !! !!! do the SVD of the overlap !! allocate( us(n_constr,ngr),vs(ngr,ngr),ws(ngr) ) !! us = ahom !! call svdcmp(us,n_constr,ngr,n_constr,ngr,ws,vs) ! allocate( us(n_constr,n_constr),vs(n_constr,n_constr),ws(n_constr) ) ! us = overl ! call svdcmp(us,n_constr,n_constr,n_constr,n_constr,ws,vs) ! truncate and keep the highest eigenvalues of ws ! call truncate(ngr,ws,n_kept) ! write(ulog,*)' the largest  ws is=',ws(1) ! write(ulog,*)' the smallest ws kept and its index is=',n_kept,ws(n_kept) ! write(ulog,*)' their ratio is=',ws(n_kept)/ws(1) ! for the kept eigenvalues calculate the correction or the residual FCS ! by projecting the initial solution onto the kernel of the constraint matrix ! here we are constructing the projection matrix which should later multiply X0 ! allocate( project(n_constr,n_constr) ) ! project=0 ! do i=1,n_constr !    project(i,i)=1 ! do j=1,n_constr !    do n3=1,n_kept !+1,n_constr !       project(i,j)=project(i,j)-vs(i,n3)*vs(j,n3) !    enddo ! enddo ! enddo ! we need to multiply the final svd solution vector by project, to remain in the kernel of C !-------------------------------------------------------------------- ! loop over different FP runs with different POSCARi-OUTCARi files ! supercell information enters here. ! this 1st loop is to calculate force_constraints in order to allocate aforce n3 = 0 allocate ( frc_constr ( fdfiles )) force_constraints = 0 do i = 1 , fdfiles write ( xt , '(i1)' ) i poscar = 'POSCAR' // xt outcar = 'OUTCAR' // xt ! read the ideal crystal data (atoms in supercell at equilbrm) from POSCAR call read_crystal ( poscar ) ! inputs: ! outputs: supercell's lattice_parameter,r1i,g1i,boxxyz,om,natom_super_cell, ! atom_sc%equilibrium_pos write ( ulog , * ) 'supercell crystal read' ! make the matrix a_ij=r0i.dot.gj call make_r0g write ( ulog , * ) 'make r0g called' ! read the position-force data for a set of configurations call read_force_position_data ( outcar , frc_constr ( i )) write ( ulog , * ) 'force - position read: i, frc_constr(i)= ' , i , frc_constr ( i ) ! outputs: nconfigs,displ(=actual positions),force,frc_constr(i) force_constraints = force_constraints + frc_constr ( i ) enddo write ( ulog , * ) 'Now allocating aforce of dims=' , force_constraints , ngr allocate ( aforce ( force_constraints , ngr ), bforce ( force_constraints ) ) !-------------------------------------------------------------------- ! now that force_constraints is known, read and setup the aforce matrix structures : do i = 1 , fdfiles write ( xt , '(i1)' ) i poscar = 'POSCAR' // xt outcar = 'OUTCAR' // xt ! read the ideal crystal data (atoms in supercell at equilbrm) from POSCAR call read_crystal ( poscar ) ! inputs: ! outputs: supercell's lattice_parameter,r1i,g1i,boxxyz,om,natom_super_cell, ! atom_sc%equilibrium_pos write ( ulog , * ) 'supercell crystal read' ! make the matrix a_ij=r0i.dot.gj call make_r0g write ( ulog , * ) 'make r0g called' ! read the position-force data for a set of configurations call read_force_position_data ( outcar , frc_constr ( i )) write ( ulog , * ) 'force - position read for the second time ' ! outputs: nconfigs,displ(=actual positions),force,frc_constr(i) call calculate_and_write_displacements ! inputs: displ, atom_sc%equilibrium_pos (get displ from actual coordinates) ! outputs: displ call identify_atoms_in_supercell ! inputs: atom0%eq_pos and atom_sc%eq_pos (finds the shift overlap atom0 with atom_sc) ! outputs: shift0, atom_sc%cell%n and tau, njmin,njmax call write_correspondance2 call cpu_time ( tim ) write ( utimes , '(a,i3,a,f10.4)' ) ' STRUCTURE ' , i , ' after write_correspondance time IS ' , tim write ( ulog , * ) ' MAIN: total # of independent FCs of all rank, ngr=' , ngr allocate ( afrc ( frc_constr ( i ), ngr ), bfrc ( frc_constr ( i ))) write ( ulog , * ) ' calling set_force_displacement_matrix, for str=' , i call set_force_displacement_matrix ( frc_constr ( i ), afrc , bfrc ) write ( ulog , * ) ' set_force_displacement_matrix called, aforce being filled now' write ( ulog , * ) ' n3,n3+frc_constr(i)=' , n3 , n3 + frc_constr ( i ) aforce ( n3 + 1 : n3 + frc_constr ( i ), 1 : ngr ) = afrc ( 1 : frc_constr ( i ), 1 : ngr ) bforce ( n3 + 1 : n3 + frc_constr ( i ) ) = bfrc ( 1 : frc_constr ( i ) ) n3 = n3 + frc_constr ( i ) deallocate ( afrc , bfrc ) ! writing the coordinates of primitive cells in the supercell ! reference of each prim cell is atom #1 open ( 111 , file = 'struct-supercell-' // xt ) write ( 111 , 5 ) r1 write ( 111 , 5 ) r2 write ( 111 , 5 ) r3 do j = 1 , natom_super_cell if ( atom_sc ( j )% cell % tau . ne . 1 ) cycle write ( 111 , 9 ) j , atom_sc ( j )% cell % n ( 1 ) * r01 + atom_sc ( j )% cell % n ( 2 ) * r02 & & + atom_sc ( j )% cell % n ( 3 ) * r03 , atom_sc ( j )% equilibrium_pos enddo close ( 111 ) enddo structures if ( n3 . ne . force_constraints ) then write ( ulog , * ) 'n3, force_constraints are not equal ' , n3 , force_constraints write ( ulog , * ) 'the program will stop' write ( * , * ) 'n3, force_constraints are not equal ' , n3 , force_constraints write ( * , * ) 'the program will stop' stop endif call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after structure loop                    IS ' , tim !--------------------------- FOR TESTING ----------------------- ! this part only does the svd on forces without including invariance relations !  dim_al = force_constraints !  dim_ac = ngr !  call remove_zeros(dim_al,dim_ac, aforce, bforce, newdim_al) !  allocate(newamat(newdim_al,dim_ac),newbmat(newdim_al)) !  newamat(:,:) = aforce(1:newdim_al,1:dim_ac) !  newbmat(:  ) = bforce(1:newdim_al) !  deallocate(aforce,bforce) !  dim_al = newdim_al ! !! give warnings if any column in aforce is totally zero !  call check_zero_column(dim_al,dim_ac,newamat) ! !  allocate(fcs(dim_ac),sigma(dim_ac)) ! !  call cpu_time(tim) !  write(utimes,'(a,f10.4)')' TIME before SVD  of aforce                   IS   ',tim ! !! do the SVD decomposition ! !  call svd_set(dim_al,dim_ac,newamat,newbmat,fcs,sigma,svdcut,error,ermax,sig,'svd-force.dat') ! !  write(ulog,*)'After svd, || F_dft-F_fit || / || F_dft || =',sig ! !  call cpu_time(tim) !  write(utimes,'(a,f10.4)')' TIME after SVD calculation of aforce         IS ',tim ! !! Add the correction term to the old solution ! ! ! allocate(amat(dim_al,dim_ac),bmat(dim_al),btes(dim_al)) ! amat(1:transl_constraints,1:ngr) = atransl(1:transl_constraints,1:ngr) ! bmat(1:transl_constraints)     = 0d0 ! amat(transl_constraints + 1 : transl_constraints + rot_constraints,1:ngr) =  & ! &                        arot(1:rot_constraints,1:ngr) ! bmat(transl_constraints + 1 : transl_constraints + rot_constraints) = & ! &                        brot(1:rot_constraints) ! ! write all fcs into one array: ! allocate(fcs(dim_ac)) ! i = 0 ! fcs(i+1:i+ngroups(2)) = fcs_2(1:ngroups(2)) ! i = i + ngroups(2) ! fcs(i+1:i+ngroups(3)) = fcs_3(1:ngroups(3)) ! i = i + ngroups(3) ! fcs(i+1:i+ngroups(4)) = fcs_4(1:ngroups(4)) ! write(ulog,*)' ###############  TESTING OF FCS  ############# ' ! do i=1,ngr !    write(ulog,*) i,fcs(i) ! enddo ! btes = matmul(amat,fcs) ! write(ulog,*)' ###############  TESTING OF INVARIANCES  ############# ' ! do i=1,dim_al !    write(ulog,*) i,bmat(i),btes(i) ! enddo ! !--------------------------- FOR TESTING ----------------------- call include_constraints ! inputs: inv_constraints,force_constraints, ! outputs:  dim_al,dim_ac, amat, bmat ! we remove the following because if one starts with reference positons in POSCAR ! which are not equilibrium position, then FC1 are not zero and lines with u=0 ! should still be kept, and not thrown away. ! the following removes lines=0 from amat (where all displacements are zero) call remove_zeros ( dim_al , dim_ac , amat , bmat , newdim_al ) !if ( include_fc(2) .ne. 2) then allocate ( newamat ( newdim_al , dim_ac ), newbmat ( newdim_al )) !endif !if (include_fc(2) .eq. 2) then !  allocate(newamat(newdim_al,map(2)%ngr:dim_ac),newbmat(map(2)%ngr:dim_al)) !   write(*,*) \"The value for newdiv_al, map(3).ntotind+map(4).ntotind is: \", map(3)%ntotind+map(4)%ntotind !   allocate(newamat(newdim_al,map(3)%ntotind+map(4)%ntotind),newbmat(map(2)%ngr:dim_al)) ! what is the dimension here map(2)%ngr:dim_al ! or 1:dim_al-map(2)%ngr !endif newamat (:,:) = amat ( 1 : newdim_al , 1 : dim_ac ) newbmat (: ) = bmat ( 1 : newdim_al ) deallocate ( amat , bmat ) allocate ( amat ( newdim_al , dim_ac ), bmat ( newdim_al )) amat = newamat bmat = newbmat dim_al = newdim_al deallocate ( newamat , newbmat ) ! give warnings if any column in aforce is totally zero call check_zero_column ( dim_al , dim_ac , amat ) tra = 0 ; rot = 0 ; hua = 0 if ( itrans . ne . 0 ) tra = transl_constraints if ( irot . ne . 0 ) rot = rot_constraints if ( ihuang . ne . 0 ) hua = huang_constraints write ( ulog , * ) ' Number of invariance constraints   =' , inv_constraints write ( ulog , * ) ' Size of the homogeneous part of A  =' , tra + rot + hua if ( inv_constraints . ne . tra + rot + hua ) then inv_constraints = tra + rot + hua write ( ulog , * ) ' Setting # of invariance constraints=' , inv_constraints endif write ( ulog , * ) ' Size of the unknown FCs of all rank=' , dim_ac if ( dim_ac . lt . ( tra + rot + hua )) then write ( ulog , * ) ' the # of indept FCs is too small for doing any elimination' eliminate_fc = 0 endif if ( dim_ac . lt . ( tra + rot + hua ) + 1 ) then call warn ( ulog ) write ( ulog , * ) ' the # of constraints is too large and they are not consistent' write ( ulog , * ) ' you need to release some of the constraints or increase the range' call warn ( 6 ) write ( 6 , * ) ' the # of constraints is too large and they are not consistent' write ( 6 , * ) ' you need to release some of the constraints or increase the range' !  stop endif ! we remove the following because if one starts with reference positons in POSCAR ! which are not equilibrium position, then FC1 are not zero and lines with u=0 ! for now do it without reduction, put the full A matrix ! then do the reduction and check validity ! then impose other invariance relations ! then put higher order terms !----------------------- END FOR TESTING ----------------------- allocate ( fcs ( dim_ac ), sigma ( dim_ac )) call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after include_constraints  before SVD   IS   ' , tim ! write the a and b matrices if ( verbose ) then write ( umatrx , * ) ' before call to svd, amat and bmat are:' do i = 1 , dim_al write ( umatrx , 17 )( amat ( i , j ), j = 1 , dim_ac ), bmat ( i ) enddo endif 17 format ( 999 ( 1 x , g9 . 2 )) ! do the SVD decomposition call svd_set ( dim_al , dim_ac , amat , bmat , fcs , sigma , svdcut , error , ermax , sig , 'svd-all.dat' ) write ( ulog , * ) 'After svd, || F_dft-F_fit || / || F_dft || =' , sig call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after SVD calculation                   IS ' , tim call write_independent_fcs ( sd ) call write_output_fc2 call date_and_time ( date = today , time = now , zone = zone ) call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' ENDING TIME OF THE PROGRAM                   IS ' , tim write ( ulog , '(a,f10.4)' ) ' ENDING TIME OF THE PROGRAM                   IS ' , tim ! if(enforce_inv.ne.0) then !    call eliminate_fcs(sig) !    write(ulog,*)'After ELIMINATE_FCS, sigma=',sig ! endif 7 format ( a , 2 ( 2 x , g12 . 5 ), 2 x , 4 ( 1 x , g11 . 4 )) write ( ulog , '(a30,3x,a10,3x,a12,3x,a)' ) ' Program  FC234 ended at ' , today ( 1 : 4 ) // '/' & & // today ( 5 : 6 ) // '/' // today ( 7 : 8 ), now ( 1 : 2 ) // ':' // now ( 3 : 4 ) // ':' // now ( 5 : 10 ), zone write ( utimes , '(a30,3x,a10,3x,a12,3x,a)' ) ' Program FC234 ended at ' , today ( 1 : 4 ) // '/' & & // today ( 5 : 6 ) // '/' // today ( 7 : 8 ), now ( 1 : 2 ) // ':' // now ( 3 : 4 ) // ':' // now ( 5 : 10 ), zone write ( ulog , 7 ) ' Average and largest errors in force=' , error , ermax , sd close ( ulog ) close ( ufit1 ) close ( ufit2 ) close ( ufit3 ) close ( ufit4 ) close ( ufc1 ) close ( ufc2 ) close ( ufc3 ) close ( ufc4 ) close ( ufco ) close ( ucor ) close ( umap ) close ( umatrx ) close ( utimes ) end program FC234 !=========================================================== subroutine remove_zeros ( nl , nc , amatr , bmatr , j ) ! removes lines which are all zero from the amatrix use ios use params use svd_stuff !for itrans,irot,ihuang implicit none integer nl , nc , i , j , nz , tra , rot , hua real ( 8 ) amatr ( nl , nc ), bmatr ( nl ), suml , small real ( 8 ), allocatable :: aa (:,:), bb (:) integer , allocatable :: zz (:) small = 1 d - 7 !10  displacements or cos(t) are never that small allocate ( zz ( nl )) zz = 1 nz = 0 do i = 1 , nl ! get the norm1 of each line !   suml = 0 !   do j=1,nc !      if ( abs(amatr(i,j)) .ge. suml ) suml = abs(amatr(i,j)) !   enddo suml = maxval ( abs ( amatr ( i ,:))) ! sqrt(sum(amatr(i,:)*amatr(i,:))/nc) if ( suml . lt . small ) then if ( abs ( bmatr ( i )) . lt . small ) then if ( verbose ) write ( ulog , * ) ' line #' , i , ' of Amatrix and Bmatrix is zero; it will be removed!' else write ( ulog , * ) ' Inconsistency in line i of Amatrix which is zero!' , i , suml write ( ulog , * ) ' It will be removed Corresponding line in bmatr is=' , bmatr ( i ) write ( ulog , * ) ' Need to increase your range of FCs' endif ! record the line index for later removal zz ( i ) = 0 nz = nz + 1 endif enddo write ( ulog , * ) ' number of lines=0 in amat are=' , nz allocate ( aa ( nl - nz , nc ), bb ( nl - nz )) tra = 0 ; rot = 0 ; hua = 0 if ( itrans . ne . 0 ) tra = transl_constraints if ( irot . ne . 0 ) rot = rot_constraints if ( ihuang . ne . 0 ) hua = huang_constraints j = 0 do i = 1 , nl if ( zz ( i ). ne . 0 ) then j = j + 1 aa ( j ,:) = amatr ( i ,:) bb ( j ) = bmatr ( i ) elseif ( i . le . tra ) then transl_constraints = transl_constraints - 1 elseif ( i . le . tra + rot ) then rot_constraints = rot_constraints - 1 elseif ( i . le . tra + rot + hua ) then huang_constraints = huang_constraints - 1 else force_constraints = force_constraints - 1 endif enddo write ( ulog , 4 ) 'NEW tra,rot,hua,force_constaints=' , transl_constraints , & & rot_constraints , huang_constraints , force_constraints amatr ( 1 : j ,:) = aa ( 1 : j ,:) bmatr ( 1 : j ) = bb ( 1 : j ) amatr ( j + 1 : nl ,:) = 0 bmatr ( j + 1 : nl ) = 0 if ( j . ne . nl - nz ) then write ( ulog , * ) 'REMOVE ZEROS: Inconsistency! j.ne. nl.nz ' , j , nl - nz stop endif write ( ulog , * ) 'REMOVE ZEROS: new number of lines in amat=' , j deallocate ( aa , bb ) 4 format ( a , 4 ( i9 )) end subroutine remove_zeros !=========================================================== subroutine eliminate_fcs ( sig ) ! try to recalculate using elimination use svd_stuff use params use ios implicit none integer i , n_elim integer , allocatable :: fcmap (:) real ( 8 ), allocatable :: newa (:,:), newb (:,:), newc (:,:), newd (:,:), ainv (:,:), sig_new (:), fc_new (:), bmat_new (:), fc_elim (:) real ( 8 ) error , ermax , sd ( 4 ), sig , num , denom real tim if ( inv_constraints . gt . dim_ac / 2 ) then if ( transl_constraints . gt . dim_ac / 2 ) then return else n_elim = transl_constraints endif else n_elim = inv_constraints endif write ( * , * ) 'number of constraints to be eliminated=' , n_elim write ( ulog , * ) 'number of constraints to be eliminated=' , n_elim allocate ( fcmap ( dim_ac )) i = n_elim allocate ( newa ( i , i ), newb ( i , dim_ac - i ), newc ( dim_al - i , i ), newd ( dim_al - i , dim_ac - i ), ainv ( i , i )) allocate ( fc_new ( dim_ac - i ), sig_new ( dim_ac - i ), bmat_new ( dim_al - i ), fc_elim ( i )) bmat_new = bmat ( 1 + n_elim : dim_al ) write ( ulog , * ) 'Eliminate: dim_al,dim_ac,inv_constraints=' , dim_al , dim_ac , inv_constraints ! decide which fcs to eliminate ! call sort(dim_ac,fcs,fcmap,dim_ac) ! keep the smallest ones and adjust the largest fcs to keep invariance relations satisfied. call invsort ( dim_ac , fcs , fcmap ) ! eliminate n_elim largest fcs defining A=[newa newb]  where newa(n_elim,n_elim) is inverted and substituted !                                         [newc newd] do i = 1 , n_elim newa ( 1 : n_elim , i ) = amat ( 1 : n_elim , fcmap ( i )) newc ( 1 : dim_al - n_elim , i ) = amat ( 1 + n_elim : dim_al , fcmap ( i )) enddo do i = 1 + n_elim , dim_ac newb ( 1 : n_elim , i - n_elim ) = amat ( 1 : n_elim , fcmap ( i )) newd ( 1 : dim_al - n_elim , i - n_elim ) = amat ( 1 + n_elim : dim_al , fcmap ( i )) enddo ! now do the elimination by SVD-solving [D-C(1/A)B]y=b call inverse_real ( newa , ainv , n_elim ) newd = newd - matmul ( newc , matmul ( ainv , newb )) call svd_set ( dim_al - n_elim , dim_ac - n_elim , newd , bmat_new , fc_new , & & sig_new , svdcut , error , ermax , sig , 'svd-aux.out' ) deallocate ( newa , newc , newd , bmat_new ) call cpu_time ( tim ) write ( utimes , '(a,f10.4)' ) ' TIME after second SVD calculation             IS ' , tim ! get the remaining FCs from x=-A_inv B y fc_elim = matmul ( matmul ( ainv , newb ), fc_new ) ! put back in the old order do i = 1 , n_elim fcs ( fcmap ( i )) = fc_elim ( i ) enddo do i = 1 + n_elim , dim_ac fcs ( fcmap ( i )) = fc_new ( i - n_elim ) enddo call write_independent_fcs ( sd ) call write_output_fc2 num = 0 ; denom = 0 do i = 1 , dim_al num = num + ( dot_product ( amat ( i ,:), fcs (:)) - bmat ( i )) ** 2 denom = denom + ( bmat ( i )) ** 2 enddo sig = sqrt ( num / denom ) deallocate ( newb , ainv , fc_elim , sig_new , fc_new ) end subroutine eliminate_fcs !============================================================ subroutine invsort ( n , r , mcor ) ! sorts the first n elements of array r in descending order r(mcor(i)) is the ordered array implicit none integer n , i , j , temp real ( 8 ) r ( n ) integer mcor ( n ) do i = 1 , n mcor ( i ) = i enddo do i = 1 , n ! was 1,n-1 do j = i + 1 , n ! was i+1,n if ( r ( mcor ( i )). lt . r ( mcor ( j ))) then temp = mcor ( i ) mcor ( i ) = mcor ( j ) mcor ( j ) = temp endif enddo enddo !  r(mcor) is now the ordered array r(mcor(1)) > r(mcor(2)) > ... > r(mcor(n)) end subroutine invsort","tags":"","loc":"sourcefile/fc234.f90.html"},{"title":"vector – Example Project ","text":"type, public :: vector Inherited by type~~vector~~InheritedByGraph type~vector vector type~atom_id0 atom_id0 type~atom_id0->type~vector equilibrium_pos type~atomic atomic type~atomic->type~vector equilibrium_pos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x y z Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y real(kind=8), public :: z","tags":"","loc":"type/vector.html"},{"title":"point – Example Project ","text":"type, public :: point Contents Variables x y z Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y real(kind=8), public :: z","tags":"","loc":"type/point.html"},{"title":"cell_id – Example Project ","text":"type, public :: cell_id Inherited by type~~cell_id~~InheritedByGraph type~cell_id cell_id type~atomic atomic type~atomic->type~cell_id cell type~shell shell type~shell->type~cell_id neighbors type~atom_id0 atom_id0 type~atom_id0->type~shell shells Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables n tau Components Type Visibility Attributes Name Initial integer, public :: n (3) integer, public :: tau","tags":"","loc":"type/cell_id.html"},{"title":"shell – Example Project ","text":"type, public :: shell Inherits type~~shell~~InheritsGraph type~shell shell type~cell_id cell_id type~shell->type~cell_id neighbors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~shell~~InheritedByGraph type~shell shell type~atom_id0 atom_id0 type~atom_id0->type~shell shells Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables no_of_neighbors rij neighbors Components Type Visibility Attributes Name Initial integer, public :: no_of_neighbors real(kind=8), public :: rij type( cell_id ), public :: neighbors (296)","tags":"","loc":"type/shell.html"},{"title":"atomic – Example Project ","text":"type, public :: atomic Inherits type~~atomic~~InheritsGraph type~atomic atomic type~vector vector type~atomic->type~vector equilibrium_pos type~cell_id cell_id type~atomic->type~cell_id cell Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables equilibrium_pos cell at_type mass Components Type Visibility Attributes Name Initial type( vector ), public :: equilibrium_pos type( cell_id ), public :: cell integer, public :: at_type real(kind=8), public :: mass","tags":"","loc":"type/atomic.html"},{"title":"atom_id0 – Example Project ","text":"type, public :: atom_id0 Inherits type~~atom_id0~~InheritsGraph type~atom_id0 atom_id0 type~vector vector type~atom_id0->type~vector equilibrium_pos type~shell shell type~atom_id0->type~shell shells type~cell_id cell_id type~shell->type~cell_id neighbors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables at_type name mass charge nshells equilibrium_pos shells Components Type Visibility Attributes Name Initial integer, public :: at_type character, public :: name *2 real(kind=8), public :: mass real(kind=8), public :: charge integer, public :: nshells type( vector ), public :: equilibrium_pos type( shell ), public, allocatable :: shells (:)","tags":"","loc":"type/atom_id0.html"},{"title":"groupmatrix – Example Project ","text":"type, public :: groupmatrix Inherited by type~~groupmatrix~~InheritedByGraph type~groupmatrix groupmatrix type~fulldmatrix fulldmatrix type~fulldmatrix->type~groupmatrix gr Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables mat iat ixyz iatind ixyzind Components Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: mat (:,:) integer, public, allocatable :: iat (:,:) integer, public, allocatable :: ixyz (:,:) integer, public, allocatable :: iatind (:,:) integer, public, allocatable :: ixyzind (:,:)","tags":"","loc":"type/groupmatrix.html"},{"title":"fulldmatrix – Example Project ","text":"type, public :: fulldmatrix Inherits type~~fulldmatrix~~InheritsGraph type~fulldmatrix fulldmatrix type~groupmatrix groupmatrix type~fulldmatrix->type~groupmatrix gr Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables gr nt ntind igr err ngr ntotind ntot Components Type Visibility Attributes Name Initial type( groupmatrix ), public, allocatable :: gr (:) integer, public, allocatable :: nt (:) integer, public, allocatable :: ntind (:) integer, public, allocatable :: igr (:) character(len=1), public, allocatable :: err (:) integer, public :: ngr integer, public :: ntotind integer, public :: ntot","tags":"","loc":"type/fulldmatrix.html"},{"title":"ncmp – Example Project","text":"function ncmp(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value integer Contents None","tags":"","loc":"proc/ncmp.html"},{"title":"vlength – Example Project","text":"function vlength(n, v) Arguments Type Intent Optional Attributes Name integer :: n double precision :: v (n) Return Value double precision Contents None","tags":"","loc":"proc/vlength.html"},{"title":"ndet – Example Project","text":"function ndet(mat) Arguments Type Intent Optional Attributes Name integer :: mat (3,3) Return Value integer Contents None","tags":"","loc":"proc/ndet.html"},{"title":"ifactorial – Example Project","text":"function ifactorial(n) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer Calls proc~~ifactorial~~CallsGraph proc~ifactorial ifactorial proc~bomb bomb proc~ifactorial->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ifactorial.html"},{"title":"force_constants_init – Example Project","text":"subroutine force_constants_init(lattparams, primlatt, natoms_in, iatomtype, atompos_in) Uses force_constants_module lattice proc~~force_constants_init~~UsesGraph proc~force_constants_init force_constants_init module~lattice lattice proc~force_constants_init->module~lattice module~force_constants_module force_constants_module proc~force_constants_init->module~force_constants_module module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: lattparams (6) real(kind=8), intent(in) :: primlatt (3,3) integer, intent(in) :: natoms_in integer, intent(in) :: iatomtype (natoms_in) real(kind=8), intent(in) :: atompos_in (3,natoms_in) Calls proc~~force_constants_init~~CallsGraph proc~force_constants_init force_constants_init proc~xmatinv xmatinv proc~force_constants_init->proc~xmatinv dcosd dcosd proc~force_constants_init->dcosd proc~findatom findatom proc~force_constants_init->proc~findatom datan datan proc~force_constants_init->datan proc~xvmlt xvmlt proc~force_constants_init->proc~xvmlt proc~bomb bomb proc~force_constants_init->proc~bomb proc~xvsub xvsub proc~force_constants_init->proc~xvsub proc~dlatmat2 dlatmat2 proc~force_constants_init->proc~dlatmat2 dsind dsind proc~force_constants_init->dsind proc~xmatmlt xmatmlt proc~force_constants_init->proc~xmatmlt proc~unitcell unitcell proc~force_constants_init->proc~unitcell proc~lubksb lubksb proc~xmatinv->proc~lubksb proc~ludcmp ludcmp proc~xmatinv->proc~ludcmp proc~dlatmat2->proc~bomb proc~dlatmat2->proc~xvsub proc~unitcell->proc~xmatmlt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~force_constants_init~~CalledByGraph proc~force_constants_init force_constants_init program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/force_constants_init.html"},{"title":"force_constants – Example Project","text":"subroutine force_constants(nrank, iatomd, ixyzd, ntermsindep, iatomtermindep, ixyztermindep, nterm5, iatomtermall, ixyztermall, amat, ntermszero, iatomtermzero, ixyztermzero, maxrank, maxterms, maxtermsindep, maxtermszero, ierz, iert, ieri) Uses force_constants_module proc~~force_constants~~UsesGraph proc~force_constants force_constants module~force_constants_module force_constants_module proc~force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrank integer, intent(in) :: iatomd (nrank) integer, intent(in) :: ixyzd (nrank) integer, intent(out) :: ntermsindep integer, intent(out) :: iatomtermindep (maxrank,maxterms) integer, intent(out) :: ixyztermindep (maxrank,maxterms) integer, intent(out) :: nterm5 integer, intent(out) :: iatomtermall (maxrank,maxterms) integer, intent(out) :: ixyztermall (maxrank,maxterms) real(kind=8), intent(out) :: amat (maxterms,maxtermsindep) integer, intent(out) :: ntermszero integer, intent(out) :: iatomtermzero (maxrank,maxtermszero) integer, intent(out) :: ixyztermzero (maxrank,maxtermszero) integer, intent(in) :: maxrank integer, intent(in) :: maxterms integer, intent(in) :: maxtermsindep integer, intent(in) :: maxtermszero integer, intent(out) :: ierz integer, intent(out) :: iert integer, intent(out) :: ieri Calls proc~~force_constants~~CallsGraph proc~force_constants force_constants proc~xrowop2 xrowop2 proc~force_constants->proc~xrowop2 proc~findatom findatom proc~force_constants->proc~findatom proc~xvmlt xvmlt proc~force_constants->proc~xvmlt proc~unique_force_constant unique_force_constant proc~force_constants->proc~unique_force_constant proc~permutations permutations proc~force_constants->proc~permutations proc~findatom2 findatom2 proc~force_constants->proc~findatom2 proc~unique_force_constant->proc~findatom proc~bomb bomb proc~permutations->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~force_constants~~CalledByGraph proc~force_constants force_constants proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/force_constants.html"},{"title":"unique_force_constant – Example Project","text":"subroutine unique_force_constant(nrank, iatomin, ixyzin, iatomout, ixyzout) Uses force_constants_module proc~~unique_force_constant~~UsesGraph proc~unique_force_constant unique_force_constant module~force_constants_module force_constants_module proc~unique_force_constant->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrank integer, intent(in) :: iatomin (nrank) integer, intent(in) :: ixyzin (nrank) integer, intent(out) :: iatomout (nrank) integer, intent(out) :: ixyzout (nrank) Calls proc~~unique_force_constant~~CallsGraph proc~unique_force_constant unique_force_constant proc~findatom findatom proc~unique_force_constant->proc~findatom Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~unique_force_constant~~CalledByGraph proc~unique_force_constant unique_force_constant proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~unique_force_constant proc~force_constants force_constants proc~collect_force_constants->proc~force_constants proc~force_constants->proc~unique_force_constant proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/unique_force_constant.html"},{"title":"findatom – Example Project","text":"subroutine findatom(icell, icell0, iatom) Uses force_constants_module proc~~findatom~~UsesGraph proc~findatom findatom module~force_constants_module force_constants_module proc~findatom->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. find atom in data base Arguments Type Intent Optional Attributes Name integer, intent(in) :: icell (3) integer, intent(in) :: icell0 integer, intent(out) :: iatom Called by proc~~findatom~~CalledByGraph proc~findatom findatom proc~force_constants_init force_constants_init proc~force_constants_init->proc~findatom proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~findatom proc~unique_force_constant unique_force_constant proc~collect_force_constants->proc~unique_force_constant proc~force_constants force_constants proc~collect_force_constants->proc~force_constants proc~unique_force_constant->proc~findatom proc~force_constants->proc~findatom proc~force_constants->proc~unique_force_constant program~fc234 FC234 program~fc234->proc~force_constants_init proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~setup_maps->proc~collect_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/findatom.html"},{"title":"findatom2 – Example Project","text":"subroutine findatom2(pos, iatom) Uses force_constants_module proc~~findatom2~~UsesGraph proc~findatom2 findatom2 module~force_constants_module force_constants_module proc~findatom2->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. find atom in data base Arguments Type Intent Optional Attributes Name double precision :: pos (3) integer :: iatom Called by proc~~findatom2~~CalledByGraph proc~findatom2 findatom2 proc~force_constants force_constants proc~force_constants->proc~findatom2 proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/findatom2.html"},{"title":"xmatinv – Example Project","text":"subroutine xmatinv(xmatin, xmatout, ier) invert a 3 by 3 matrix Arguments Type Intent Optional Attributes Name double precision :: xmatin (3,3) double precision :: xmatout (3,3) integer :: ier Calls proc~~xmatinv~~CallsGraph proc~xmatinv xmatinv proc~lubksb lubksb proc~xmatinv->proc~lubksb proc~ludcmp ludcmp proc~xmatinv->proc~ludcmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~xmatinv~~CalledByGraph proc~xmatinv xmatinv proc~force_constants_init force_constants_init proc~force_constants_init->proc~xmatinv program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xmatinv.html"},{"title":"ludcmp – Example Project","text":"subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name double precision :: a (np,np) integer :: n integer :: np integer :: indx (n) double precision :: d Called by proc~~ludcmp~~CalledByGraph proc~ludcmp ludcmp proc~xmatinv xmatinv proc~xmatinv->proc~ludcmp proc~force_constants_init force_constants_init proc~force_constants_init->proc~xmatinv program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ludcmp.html"},{"title":"lubksb – Example Project","text":"subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name double precision :: a (np,np) integer :: n integer :: np integer :: indx (n) double precision :: b (n) Called by proc~~lubksb~~CalledByGraph proc~lubksb lubksb proc~xmatinv xmatinv proc~xmatinv->proc~lubksb proc~force_constants_init force_constants_init proc~force_constants_init->proc~xmatinv program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lubksb.html"},{"title":"xmatmlt – Example Project","text":"subroutine xmatmlt(x1, x2, x3, nrow1, ncol1, ncol2, nr1, nr2, nr3) multiply two real matrices, x3=x1*x2 Arguments Type Intent Optional Attributes Name double precision :: x1 (nr1,ncol1) double precision :: x2 (nr2,ncol2) double precision :: x3 (nr3,ncol2) integer :: nrow1 integer :: ncol1 integer :: ncol2 integer :: nr1 integer :: nr2 integer :: nr3 Called by proc~~xmatmlt~~CalledByGraph proc~xmatmlt xmatmlt proc~force_constants_init force_constants_init proc~force_constants_init->proc~xmatmlt proc~unitcell unitcell proc~force_constants_init->proc~unitcell proc~unitcell->proc~xmatmlt proc~getstar getstar proc~getstar->proc~xmatmlt program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xmatmlt.html"},{"title":"xvmlt – Example Project","text":"subroutine xvmlt(x, v1, v2, nrow, ncol, nr) multiply a double precision vector by a double precision matrix, v2=x*v1 Arguments Type Intent Optional Attributes Name double precision :: x (nr,ncol) double precision :: v1 (ncol) double precision :: v2 (nrow) integer :: nrow integer :: ncol integer :: nr Called by proc~~xvmlt~~CalledByGraph proc~xvmlt xvmlt proc~force_constants_init force_constants_init proc~force_constants_init->proc~xvmlt proc~force_constants force_constants proc~force_constants->proc~xvmlt proc~getstar getstar proc~getstar->proc~xvmlt program~fc234 FC234 program~fc234->proc~force_constants_init proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps->proc~collect_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xvmlt.html"},{"title":"unitcell – Example Project","text":"subroutine unitcell(cart_to_prim, prim_to_cart, v1, v2) Arguments Type Intent Optional Attributes Name double precision :: cart_to_prim (3,3) double precision :: prim_to_cart (3,3) double precision :: v1 (3) double precision :: v2 (3) Calls proc~~unitcell~~CallsGraph proc~unitcell unitcell proc~xmatmlt xmatmlt proc~unitcell->proc~xmatmlt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~unitcell~~CalledByGraph proc~unitcell unitcell proc~force_constants_init force_constants_init proc~force_constants_init->proc~unitcell program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/unitcell.html"},{"title":"dlatmat2 – Example Project","text":"subroutine dlatmat2(cart, eps, nmatrices, matrices) find symmetry matrices for a given lattice Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: cart (3,3) real(kind=8), intent(in) :: eps integer, intent(out) :: nmatrices integer, intent(out) :: matrices (3,3,48) Calls proc~~dlatmat2~~CallsGraph proc~dlatmat2 dlatmat2 proc~xvsub xvsub proc~dlatmat2->proc~xvsub proc~bomb bomb proc~dlatmat2->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dlatmat2~~CalledByGraph proc~dlatmat2 dlatmat2 proc~force_constants_init force_constants_init proc~force_constants_init->proc~dlatmat2 program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dlatmat2.html"},{"title":"xvsub – Example Project","text":"subroutine xvsub(v1, v2, v3, nrow) subtract two real vectors: v3=v1-v2 Arguments Type Intent Optional Attributes Name double precision :: v1 (nrow) double precision :: v2 (nrow) double precision :: v3 (nrow) integer :: nrow Called by proc~~xvsub~~CalledByGraph proc~xvsub xvsub proc~force_constants_init force_constants_init proc~force_constants_init->proc~xvsub proc~dlatmat2 dlatmat2 proc~force_constants_init->proc~dlatmat2 proc~dlatmat2->proc~xvsub proc~getstar getstar proc~getstar->proc~xvsub program~fc234 FC234 program~fc234->proc~force_constants_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xvsub.html"},{"title":"xvadd – Example Project","text":"subroutine xvadd(v1, v2, v3, nrow) add two real vectors: v3=v1+v2 Arguments Type Intent Optional Attributes Name double precision :: v1 (nrow) double precision :: v2 (nrow) double precision :: v3 (nrow) integer :: nrow Contents None","tags":"","loc":"proc/xvadd.html"},{"title":"bomb – Example Project","text":"subroutine bomb() Arguments None Called by proc~~bomb~~CalledByGraph proc~bomb bomb proc~force_constants_init force_constants_init proc~force_constants_init->proc~bomb proc~dlatmat2 dlatmat2 proc~force_constants_init->proc~dlatmat2 proc~ifactorial ifactorial proc~ifactorial->proc~bomb proc~permutations permutations proc~permutations->proc~bomb proc~dlatmat2->proc~bomb program~fc234 FC234 program~fc234->proc~force_constants_init proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~force_constants force_constants proc~force_constants->proc~permutations proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps->proc~collect_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bomb.html"},{"title":"permutations – Example Project","text":"subroutine permutations(n, ipermutations, nr, nc) Arguments Type Intent Optional Attributes Name integer :: n integer :: ipermutations (nr,nc) integer :: nr integer :: nc Calls proc~~permutations~~CallsGraph proc~permutations permutations proc~bomb bomb proc~permutations->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~permutations~~CalledByGraph proc~permutations permutations proc~force_constants force_constants proc~force_constants->proc~permutations proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/permutations.html"},{"title":"xrowop2 – Example Project","text":"subroutine xrowop2(zna, nrow, ncol, nnrow, nncol) Arguments Type Intent Optional Attributes Name double precision :: zna (nnrow,nncol) integer :: nrow integer :: ncol integer :: nnrow integer :: nncol Called by proc~~xrowop2~~CalledByGraph proc~xrowop2 xrowop2 proc~force_constants force_constants proc~force_constants->proc~xrowop2 proc~collect_force_constants collect_force_constants proc~collect_force_constants->proc~force_constants proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xrowop2.html"},{"title":"getstar – Example Project","text":"subroutine getstar(kvec, primlatt, narms, kvecstar, kvecop) Uses force_constants_module proc~~getstar~~UsesGraph proc~getstar getstar module~force_constants_module force_constants_module proc~getstar->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kvec (3) real(kind=8), intent(in) :: primlatt (3,3) integer, intent(out) :: narms real(kind=8), intent(out) :: kvecstar (3,48) integer, intent(out) :: kvecop (48) Calls proc~~getstar~~CallsGraph proc~getstar getstar proc~xvsub xvsub proc~getstar->proc~xvsub proc~xvmlt xvmlt proc~getstar->proc~xvmlt proc~xmatmlt xmatmlt proc~getstar->proc~xmatmlt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/getstar.html"},{"title":"collect_force_constants – Example Project","text":"subroutine collect_force_constants(nrank, nshell, ngroups, ntermsindep, iatomtermindep, ixyztermindep, nterm6, iatomterm, ixyzterm, amat, ntermszero, iatomtermzero, ixyztermzero, maxrank, maxterms, maxtermsindep, maxtermszero, maxgroups, ierz, iert, ieri, ierg) Uses force_constants_module proc~~collect_force_constants~~UsesGraph proc~collect_force_constants collect_force_constants module~force_constants_module force_constants_module proc~collect_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nrank integer, intent(in) :: nshell (natoms0) integer, intent(out) :: ngroups integer, intent(out) :: ntermsindep (maxgroups) integer, intent(out) :: iatomtermindep (maxrank,maxterms,maxgroups) integer, intent(out) :: ixyztermindep (maxrank,maxterms,maxgroups) integer, intent(out) :: nterm6 (maxgroups) integer, intent(out) :: iatomterm (maxrank,maxterms,maxgroups) integer, intent(out) :: ixyzterm (maxrank,maxterms,maxgroups) real(kind=8), intent(out) :: amat (maxterms,maxtermsindep,maxgroups) integer, intent(out) :: ntermszero integer, intent(out) :: iatomtermzero (maxrank,maxtermszero) integer, intent(out) :: ixyztermzero (maxrank,maxtermszero) integer, intent(in) :: maxrank integer, intent(in) :: maxterms integer, intent(in) :: maxtermsindep integer, intent(in) :: maxtermszero integer, intent(in) :: maxgroups integer, intent(out) :: ierz integer, intent(out) :: iert integer, intent(out) :: ieri integer, intent(out) :: ierg Calls proc~~collect_force_constants~~CallsGraph proc~collect_force_constants collect_force_constants proc~findatom findatom proc~collect_force_constants->proc~findatom 99 99 proc~collect_force_constants->99 proc~unique_force_constant unique_force_constant proc~collect_force_constants->proc~unique_force_constant proc~force_constants force_constants proc~collect_force_constants->proc~force_constants proc~unique_force_constant->proc~findatom proc~force_constants->proc~findatom proc~force_constants->proc~unique_force_constant proc~xvmlt xvmlt proc~force_constants->proc~xvmlt proc~xrowop2 xrowop2 proc~force_constants->proc~xrowop2 proc~permutations permutations proc~force_constants->proc~permutations proc~findatom2 findatom2 proc~force_constants->proc~findatom2 proc~bomb bomb proc~permutations->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~collect_force_constants~~CalledByGraph proc~collect_force_constants collect_force_constants proc~setup_maps setup_maps proc~setup_maps->proc~collect_force_constants program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/collect_force_constants.html"},{"title":"read_input – Example Project","text":"subroutine read_input() Uses lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~read_input~~UsesGraph proc~read_input read_input module~svd_stuff svd_stuff proc~read_input->module~svd_stuff module~force_constants_module force_constants_module proc~read_input->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~read_input->module~atoms_force_constants module~lattice lattice proc~read_input->module~lattice module~ios ios proc~read_input->module~ios module~params params proc~read_input->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry module~constants constants module~lattice->module~constants module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~read_input~~CallsGraph proc~read_input read_input proc~allocate_primcell allocate_primcell proc~read_input->proc~allocate_primcell proc~allocate_mass allocate_mass proc~read_input->proc~allocate_mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_input~~CalledByGraph proc~read_input read_input program~fc234 FC234 program~fc234->proc~read_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_input.html"},{"title":"read_crystal – Example Project","text":"subroutine read_crystal(poscar) Uses geometry lattice ios params atoms_force_constants proc~~read_crystal~~UsesGraph proc~read_crystal read_crystal module~geometry geometry proc~read_crystal->module~geometry module~atoms_force_constants atoms_force_constants proc~read_crystal->module~atoms_force_constants module~lattice lattice proc~read_crystal->module~lattice module~ios ios proc~read_crystal->module~ios module~params params proc~read_crystal->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character :: poscar *(*) Calls proc~~read_crystal~~CallsGraph proc~read_crystal read_crystal 9 9 proc~read_crystal->9 interface~length length proc~read_crystal->interface~length proc~make_reciprocal_lattice make_reciprocal_lattice proc~read_crystal->proc~make_reciprocal_lattice proc~calculate_volume calculate_volume proc~read_crystal->proc~calculate_volume interface~write_out write_out proc~read_crystal->interface~write_out proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 3 3 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_crystal~~CalledByGraph proc~read_crystal read_crystal program~fc234 FC234 program~fc234->proc~read_crystal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_crystal.html"},{"title":"check_input_poscar_consistency – Example Project","text":"subroutine check_input_poscar_consistency() Uses geometry lattice ios params atoms_force_constants proc~~check_input_poscar_consistency~~UsesGraph proc~check_input_poscar_consistency check_input_poscar_consistency module~geometry geometry proc~check_input_poscar_consistency->module~geometry module~atoms_force_constants atoms_force_constants proc~check_input_poscar_consistency->module~atoms_force_constants module~lattice lattice proc~check_input_poscar_consistency->module~lattice module~ios ios proc~check_input_poscar_consistency->module~ios module~params params proc~check_input_poscar_consistency->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~check_input_poscar_consistency~~CallsGraph proc~check_input_poscar_consistency check_input_poscar_consistency 3 3 proc~check_input_poscar_consistency->3 9 9 proc~check_input_poscar_consistency->9 proc~check check proc~check_input_poscar_consistency->proc~check interface~write_out write_out proc~check_input_poscar_consistency->interface~write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_input_poscar_consistency.html"},{"title":"check_input_poscar_consistency_new – Example Project","text":"subroutine check_input_poscar_consistency_new() Uses geometry lattice ios params atoms_force_constants proc~~check_input_poscar_consistency_new~~UsesGraph proc~check_input_poscar_consistency_new check_input_poscar_consistency_new module~geometry geometry proc~check_input_poscar_consistency_new->module~geometry module~atoms_force_constants atoms_force_constants proc~check_input_poscar_consistency_new->module~atoms_force_constants module~lattice lattice proc~check_input_poscar_consistency_new->module~lattice module~ios ios proc~check_input_poscar_consistency_new->module~ios module~params params proc~check_input_poscar_consistency_new->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~check_input_poscar_consistency_new~~CallsGraph proc~check_input_poscar_consistency_new check_input_poscar_consistency_new 9 9 proc~check_input_poscar_consistency_new->9 2 2 proc~check_input_poscar_consistency_new->2 3 3 proc~check_input_poscar_consistency_new->3 proc~check check proc~check_input_poscar_consistency_new->proc~check interface~write_out write_out proc~check_input_poscar_consistency_new->interface~write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_input_poscar_consistency_new~~CalledByGraph proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new program~fc234 FC234 program~fc234->proc~identify_atoms_in_supercell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_input_poscar_consistency_new.html"},{"title":"read_force_position_data – Example Project","text":"subroutine read_force_position_data(outcar, frc_constr) Uses geometry lattice svd_stuff ios params atoms_force_constants proc~~read_force_position_data~~UsesGraph proc~read_force_position_data read_force_position_data module~svd_stuff svd_stuff proc~read_force_position_data->module~svd_stuff module~geometry geometry proc~read_force_position_data->module~geometry module~lattice lattice proc~read_force_position_data->module~lattice module~atoms_force_constants atoms_force_constants proc~read_force_position_data->module~atoms_force_constants module~ios ios proc~read_force_position_data->module~ios module~params params proc~read_force_position_data->module~params module~lattice->module~geometry module~constants constants module~lattice->module~constants module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character :: outcar *(*) integer :: frc_constr Calls proc~~read_force_position_data~~CallsGraph proc~read_force_position_data read_force_position_data proc~findword findword proc~read_force_position_data->proc~findword proc~allocate_pos allocate_pos proc~read_force_position_data->proc~allocate_pos interface~write_out write_out proc~read_force_position_data->interface~write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 3 3 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_force_position_data~~CalledByGraph proc~read_force_position_data read_force_position_data program~fc234 FC234 program~fc234->proc~read_force_position_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_force_position_data.html"},{"title":"write_independent_fcs – Example Project","text":"subroutine write_independent_fcs(sd) Uses svd_stuff ios params atoms_force_constants proc~~write_independent_fcs~~UsesGraph proc~write_independent_fcs write_independent_fcs module~svd_stuff svd_stuff proc~write_independent_fcs->module~svd_stuff module~params params proc~write_independent_fcs->module~params module~atoms_force_constants atoms_force_constants proc~write_independent_fcs->module~atoms_force_constants module~ios ios proc~write_independent_fcs->module~ios module~geometry geometry module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. fc1 = fc1-matmul(a11ia12,fcs) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: sd (4) Calls proc~~write_independent_fcs~~CallsGraph proc~write_independent_fcs write_independent_fcs 3 3 proc~write_independent_fcs->3 9 9 proc~write_independent_fcs->9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_independent_fcs~~CalledByGraph proc~write_independent_fcs write_independent_fcs proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~write_independent_fcs program~fc234 FC234 program~fc234->proc~write_independent_fcs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_independent_fcs.html"},{"title":"write_independent_fcs_2 – Example Project","text":"subroutine write_independent_fcs_2(sd) Uses svd_stuff ios params atoms_force_constants proc~~write_independent_fcs_2~~UsesGraph proc~write_independent_fcs_2 write_independent_fcs_2 module~svd_stuff svd_stuff proc~write_independent_fcs_2->module~svd_stuff module~params params proc~write_independent_fcs_2->module~params module~atoms_force_constants atoms_force_constants proc~write_independent_fcs_2->module~atoms_force_constants module~ios ios proc~write_independent_fcs_2->module~ios module~geometry geometry module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: sd (4) Calls proc~~write_independent_fcs_2~~CallsGraph proc~write_independent_fcs_2 write_independent_fcs_2 proc~check_huang check_huang proc~write_independent_fcs_2->proc~check_huang 9 9 proc~write_independent_fcs_2->9 3 3 proc~write_independent_fcs_2->3 proc~check_huang->9 8 8 proc~check_huang->8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_independent_fcs_2.html"},{"title":"write_neighbors – Example Project","text":"subroutine write_neighbors() Uses ios force_constants_module params atoms_force_constants proc~~write_neighbors~~UsesGraph proc~write_neighbors write_neighbors module~atoms_force_constants atoms_force_constants proc~write_neighbors->module~atoms_force_constants module~params params proc~write_neighbors->module~params module~force_constants_module force_constants_module proc~write_neighbors->module~force_constants_module module~ios ios proc~write_neighbors->module~ios module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~write_neighbors~~CallsGraph proc~write_neighbors write_neighbors 3 3 proc~write_neighbors->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_neighbors~~CalledByGraph proc~write_neighbors write_neighbors program~fc234 FC234 program~fc234->proc~write_neighbors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_neighbors.html"},{"title":"write_output_fc2 – Example Project","text":"subroutine write_output_fc2() Uses constants lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~write_output_fc2~~UsesGraph proc~write_output_fc2 write_output_fc2 module~svd_stuff svd_stuff proc~write_output_fc2->module~svd_stuff module~force_constants_module force_constants_module proc~write_output_fc2->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~write_output_fc2->module~atoms_force_constants module~lattice lattice proc~write_output_fc2->module~lattice module~ios ios proc~write_output_fc2->module~ios module~constants constants proc~write_output_fc2->module~constants module~params params proc~write_output_fc2->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry module~lattice->module~constants module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~write_output_fc2~~CallsGraph proc~write_output_fc2 write_output_fc2 3 3 proc~write_output_fc2->3 2 2 proc~write_output_fc2->2 4 4 proc~write_output_fc2->4 interface~length length proc~write_output_fc2->interface~length proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_output_fc2~~CalledByGraph proc~write_output_fc2 write_output_fc2 proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~write_output_fc2 program~fc234 FC234 program~fc234->proc~write_output_fc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_output_fc2.html"},{"title":"read_output_fc2 – Example Project","text":"subroutine read_output_fc2() Uses constants lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~read_output_fc2~~UsesGraph proc~read_output_fc2 read_output_fc2 module~svd_stuff svd_stuff proc~read_output_fc2->module~svd_stuff module~force_constants_module force_constants_module proc~read_output_fc2->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~read_output_fc2->module~atoms_force_constants module~lattice lattice proc~read_output_fc2->module~lattice module~ios ios proc~read_output_fc2->module~ios module~constants constants proc~read_output_fc2->module~constants module~params params proc~read_output_fc2->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry module~lattice->module~constants module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~read_output_fc2~~CallsGraph proc~read_output_fc2 read_output_fc2 3 3 proc~read_output_fc2->3 2 2 proc~read_output_fc2->2 4 4 proc~read_output_fc2->4 interface~length length proc~read_output_fc2->interface~length proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_output_fc2.html"},{"title":"write_output_fc – Example Project","text":"subroutine write_output_fc() Uses constants lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~write_output_fc~~UsesGraph proc~write_output_fc write_output_fc module~svd_stuff svd_stuff proc~write_output_fc->module~svd_stuff module~force_constants_module force_constants_module proc~write_output_fc->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~write_output_fc->module~atoms_force_constants module~lattice lattice proc~write_output_fc->module~lattice module~ios ios proc~write_output_fc->module~ios module~constants constants proc~write_output_fc->module~constants module~params params proc~write_output_fc->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry module~lattice->module~constants module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~write_output_fc~~CallsGraph proc~write_output_fc write_output_fc 9 9 proc~write_output_fc->9 proc~write_lat_fc write_lat_fc proc~write_output_fc->proc~write_lat_fc interface~length length proc~write_output_fc->interface~length 2 2 proc~write_output_fc->2 3 3 proc~write_output_fc->3 4 4 proc~write_output_fc->4 1 1 proc~write_output_fc->1 proc~write_lat_fc->9 proc~write_lat_fc->interface~length proc~write_lat_fc->3 proc~write_lat_fc->4 proc~write_lat_fc->1 proc~findatom_sc findatom_sc proc~write_lat_fc->proc~findatom_sc proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha dfloat dfloat proc~findatom_sc->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_output_fc.html"},{"title":"read_fcs_2 – Example Project","text":"subroutine read_fcs_2(rank) Uses svd_stuff ios force_constants_module params atoms_force_constants proc~~read_fcs_2~~UsesGraph proc~read_fcs_2 read_fcs_2 module~svd_stuff svd_stuff proc~read_fcs_2->module~svd_stuff module~force_constants_module force_constants_module proc~read_fcs_2->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~read_fcs_2->module~atoms_force_constants module~ios ios proc~read_fcs_2->module~ios module~params params proc~read_fcs_2->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: rank Called by proc~~read_fcs_2~~CalledByGraph proc~read_fcs_2 read_fcs_2 proc~setup_maps setup_maps proc~setup_maps->proc~read_fcs_2 program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_fcs_2.html"},{"title":"calculate_and_write_displacements – Example Project","text":"subroutine calculate_and_write_displacements() Uses geometry lattice ios params atoms_force_constants proc~~calculate_and_write_displacements~~UsesGraph proc~calculate_and_write_displacements calculate_and_write_displacements module~geometry geometry proc~calculate_and_write_displacements->module~geometry module~atoms_force_constants atoms_force_constants proc~calculate_and_write_displacements->module~atoms_force_constants module~lattice lattice proc~calculate_and_write_displacements->module~lattice module~ios ios proc~calculate_and_write_displacements->module~ios module~params params proc~calculate_and_write_displacements->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~calculate_and_write_displacements~~CallsGraph proc~calculate_and_write_displacements calculate_and_write_displacements 3 3 proc~calculate_and_write_displacements->3 proc~direct_to_cart_aa direct_to_cart_aa proc~calculate_and_write_displacements->proc~direct_to_cart_aa 2 2 proc~calculate_and_write_displacements->2 proc~cart_to_direct_aa cart_to_direct_aa proc~calculate_and_write_displacements->proc~cart_to_direct_aa proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_aa->proc~direct_to_cart_v proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_aa->proc~cart_to_direct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calculate_and_write_displacements~~CalledByGraph proc~calculate_and_write_displacements calculate_and_write_displacements program~fc234 FC234 program~fc234->proc~calculate_and_write_displacements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_and_write_displacements.html"},{"title":"identify_atoms_in_supercell – Example Project","text":"subroutine identify_atoms_in_supercell() Uses geometry lattice ios params atoms_force_constants proc~~identify_atoms_in_supercell~~UsesGraph proc~identify_atoms_in_supercell identify_atoms_in_supercell module~geometry geometry proc~identify_atoms_in_supercell->module~geometry module~atoms_force_constants atoms_force_constants proc~identify_atoms_in_supercell->module~atoms_force_constants module~lattice lattice proc~identify_atoms_in_supercell->module~lattice module~ios ios proc~identify_atoms_in_supercell->module~ios module~params params proc~identify_atoms_in_supercell->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~identify_atoms_in_supercell~~CallsGraph proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new 3 3 proc~identify_atoms_in_supercell->3 proc~check_input_poscar_consistency_new->3 9 9 proc~check_input_poscar_consistency_new->9 2 2 proc~check_input_poscar_consistency_new->2 proc~check check proc~check_input_poscar_consistency_new->proc~check interface~write_out write_out proc~check_input_poscar_consistency_new->interface~write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~identify_atoms_in_supercell~~CalledByGraph proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234 FC234 program~fc234->proc~identify_atoms_in_supercell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/identify_atoms_in_supercell.html"},{"title":"ustring – Example Project","text":"subroutine ustring(m, lineout, nrank, iatom, ixyz) Arguments Type Intent Optional Attributes Name integer :: m character :: lineout *80 integer :: nrank integer :: iatom (nrank) integer :: ixyz (nrank) Called by proc~~ustring~~CalledByGraph proc~ustring ustring proc~setup_maps setup_maps proc~setup_maps->proc~ustring program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ustring.html"},{"title":"pos_out_consistency – Example Project","text":"subroutine pos_out_consistency() Uses geometry lattice ios params atoms_force_constants proc~~pos_out_consistency~~UsesGraph proc~pos_out_consistency pos_out_consistency module~geometry geometry proc~pos_out_consistency->module~geometry module~atoms_force_constants atoms_force_constants proc~pos_out_consistency->module~atoms_force_constants module~lattice lattice proc~pos_out_consistency->module~lattice module~ios ios proc~pos_out_consistency->module~ios module~params params proc~pos_out_consistency->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~pos_out_consistency~~CallsGraph proc~pos_out_consistency pos_out_consistency proc~direct_to_cart_aa direct_to_cart_aa proc~pos_out_consistency->proc~direct_to_cart_aa proc~cart_to_direct_aa cart_to_direct_aa proc~pos_out_consistency->proc~cart_to_direct_aa proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_aa->proc~direct_to_cart_v proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_aa->proc~cart_to_direct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pos_out_consistency.html"},{"title":"write_correspondance – Example Project","text":"subroutine write_correspondance() Uses geometry lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~write_correspondance~~UsesGraph proc~write_correspondance write_correspondance module~svd_stuff svd_stuff proc~write_correspondance->module~svd_stuff module~force_constants_module force_constants_module proc~write_correspondance->module~force_constants_module module~geometry geometry proc~write_correspondance->module~geometry module~lattice lattice proc~write_correspondance->module~lattice module~atoms_force_constants atoms_force_constants proc~write_correspondance->module~atoms_force_constants module~ios ios proc~write_correspondance->module~ios module~params params proc~write_correspondance->module~params module~lattice->module~geometry module~constants constants module~lattice->module~constants module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~write_correspondance~~CallsGraph proc~write_correspondance write_correspondance proc~findatom_sc findatom_sc proc~write_correspondance->proc~findatom_sc interface~length length proc~write_correspondance->interface~length 2 2 proc~write_correspondance->2 4 4 proc~write_correspondance->4 dfloat dfloat proc~write_correspondance->dfloat proc~findatom_sc->dfloat proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_correspondance.html"},{"title":"write_correspondance2 – Example Project","text":"subroutine write_correspondance2() Uses geometry lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~write_correspondance2~~UsesGraph proc~write_correspondance2 write_correspondance2 module~svd_stuff svd_stuff proc~write_correspondance2->module~svd_stuff module~force_constants_module force_constants_module proc~write_correspondance2->module~force_constants_module module~geometry geometry proc~write_correspondance2->module~geometry module~lattice lattice proc~write_correspondance2->module~lattice module~atoms_force_constants atoms_force_constants proc~write_correspondance2->module~atoms_force_constants module~ios ios proc~write_correspondance2->module~ios module~params params proc~write_correspondance2->module~params module~lattice->module~geometry module~constants constants module~lattice->module~constants module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~write_correspondance2~~CallsGraph proc~write_correspondance2 write_correspondance2 proc~findatom_sc findatom_sc proc~write_correspondance2->proc~findatom_sc interface~length length proc~write_correspondance2->interface~length 2 2 proc~write_correspondance2->2 4 4 proc~write_correspondance2->4 dfloat dfloat proc~write_correspondance2->dfloat proc~findatom_sc->dfloat proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_correspondance2~~CalledByGraph proc~write_correspondance2 write_correspondance2 program~fc234 FC234 program~fc234->proc~write_correspondance2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_correspondance2.html"},{"title":"warn – Example Project","text":"subroutine warn(unt) Arguments Type Intent Optional Attributes Name integer :: unt Called by proc~~warn~~CalledByGraph proc~warn warn program~fc234 FC234 program~fc234->proc~warn proc~check_zero_column check_zero_column program~fc234->proc~check_zero_column proc~check_zero_column->proc~warn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/warn.html"},{"title":"write_lat_fc – Example Project","text":"subroutine write_lat_fc(ngrps, ntrms) Uses constants lattice svd_stuff ios force_constants_module params atoms_force_constants proc~~write_lat_fc~~UsesGraph proc~write_lat_fc write_lat_fc module~svd_stuff svd_stuff proc~write_lat_fc->module~svd_stuff module~force_constants_module force_constants_module proc~write_lat_fc->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~write_lat_fc->module~atoms_force_constants module~lattice lattice proc~write_lat_fc->module~lattice module~ios ios proc~write_lat_fc->module~ios module~constants constants proc~write_lat_fc->module~constants module~params params proc~write_lat_fc->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry module~lattice->module~constants module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: ngrps (4) integer :: ntrms (4) Calls proc~~write_lat_fc~~CallsGraph proc~write_lat_fc write_lat_fc proc~findatom_sc findatom_sc proc~write_lat_fc->proc~findatom_sc 9 9 proc~write_lat_fc->9 interface~length length proc~write_lat_fc->interface~length 3 3 proc~write_lat_fc->3 4 4 proc~write_lat_fc->4 1 1 proc~write_lat_fc->1 dfloat dfloat proc~findatom_sc->dfloat proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_lat_fc~~CalledByGraph proc~write_lat_fc write_lat_fc program~fc234 FC234 program~fc234->proc~write_lat_fc proc~write_output_fc write_output_fc proc~write_output_fc->proc~write_lat_fc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_lat_fc.html"},{"title":"fcut – Example Project","text":"function fcut(x, x1, x2) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x real(kind=8), intent(in) :: x1 real(kind=8), intent(in) :: x2 Return Value real(kind=8) Contents None","tags":"","loc":"proc/fcut.html"},{"title":"delta – Example Project","text":"function delta(x) result(y) Uses constants proc~~delta~~UsesGraph proc~delta delta module~constants constants proc~delta->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Contents None","tags":"","loc":"proc/delta.html"},{"title":"delta_g – Example Project","text":"function delta_g(x, w) result(y) Uses constants proc~~delta_g~~UsesGraph proc~delta_g delta_g module~constants constants proc~delta_g->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: w Return Value real(kind=8) Contents None","tags":"","loc":"proc/delta_g.html"},{"title":"delta_l – Example Project","text":"function delta_l(x, w) result(y) Uses constants proc~~delta_l~~UsesGraph proc~delta_l delta_l module~constants constants proc~delta_l->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: w Return Value real(kind=8) Contents None","tags":"","loc":"proc/delta_l.html"},{"title":"nbe – Example Project","text":"function nbe(w, t, m) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w real(kind=8), intent(in) :: t integer :: m Return Value real(kind=8) Contents None","tags":"","loc":"proc/nbe.html"},{"title":"indexg – Example Project","text":"function indexg(i, j, k, nil, njl, njh, nkl, nkh) result(n) Arguments Type Intent Optional Attributes Name integer :: i integer :: j integer :: k integer :: nil integer :: njl integer :: njh integer :: nkl integer :: nkh Return Value integer Contents None","tags":"","loc":"proc/indexg.html"},{"title":"indexn – Example Project","text":"function indexn(i, j, k, n1, n2, n3) result(n) Arguments Type Intent Optional Attributes Name integer :: i integer :: j integer :: k integer :: n1 integer :: n2 integer :: n3 Return Value integer Contents None","tags":"","loc":"proc/indexn.html"},{"title":"trace – Example Project","text":"function trace(n, mat) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: mat (n,n) Return Value real(kind=8) Contents None","tags":"","loc":"proc/trace.html"},{"title":"findword – Example Project","text":"subroutine findword(word, line, found) Arguments Type Intent Optional Attributes Name character :: word character :: line logical :: found Called by proc~~findword~~CalledByGraph proc~findword findword proc~read_force_position_data read_force_position_data proc~read_force_position_data->proc~findword program~fc234 FC234 program~fc234->proc~read_force_position_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/findword.html"},{"title":"findatom_sc – Example Project","text":"subroutine findatom_sc(n3, tau, iatom) Uses geometry ios lattice atoms_force_constants proc~~findatom_sc~~UsesGraph proc~findatom_sc findatom_sc module~geometry geometry proc~findatom_sc->module~geometry module~atoms_force_constants atoms_force_constants proc~findatom_sc->module~atoms_force_constants module~lattice lattice proc~findatom_sc->module~lattice module~ios ios proc~findatom_sc->module~ios module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n3 (3) integer, intent(in) :: tau integer, intent(out) :: iatom Calls proc~~findatom_sc~~CallsGraph proc~findatom_sc findatom_sc dfloat dfloat proc~findatom_sc->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~findatom_sc~~CalledByGraph proc~findatom_sc findatom_sc proc~write_lat_fc write_lat_fc proc~write_lat_fc->proc~findatom_sc proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->proc~findatom_sc proc~write_correspondance write_correspondance proc~write_correspondance->proc~findatom_sc proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->proc~findatom_sc program~fc234 FC234 program~fc234->proc~write_lat_fc program~fc234->proc~write_correspondance2 program~fc234->proc~set_force_displacement_matrix proc~write_output_fc write_output_fc proc~write_output_fc->proc~write_lat_fc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/findatom_sc.html"},{"title":"make_r0g – Example Project","text":"subroutine make_r0g() Uses lattice proc~~make_r0g~~UsesGraph proc~make_r0g make_r0g module~lattice lattice proc~make_r0g->module~lattice module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Called by proc~~make_r0g~~CalledByGraph proc~make_r0g make_r0g program~fc234 FC234 program~fc234->proc~make_r0g Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_r0g.html"},{"title":"check – Example Project","text":"subroutine check(r, a1, a2, a3, ier, g1, g2, g3) Uses geometry ios params proc~~check~~UsesGraph proc~check check module~geometry geometry proc~check->module~geometry module~params params proc~check->module~params module~ios ios proc~check->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: r real(kind=8) :: a1 real(kind=8) :: a2 real(kind=8) :: a3 integer :: ier type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 Called by proc~~check~~CalledByGraph proc~check check proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->proc~check proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->proc~check proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new program~fc234 FC234 program~fc234->proc~identify_atoms_in_supercell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check.html"},{"title":"check_d – Example Project","text":"subroutine check_d(r, a1, a2, a3, ier) Uses geometry ios params proc~~check_d~~UsesGraph proc~check_d check_d module~geometry geometry proc~check_d->module~geometry module~params params proc~check_d->module~params module~ios ios proc~check_d->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: r real(kind=8) :: a1 real(kind=8) :: a2 real(kind=8) :: a3 integer :: ier Contents None","tags":"","loc":"proc/check_d.html"},{"title":"calculate_distance – Example Project","text":"subroutine calculate_distance(i, j, atompos, maxatoms, rij) Arguments Type Intent Optional Attributes Name integer :: i integer :: j real(kind=8) :: atompos (3,maxatoms) integer :: maxatoms real(kind=8) :: rij Called by proc~~calculate_distance~~CalledByGraph proc~calculate_distance calculate_distance proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->proc~calculate_distance program~fc234 FC234 program~fc234->proc~set_neighbor_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_distance.html"},{"title":"sort – Example Project","text":"subroutine sort(n, r, mcor, maxat) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: r (maxat) integer :: mcor (maxat) integer :: maxat Called by proc~~sort~~CalledByGraph proc~sort sort proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->proc~sort proc~make_sorted_gs make_sorted_gs proc~make_sorted_gs->proc~sort program~fc234 FC234 program~fc234->proc~set_neighbor_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sort.html"},{"title":"calculate_volume – Example Project","text":"subroutine calculate_volume(r1, r2, r3, om) Uses geometry proc~~calculate_volume~~UsesGraph proc~calculate_volume calculate_volume module~geometry geometry proc~calculate_volume->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 real(kind=8) :: om Called by proc~~calculate_volume~~CalledByGraph proc~calculate_volume calculate_volume proc~read_crystal read_crystal proc~read_crystal->proc~calculate_volume program~fc234 FC234 program~fc234->proc~read_crystal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calculate_volume.html"},{"title":"make_reciprocal_lattice – Example Project","text":"subroutine make_reciprocal_lattice(r1, r2, r3, g1, g2, g3) Uses geometry ios constants proc~~make_reciprocal_lattice~~UsesGraph proc~make_reciprocal_lattice make_reciprocal_lattice module~constants constants proc~make_reciprocal_lattice->module~constants module~geometry geometry proc~make_reciprocal_lattice->module~geometry module~ios ios proc~make_reciprocal_lattice->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 Called by proc~~make_reciprocal_lattice~~CalledByGraph proc~make_reciprocal_lattice make_reciprocal_lattice program~fc234 FC234 program~fc234->proc~make_reciprocal_lattice proc~read_crystal read_crystal program~fc234->proc~read_crystal proc~get_direct_components get_direct_components proc~get_direct_components->proc~make_reciprocal_lattice proc~read_crystal->proc~make_reciprocal_lattice proc~check_inside_bz check_inside_bz proc~check_inside_bz->proc~get_direct_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_reciprocal_lattice.html"},{"title":"make_reciprocal_lattice_2pi – Example Project","text":"subroutine make_reciprocal_lattice_2pi(r1, r2, r3, g1, g2, g3) Uses geometry ios constants proc~~make_reciprocal_lattice_2pi~~UsesGraph proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi module~constants constants proc~make_reciprocal_lattice_2pi->module~constants module~geometry geometry proc~make_reciprocal_lattice_2pi->module~geometry module~ios ios proc~make_reciprocal_lattice_2pi->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 Calls proc~~make_reciprocal_lattice_2pi~~CallsGraph proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi interface~write_out write_out proc~make_reciprocal_lattice_2pi->interface~write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 3 3 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_reciprocal_lattice_2pi.html"},{"title":"find_root – Example Project","text":"subroutine find_root(fcn, x1, x2, root) Arguments Type Intent Optional Attributes Name real(kind=8) :: fcn real(kind=8) :: x1 real(kind=8) :: x2 real(kind=8) :: root Contents None","tags":"","loc":"proc/find_root.html"},{"title":"check_inside_bz – Example Project","text":"subroutine check_inside_bz(q, g1, g2, g3, inside) Uses geometry proc~~check_inside_bz~~UsesGraph proc~check_inside_bz check_inside_bz module~geometry geometry proc~check_inside_bz->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: q (3) type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 integer :: inside Calls proc~~check_inside_bz~~CallsGraph proc~check_inside_bz check_inside_bz proc~get_direct_components get_direct_components proc~check_inside_bz->proc~get_direct_components proc~make_reciprocal_lattice make_reciprocal_lattice proc~get_direct_components->proc~make_reciprocal_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_inside_bz.html"},{"title":"check_inside_fbz – Example Project","text":"subroutine check_inside_fbz(q, g1, g2, g3, inside) Uses geometry constants proc~~check_inside_fbz~~UsesGraph proc~check_inside_fbz check_inside_fbz module~constants constants proc~check_inside_fbz->module~constants module~geometry geometry proc~check_inside_fbz->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: q (3) type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 logical :: inside Called by proc~~check_inside_fbz~~CalledByGraph proc~check_inside_fbz check_inside_fbz proc~send_to_fbz send_to_fbz proc~send_to_fbz->proc~check_inside_fbz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_inside_fbz.html"},{"title":"check_inside_irred_fbz2 – Example Project","text":"subroutine check_inside_irred_fbz2(k, inside) Uses constants lattice proc~~check_inside_irred_fbz2~~UsesGraph proc~check_inside_irred_fbz2 check_inside_irred_fbz2 module~constants constants proc~check_inside_irred_fbz2->module~constants module~lattice lattice proc~check_inside_irred_fbz2->module~lattice module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: k (3) logical :: inside Called by proc~~check_inside_irred_fbz2~~CalledByGraph proc~check_inside_irred_fbz2 check_inside_irred_fbz2 proc~select_ibz select_IBZ proc~select_ibz->proc~check_inside_irred_fbz2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_inside_irred_fbz2.html"},{"title":"check_inside_irred_fbz – Example Project","text":"subroutine check_inside_irred_fbz(k, inside) Uses constants lattice proc~~check_inside_irred_fbz~~UsesGraph proc~check_inside_irred_fbz check_inside_irred_fbz module~constants constants proc~check_inside_irred_fbz->module~constants module~lattice lattice proc~check_inside_irred_fbz->module~lattice module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: k (3) logical :: inside Contents None","tags":"","loc":"proc/check_inside_irred_fbz.html"},{"title":"select_IBZ – Example Project","text":"subroutine select_IBZ(nbz, kbz, nib, kib) Uses lattice proc~~select_ibz~~UsesGraph proc~select_ibz select_IBZ module~lattice lattice proc~select_ibz->module~lattice module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: nbz real(kind=8) :: kbz (3,nbz) integer :: nib real(kind=8) :: kib (3,nbz) Calls proc~~select_ibz~~CallsGraph proc~select_ibz select_IBZ proc~check_inside_irred_fbz2 check_inside_irred_fbz2 proc~select_ibz->proc~check_inside_irred_fbz2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/select_ibz.html"},{"title":"make_sorted_gs – Example Project","text":"subroutine make_sorted_gs(g1, g2, g3, nshell, gg) Uses geometry proc~~make_sorted_gs~~UsesGraph proc~make_sorted_gs make_sorted_gs module~geometry geometry proc~make_sorted_gs->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 integer :: nshell real(kind=8) :: gg (3,nshell) Calls proc~~make_sorted_gs~~CallsGraph proc~make_sorted_gs make_sorted_gs proc~sort sort proc~make_sorted_gs->proc~sort interface~length length proc~make_sorted_gs->interface~length 9 9 proc~make_sorted_gs->9 proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_sorted_gs.html"},{"title":"get_direct_components – Example Project","text":"subroutine get_direct_components(q, qx, qy, qz, g1, g2, g3, inside) Uses geometry proc~~get_direct_components~~UsesGraph proc~get_direct_components get_direct_components module~geometry geometry proc~get_direct_components->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: q (3) real(kind=8), intent(out) :: qx real(kind=8), intent(out) :: qy real(kind=8), intent(out) :: qz type( vector ), intent(in) :: g1 type( vector ), intent(in) :: g2 type( vector ), intent(in) :: g3 integer, intent(out) :: inside Calls proc~~get_direct_components~~CallsGraph proc~get_direct_components get_direct_components proc~make_reciprocal_lattice make_reciprocal_lattice proc~get_direct_components->proc~make_reciprocal_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_direct_components~~CalledByGraph proc~get_direct_components get_direct_components proc~check_inside_bz check_inside_bz proc~check_inside_bz->proc~get_direct_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_direct_components.html"},{"title":"comp1 – Example Project","text":"subroutine comp1(q, rr, n, i, insid) Uses geometry proc~~comp1~~UsesGraph proc~comp1 comp1 module~geometry geometry proc~comp1->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: q (3) type( vector ) :: rr integer :: n integer :: i integer :: insid Called by proc~~comp1~~CalledByGraph proc~comp1 comp1 proc~get_components_g get_components_g proc~get_components_g->proc~comp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/comp1.html"},{"title":"comp_c – Example Project","text":"subroutine comp_c(q, rr, n, i, insid) Uses geometry proc~~comp_c~~UsesGraph proc~comp_c comp_c module~geometry geometry proc~comp_c->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: q (3) type( vector ) :: rr integer :: n integer :: i integer :: insid Called by proc~~comp_c~~CalledByGraph proc~comp_c comp_c proc~get_components_g_centered get_components_g_centered proc~get_components_g_centered->proc~comp_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/comp_c.html"},{"title":"get_components_g – Example Project","text":"subroutine get_components_g(q, n, i, j, k, inside) Uses geometry lattice proc~~get_components_g~~UsesGraph proc~get_components_g get_components_g module~geometry geometry proc~get_components_g->module~geometry module~lattice lattice proc~get_components_g->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: q (3) integer, intent(in) :: n (3) integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(out) :: inside Calls proc~~get_components_g~~CallsGraph proc~get_components_g get_components_g proc~comp1 comp1 proc~get_components_g->proc~comp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_components_g.html"},{"title":"get_components_g_centered – Example Project","text":"subroutine get_components_g_centered(q, n, i, j, k, inside) Uses geometry lattice proc~~get_components_g_centered~~UsesGraph proc~get_components_g_centered get_components_g_centered module~geometry geometry proc~get_components_g_centered->module~geometry module~lattice lattice proc~get_components_g_centered->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: q (3) integer, intent(in) :: n (3) integer, intent(out) :: i integer, intent(out) :: j integer, intent(out) :: k integer, intent(out) :: inside Calls proc~~get_components_g_centered~~CallsGraph proc~get_components_g_centered get_components_g_centered proc~comp_c comp_c proc~get_components_g_centered->proc~comp_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_components_g_centered.html"},{"title":"set_neighbork – Example Project","text":"subroutine set_neighbork(nkp, kp, nb, nbk, nbmax, kcutoff, nshl, gg) Uses geometry ios lattice proc~~set_neighbork~~UsesGraph proc~set_neighbork set_neighbork module~geometry geometry proc~set_neighbork->module~geometry module~lattice lattice proc~set_neighbork->module~lattice module~ios ios proc~set_neighbork->module~ios module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: nkp real(kind=8) :: kp (3,nkp) integer :: nb (nkp,nbmax) integer :: nbk (nkp) integer :: nbmax real(kind=8) :: kcutoff integer :: nshl real(kind=8) :: gg (3,nshl) Calls proc~~set_neighbork~~CallsGraph proc~set_neighbork set_neighbork 3 3 proc~set_neighbork->3 interface~length length proc~set_neighbork->interface~length 7 7 proc~set_neighbork->7 proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_neighbork.html"},{"title":"send_to_fbz – Example Project","text":"subroutine send_to_fbz(kp, nshl, gg, q, ns) Uses lattice proc~~send_to_fbz~~UsesGraph proc~send_to_fbz send_to_fbz module~lattice lattice proc~send_to_fbz->module~lattice module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. use io2 Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kp (3) integer, intent(in) :: nshl real(kind=8), intent(in) :: gg (3,nshl) real(kind=8), intent(out) :: q (3) integer, intent(out) :: ns Calls proc~~send_to_fbz~~CallsGraph proc~send_to_fbz send_to_fbz proc~check_inside_fbz check_inside_fbz proc~send_to_fbz->proc~check_inside_fbz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/send_to_fbz.html"},{"title":"send_to_primcell – Example Project","text":"subroutine send_to_primcell(kp, q) Uses lattice proc~~send_to_primcell~~UsesGraph proc~send_to_primcell send_to_primcell module~lattice lattice proc~send_to_primcell->module~lattice module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. use io2 Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: kp (3) real(kind=8), intent(out) :: q (3) Contents None","tags":"","loc":"proc/send_to_primcell.html"},{"title":"inverse_real – Example Project","text":"subroutine inverse_real(a, b, n) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) integer :: n Called by proc~~inverse_real~~CalledByGraph proc~inverse_real inverse_real proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~inverse_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inverse_real.html"},{"title":"mean_sd – Example Project","text":"subroutine mean_sd(x, mean, sd) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) real(kind=8) :: mean real(kind=8) :: sd Contents None","tags":"","loc":"proc/mean_sd.html"},{"title":"histogram – Example Project","text":"subroutine histogram(m, x, mesh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m real(kind=8), intent(in) :: x (m) integer, intent(in) :: mesh Calls proc~~histogram~~CallsGraph proc~histogram histogram 9 9 proc~histogram->9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/histogram.html"},{"title":"pythag2 – Example Project","text":"function pythag2(a, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b Return Value real(kind=8) Contents None","tags":"","loc":"proc/pythag2.html"},{"title":"svd_set – Example Project","text":"subroutine svd_set(m3, n, a, b, x, sig, svdcut, error, ermax, sigma, fnsvd) Arguments Type Intent Optional Attributes Name integer :: m3 integer :: n real(kind=8), intent(in) :: a (m3,n) real(kind=8), intent(in) :: b (m3) real(kind=8), intent(out) :: x (n) real(kind=8), intent(out) :: sig (n) real(kind=8) :: svdcut real(kind=8), intent(out) :: error real(kind=8), intent(out) :: ermax real(kind=8) :: sigma character :: fnsvd Calls proc~~svd_set~~CallsGraph proc~svd_set svd_set proc~svdcmp svdcmp proc~svd_set->proc~svdcmp proc~svbksb svbksb proc~svd_set->proc~svbksb 99 99 proc~svd_set->99 3 3 proc~svd_set->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~svd_set~~CalledByGraph proc~svd_set svd_set proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~svd_set program~fc234 FC234 program~fc234->proc~svd_set Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/svd_set.html"},{"title":"svdcmp – Example Project","text":"subroutine svdcmp(a, m, n, mp, np, w, v) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (mp,np) integer :: m integer :: n integer :: mp integer :: np real(kind=8) :: w (np) real(kind=8) :: v (np,np) Called by proc~~svdcmp~~CalledByGraph proc~svdcmp svdcmp proc~svd_set svd_set proc~svd_set->proc~svdcmp proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~svd_set program~fc234 FC234 program~fc234->proc~svd_set Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/svdcmp.html"},{"title":"svbksb – Example Project","text":"subroutine svbksb(u, w, v, m, n, mp, np, b, x) Arguments Type Intent Optional Attributes Name real(kind=8) :: u (mp,np) real(kind=8) :: w (np) real(kind=8) :: v (np,np) integer :: m integer :: n integer :: mp integer :: np real(kind=8) :: b (mp) real(kind=8) :: x (np) Called by proc~~svbksb~~CalledByGraph proc~svbksb svbksb proc~svd_set svd_set proc~svd_set->proc~svbksb proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~svd_set program~fc234 FC234 program~fc234->proc~svd_set Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/svbksb.html"},{"title":"bring_to_prim_cell_cav – Example Project","text":"function bring_to_prim_cell_cav(a) result(w) Uses geometry lattice proc~~bring_to_prim_cell_cav~~UsesGraph proc~bring_to_prim_cell_cav bring_to_prim_cell_cav module~geometry geometry proc~bring_to_prim_cell_cav->module~geometry module~lattice lattice proc~bring_to_prim_cell_cav->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector ) Contents None","tags":"","loc":"proc/bring_to_prim_cell_cav.html"},{"title":"bring_to_super_cell_cav – Example Project","text":"function bring_to_super_cell_cav(a) result(w) Uses geometry lattice proc~~bring_to_super_cell_cav~~UsesGraph proc~bring_to_super_cell_cav bring_to_super_cell_cav module~geometry geometry proc~bring_to_super_cell_cav->module~geometry module~lattice lattice proc~bring_to_super_cell_cav->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector ) Contents None","tags":"","loc":"proc/bring_to_super_cell_cav.html"},{"title":"bring_to_prim_cell_caa – Example Project","text":"function bring_to_prim_cell_caa(a) result(b) Uses geometry lattice proc~~bring_to_prim_cell_caa~~UsesGraph proc~bring_to_prim_cell_caa bring_to_prim_cell_caa module~geometry geometry proc~bring_to_prim_cell_caa->module~geometry module~lattice lattice proc~bring_to_prim_cell_caa->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value real(kind=8)(3) Contents None","tags":"","loc":"proc/bring_to_prim_cell_caa.html"},{"title":"bring_to_super_cell_caa – Example Project","text":"function bring_to_super_cell_caa(a) result(b) Uses geometry lattice proc~~bring_to_super_cell_caa~~UsesGraph proc~bring_to_super_cell_caa bring_to_super_cell_caa module~geometry geometry proc~bring_to_super_cell_caa->module~geometry module~lattice lattice proc~bring_to_super_cell_caa->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value real(kind=8)(3) Contents None","tags":"","loc":"proc/bring_to_super_cell_caa.html"},{"title":"bring_to_prim_cell_cv – Example Project","text":"function bring_to_prim_cell_cv(v) result(w) Uses geometry lattice proc~~bring_to_prim_cell_cv~~UsesGraph proc~bring_to_prim_cell_cv bring_to_prim_cell_cv module~geometry geometry proc~bring_to_prim_cell_cv->module~geometry module~lattice lattice proc~bring_to_prim_cell_cv->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) Contents None","tags":"","loc":"proc/bring_to_prim_cell_cv.html"},{"title":"bring_to_super_cell_cv – Example Project","text":"function bring_to_super_cell_cv(v) result(w) Uses geometry lattice proc~~bring_to_super_cell_cv~~UsesGraph proc~bring_to_super_cell_cv bring_to_super_cell_cv module~geometry geometry proc~bring_to_super_cell_cv->module~geometry module~lattice lattice proc~bring_to_super_cell_cv->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) Contents None","tags":"","loc":"proc/bring_to_super_cell_cv.html"},{"title":"cart_to_direct_v – Example Project","text":"subroutine cart_to_direct_v(v, w) Uses geometry lattice proc~~cart_to_direct_v~~UsesGraph proc~cart_to_direct_v cart_to_direct_v module~geometry geometry proc~cart_to_direct_v->module~geometry module~lattice lattice proc~cart_to_direct_v->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: w Called by proc~~cart_to_direct_v~~CalledByGraph proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_av cart_to_direct_av proc~cart_to_direct_av->proc~cart_to_direct_v proc~cart_to_direct_aa cart_to_direct_aa proc~cart_to_direct_aa->proc~cart_to_direct_v proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->proc~cart_to_direct_aa proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->proc~cart_to_direct_aa program~fc234 FC234 program~fc234->proc~calculate_and_write_displacements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cart_to_direct_v.html"},{"title":"cart_to_direct_av – Example Project","text":"subroutine cart_to_direct_av(a, w) Uses geometry lattice proc~~cart_to_direct_av~~UsesGraph proc~cart_to_direct_av cart_to_direct_av module~geometry geometry proc~cart_to_direct_av->module~geometry module~lattice lattice proc~cart_to_direct_av->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: w Calls proc~~cart_to_direct_av~~CallsGraph proc~cart_to_direct_av cart_to_direct_av proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_av->proc~cart_to_direct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cart_to_direct_av.html"},{"title":"cart_to_direct_aa – Example Project","text":"subroutine cart_to_direct_aa(a, b) Uses geometry lattice proc~~cart_to_direct_aa~~UsesGraph proc~cart_to_direct_aa cart_to_direct_aa module~geometry geometry proc~cart_to_direct_aa->module~geometry module~lattice lattice proc~cart_to_direct_aa->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) real(kind=8) :: b (3) Calls proc~~cart_to_direct_aa~~CallsGraph proc~cart_to_direct_aa cart_to_direct_aa proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_aa->proc~cart_to_direct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cart_to_direct_aa~~CalledByGraph proc~cart_to_direct_aa cart_to_direct_aa proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->proc~cart_to_direct_aa proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->proc~cart_to_direct_aa program~fc234 FC234 program~fc234->proc~calculate_and_write_displacements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cart_to_direct_aa.html"},{"title":"direct_to_cart_v – Example Project","text":"subroutine direct_to_cart_v(v, w) Uses geometry lattice proc~~direct_to_cart_v~~UsesGraph proc~direct_to_cart_v direct_to_cart_v module~geometry geometry proc~direct_to_cart_v->module~geometry module~lattice lattice proc~direct_to_cart_v->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: w Called by proc~~direct_to_cart_v~~CalledByGraph proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_aa direct_to_cart_aa proc~direct_to_cart_aa->proc~direct_to_cart_v proc~direct_to_cart_av direct_to_cart_av proc~direct_to_cart_av->proc~direct_to_cart_v proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->proc~direct_to_cart_aa proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->proc~direct_to_cart_aa program~fc234 FC234 program~fc234->proc~calculate_and_write_displacements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/direct_to_cart_v.html"},{"title":"direct_to_cart_av – Example Project","text":"subroutine direct_to_cart_av(a, w) Uses geometry lattice proc~~direct_to_cart_av~~UsesGraph proc~direct_to_cart_av direct_to_cart_av module~geometry geometry proc~direct_to_cart_av->module~geometry module~lattice lattice proc~direct_to_cart_av->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: w Calls proc~~direct_to_cart_av~~CallsGraph proc~direct_to_cart_av direct_to_cart_av proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_av->proc~direct_to_cart_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/direct_to_cart_av.html"},{"title":"direct_to_cart_aa – Example Project","text":"subroutine direct_to_cart_aa(a, b) Uses geometry lattice proc~~direct_to_cart_aa~~UsesGraph proc~direct_to_cart_aa direct_to_cart_aa module~geometry geometry proc~direct_to_cart_aa->module~geometry module~lattice lattice proc~direct_to_cart_aa->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) real(kind=8) :: b (3) Calls proc~~direct_to_cart_aa~~CallsGraph proc~direct_to_cart_aa direct_to_cart_aa proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_aa->proc~direct_to_cart_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~direct_to_cart_aa~~CalledByGraph proc~direct_to_cart_aa direct_to_cart_aa proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->proc~direct_to_cart_aa proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->proc~direct_to_cart_aa program~fc234 FC234 program~fc234->proc~calculate_and_write_displacements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/direct_to_cart_aa.html"},{"title":"dir2cart_g – Example Project","text":"subroutine dir2cart_g(q, k) Uses geometry lattice proc~~dir2cart_g~~UsesGraph proc~dir2cart_g dir2cart_g module~geometry geometry proc~dir2cart_g->module~geometry module~lattice lattice proc~dir2cart_g->module~lattice module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: q (3) real(kind=8) :: k (3) Contents None","tags":"","loc":"proc/dir2cart_g.html"},{"title":"voigt – Example Project","text":"function voigt(i, j) Arguments Type Intent Optional Attributes Name integer :: i integer :: j Return Value integer Contents None","tags":"","loc":"proc/voigt.html"},{"title":"set_translational_inv_constraints – Example Project","text":"subroutine set_translational_inv_constraints() Uses geometry svd_stuff ios force_constants_module params atoms_force_constants proc~~set_translational_inv_constraints~~UsesGraph proc~set_translational_inv_constraints set_translational_inv_constraints module~svd_stuff svd_stuff proc~set_translational_inv_constraints->module~svd_stuff module~force_constants_module force_constants_module proc~set_translational_inv_constraints->module~force_constants_module module~geometry geometry proc~set_translational_inv_constraints->module~geometry module~atoms_force_constants atoms_force_constants proc~set_translational_inv_constraints->module~atoms_force_constants module~ios ios proc~set_translational_inv_constraints->module~ios module~params params proc~set_translational_inv_constraints->module~params module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. sets the translational invariance part of the amatrx Arguments None Calls proc~~set_translational_inv_constraints~~CallsGraph proc~set_translational_inv_constraints set_translational_inv_constraints interface~length length proc~set_translational_inv_constraints->interface~length proc~compare2previous_lines compare2previous_lines proc~set_translational_inv_constraints->proc~compare2previous_lines interface~write_out write_out proc~set_translational_inv_constraints->interface~write_out proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha 99 99 proc~compare2previous_lines->99 proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 3 3 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_translational_inv_constraints~~CalledByGraph proc~set_translational_inv_constraints set_translational_inv_constraints program~fc234 FC234 program~fc234->proc~set_translational_inv_constraints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_translational_inv_constraints.html"},{"title":"set_rotational_inv_constraints – Example Project","text":"subroutine set_rotational_inv_constraints() Uses geometry svd_stuff ios force_constants_module params atoms_force_constants proc~~set_rotational_inv_constraints~~UsesGraph proc~set_rotational_inv_constraints set_rotational_inv_constraints module~svd_stuff svd_stuff proc~set_rotational_inv_constraints->module~svd_stuff module~force_constants_module force_constants_module proc~set_rotational_inv_constraints->module~force_constants_module module~geometry geometry proc~set_rotational_inv_constraints->module~geometry module~atoms_force_constants atoms_force_constants proc~set_rotational_inv_constraints->module~atoms_force_constants module~ios ios proc~set_rotational_inv_constraints->module~ios module~params params proc~set_rotational_inv_constraints->module~params module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. sets the rotational invariance part of the amatrx Arguments None Calls proc~~set_rotational_inv_constraints~~CallsGraph proc~set_rotational_inv_constraints set_rotational_inv_constraints 66 66 proc~set_rotational_inv_constraints->66 4 4 proc~set_rotational_inv_constraints->4 proc~compare2previous_lines compare2previous_lines proc~set_rotational_inv_constraints->proc~compare2previous_lines 99 99 proc~compare2previous_lines->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_rotational_inv_constraints~~CalledByGraph proc~set_rotational_inv_constraints set_rotational_inv_constraints program~fc234 FC234 program~fc234->proc~set_rotational_inv_constraints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_rotational_inv_constraints.html"},{"title":"set_force_displacement_matrix – Example Project","text":"subroutine set_force_displacement_matrix(frc_constr, afrc, bfrc) Uses geometry svd_stuff ios force_constants_module params atoms_force_constants proc~~set_force_displacement_matrix~~UsesGraph proc~set_force_displacement_matrix set_force_displacement_matrix module~svd_stuff svd_stuff proc~set_force_displacement_matrix->module~svd_stuff module~force_constants_module force_constants_module proc~set_force_displacement_matrix->module~force_constants_module module~geometry geometry proc~set_force_displacement_matrix->module~geometry module~atoms_force_constants atoms_force_constants proc~set_force_displacement_matrix->module~atoms_force_constants module~ios ios proc~set_force_displacement_matrix->module~ios module~params params proc~set_force_displacement_matrix->module~params module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: frc_constr real(kind=8) :: afrc (frc_constr,ngr) real(kind=8) :: bfrc (frc_constr) Calls proc~~set_force_displacement_matrix~~CallsGraph proc~set_force_displacement_matrix set_force_displacement_matrix proc~findatom_sc findatom_sc proc~set_force_displacement_matrix->proc~findatom_sc 66 66 proc~set_force_displacement_matrix->66 4 4 proc~set_force_displacement_matrix->4 3 3 proc~set_force_displacement_matrix->3 dfloat dfloat proc~findatom_sc->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_force_displacement_matrix~~CalledByGraph proc~set_force_displacement_matrix set_force_displacement_matrix program~fc234 FC234 program~fc234->proc~set_force_displacement_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_force_displacement_matrix.html"},{"title":"setup_maps – Example Project","text":"subroutine setup_maps() Uses geometry svd_stuff ios params atoms_force_constants proc~~setup_maps~~UsesGraph proc~setup_maps setup_maps module~svd_stuff svd_stuff proc~setup_maps->module~svd_stuff module~geometry geometry proc~setup_maps->module~geometry module~atoms_force_constants atoms_force_constants proc~setup_maps->module~atoms_force_constants module~ios ios proc~setup_maps->module~ios module~params params proc~setup_maps->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. maps the output of collect_fcs to the new arrays for each rank,\nwith the proper (allocatable) dimensions Arguments None Calls proc~~setup_maps~~CallsGraph proc~setup_maps setup_maps 9 9 proc~setup_maps->9 proc~ustring ustring proc~setup_maps->proc~ustring proc~get_dim get_dim proc~setup_maps->proc~get_dim proc~read_fcs_2 read_fcs_2 proc~setup_maps->proc~read_fcs_2 proc~collect_force_constants collect_force_constants proc~setup_maps->proc~collect_force_constants interface~write_out write_out proc~setup_maps->interface~write_out proc~force_constants force_constants proc~collect_force_constants->proc~force_constants proc~findatom findatom proc~collect_force_constants->proc~findatom proc~unique_force_constant unique_force_constant proc~collect_force_constants->proc~unique_force_constant 99 99 proc~collect_force_constants->99 proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr proc~write_outim->99 proc~write_outrm->99 proc~force_constants->proc~findatom proc~force_constants->proc~unique_force_constant proc~xrowop2 xrowop2 proc~force_constants->proc~xrowop2 proc~xvmlt xvmlt proc~force_constants->proc~xvmlt proc~permutations permutations proc~force_constants->proc~permutations proc~findatom2 findatom2 proc~force_constants->proc~findatom2 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 proc~unique_force_constant->proc~findatom 3 3 proc~write_outv->3 proc~write_outr->99 proc~bomb bomb proc~permutations->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_maps~~CalledByGraph proc~setup_maps setup_maps program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_maps.html"},{"title":"include_constraints – Example Project","text":"subroutine include_constraints() Uses svd_stuff ios params proc~~include_constraints~~UsesGraph proc~include_constraints include_constraints module~svd_stuff svd_stuff proc~include_constraints->module~svd_stuff module~params params proc~include_constraints->module~params module~ios ios proc~include_constraints->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. now that we have the 3 matrices atransl,arot,ahuang and aforce, here we decide\nhow to put them together to do the SVD\noutputs are amat and bmat and their dimensions:dim_al,dim_ac, which go to SVD Arguments None Called by proc~~include_constraints~~CalledByGraph proc~include_constraints include_constraints program~fc234 FC234 program~fc234->proc~include_constraints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/include_constraints.html"},{"title":"homogeneous_constraints_overlap – Example Project","text":"subroutine homogeneous_constraints_overlap(n_constr) Uses svd_stuff ios params proc~~homogeneous_constraints_overlap~~UsesGraph proc~homogeneous_constraints_overlap homogeneous_constraints_overlap module~svd_stuff svd_stuff proc~homogeneous_constraints_overlap->module~svd_stuff module~params params proc~homogeneous_constraints_overlap->module~params module~ios ios proc~homogeneous_constraints_overlap->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: n_constr Contents None","tags":"","loc":"proc/homogeneous_constraints_overlap.html"},{"title":"estimate_inv_constraints – Example Project","text":"subroutine estimate_inv_constraints() Uses geometry svd_stuff ios params atoms_force_constants proc~~estimate_inv_constraints~~UsesGraph proc~estimate_inv_constraints estimate_inv_constraints module~svd_stuff svd_stuff proc~estimate_inv_constraints->module~svd_stuff module~geometry geometry proc~estimate_inv_constraints->module~geometry module~atoms_force_constants atoms_force_constants proc~estimate_inv_constraints->module~atoms_force_constants module~ios ios proc~estimate_inv_constraints->module~ios module~params params proc~estimate_inv_constraints->module~params module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Contents None","tags":"","loc":"proc/estimate_inv_constraints.html"},{"title":"get_dim – Example Project","text":"subroutine get_dim(mapd, ndimindep, ndimfull) Uses svd_stuff proc~~get_dim~~UsesGraph proc~get_dim get_dim module~svd_stuff svd_stuff proc~get_dim->module~svd_stuff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. calculate the number of in/dependent fcs for all groups to fillup map%ntot and %ntotind Arguments Type Intent Optional Attributes Name type( fulldmatrix ) :: mapd integer :: ndimindep integer :: ndimfull Called by proc~~get_dim~~CalledByGraph proc~get_dim get_dim proc~setup_maps setup_maps proc~setup_maps->proc~get_dim program~fc234 FC234 program~fc234->proc~setup_maps Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_dim.html"},{"title":"check_zero_column – Example Project","text":"subroutine check_zero_column(line, col, afrc) Uses svd_stuff ios params proc~~check_zero_column~~UsesGraph proc~check_zero_column check_zero_column module~svd_stuff svd_stuff proc~check_zero_column->module~svd_stuff module~params params proc~check_zero_column->module~params module~ios ios proc~check_zero_column->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. check if there is any column that is zero (the corresponding FC can not be extracted) Arguments Type Intent Optional Attributes Name integer :: line integer :: col real(kind=8) :: afrc (line,col) Calls proc~~check_zero_column~~CallsGraph proc~check_zero_column check_zero_column proc~warn warn proc~check_zero_column->proc~warn proc~find_t find_t proc~check_zero_column->proc~find_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_zero_column~~CalledByGraph proc~check_zero_column check_zero_column program~fc234 FC234 program~fc234->proc~check_zero_column Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_zero_column.html"},{"title":"find_t – Example Project","text":"subroutine find_t(t, rnk, nti) Uses svd_stuff ios proc~~find_t~~UsesGraph proc~find_t find_t module~svd_stuff svd_stuff proc~find_t->module~svd_stuff module~ios ios proc~find_t->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. for a given t in {1,...,ngr} find its corresponding rank and ntindp number nti Arguments Type Intent Optional Attributes Name integer, intent(in) :: t integer, intent(out) :: rnk integer, intent(out) :: nti Called by proc~~find_t~~CalledByGraph proc~find_t find_t proc~check_zero_column check_zero_column proc~check_zero_column->proc~find_t program~fc234 FC234 program~fc234->proc~check_zero_column Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_t.html"},{"title":"compare2previous_lines – Example Project","text":"subroutine compare2previous_lines(m, n, a1d, a, counter, new) Uses geometry ios params proc~~compare2previous_lines~~UsesGraph proc~compare2previous_lines compare2previous_lines module~geometry geometry proc~compare2previous_lines->module~geometry module~params params proc~compare2previous_lines->module~params module~ios ios proc~compare2previous_lines->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=8), dimension(n) :: a1d real(kind=8), dimension(m,n) :: a integer :: counter logical :: new Calls proc~~compare2previous_lines~~CallsGraph proc~compare2previous_lines compare2previous_lines 99 99 proc~compare2previous_lines->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~compare2previous_lines~~CalledByGraph proc~compare2previous_lines compare2previous_lines proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->proc~compare2previous_lines proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->proc~compare2previous_lines program~fc234 FC234 program~fc234->proc~set_rotational_inv_constraints program~fc234->proc~set_translational_inv_constraints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/compare2previous_lines.html"},{"title":"set_huang_inv_constraints – Example Project","text":"subroutine set_huang_inv_constraints() Uses svd_stuff ios force_constants_module params atoms_force_constants proc~~set_huang_inv_constraints~~UsesGraph proc~set_huang_inv_constraints set_huang_inv_constraints module~svd_stuff svd_stuff proc~set_huang_inv_constraints->module~svd_stuff module~force_constants_module force_constants_module proc~set_huang_inv_constraints->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~set_huang_inv_constraints->module~atoms_force_constants module~ios ios proc~set_huang_inv_constraints->module~ios module~params params proc~set_huang_inv_constraints->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~set_huang_inv_constraints~~CallsGraph proc~set_huang_inv_constraints set_huang_inv_constraints 9 9 proc~set_huang_inv_constraints->9 8 8 proc~set_huang_inv_constraints->8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_huang_inv_constraints~~CalledByGraph proc~set_huang_inv_constraints set_huang_inv_constraints program~fc234 FC234 program~fc234->proc~set_huang_inv_constraints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_huang_inv_constraints.html"},{"title":"check_huang – Example Project","text":"subroutine check_huang() Uses svd_stuff ios force_constants_module params atoms_force_constants proc~~check_huang~~UsesGraph proc~check_huang check_huang module~svd_stuff svd_stuff proc~check_huang->module~svd_stuff module~force_constants_module force_constants_module proc~check_huang->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~check_huang->module~atoms_force_constants module~ios ios proc~check_huang->module~ios module~params params proc~check_huang->module~params module~atoms_force_constants->module~force_constants_module module~geometry geometry module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~check_huang~~CallsGraph proc~check_huang check_huang 9 9 proc~check_huang->9 8 8 proc~check_huang->8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_huang~~CalledByGraph proc~check_huang check_huang proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->proc~check_huang Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_huang.html"},{"title":"truncate – Example Project","text":"subroutine truncate(n, ws, n_kept) find a gap in the ws and drop the small ws values Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: ws (n) integer :: n_kept Calls proc~~truncate~~CallsGraph proc~truncate truncate 9 9 proc~truncate->9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/truncate.html"},{"title":"remove_zeros – Example Project","text":"subroutine remove_zeros(nl, nc, amatr, bmatr, j) Uses svd_stuff ios params proc~~remove_zeros~~UsesGraph proc~remove_zeros remove_zeros module~svd_stuff svd_stuff proc~remove_zeros->module~svd_stuff module~params params proc~remove_zeros->module~params module~ios ios proc~remove_zeros->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: nl integer :: nc real(kind=8) :: amatr (nl,nc) real(kind=8) :: bmatr (nl) integer :: j Calls proc~~remove_zeros~~CallsGraph proc~remove_zeros remove_zeros 4 4 proc~remove_zeros->4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~remove_zeros~~CalledByGraph proc~remove_zeros remove_zeros program~fc234 FC234 program~fc234->proc~remove_zeros Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/remove_zeros.html"},{"title":"eliminate_fcs – Example Project","text":"subroutine eliminate_fcs(sig) Uses svd_stuff ios params proc~~eliminate_fcs~~UsesGraph proc~eliminate_fcs eliminate_fcs module~svd_stuff svd_stuff proc~eliminate_fcs->module~svd_stuff module~params params proc~eliminate_fcs->module~params module~ios ios proc~eliminate_fcs->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: sig Calls proc~~eliminate_fcs~~CallsGraph proc~eliminate_fcs eliminate_fcs proc~invsort invsort proc~eliminate_fcs->proc~invsort proc~svd_set svd_set proc~eliminate_fcs->proc~svd_set proc~inverse_real inverse_real proc~eliminate_fcs->proc~inverse_real proc~write_output_fc2 write_output_fc2 proc~eliminate_fcs->proc~write_output_fc2 proc~write_independent_fcs write_independent_fcs proc~eliminate_fcs->proc~write_independent_fcs 3 3 proc~svd_set->3 proc~svbksb svbksb proc~svd_set->proc~svbksb proc~svdcmp svdcmp proc~svd_set->proc~svdcmp 99 99 proc~svd_set->99 interface~length length proc~write_output_fc2->interface~length proc~write_output_fc2->3 2 2 proc~write_output_fc2->2 4 4 proc~write_output_fc2->4 9 9 proc~write_independent_fcs->9 proc~write_independent_fcs->3 proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eliminate_fcs.html"},{"title":"invsort – Example Project","text":"subroutine invsort(n, r, mcor) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: r (n) integer :: mcor (n) Called by proc~~invsort~~CalledByGraph proc~invsort invsort proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~invsort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/invsort.html"},{"title":"allocate_eiqr2 – Example Project","text":"public subroutine allocate_eiqr2(num1, num2) Arguments Type Intent Optional Attributes Name integer :: num1 integer :: num2 Contents None","tags":"","loc":"proc/allocate_eiqr2.html"},{"title":"allocate_eivec2 – Example Project","text":"public subroutine allocate_eivec2(num1, num3, num4) Arguments Type Intent Optional Attributes Name integer :: num1 integer :: num3 integer :: num4 Contents None","tags":"","loc":"proc/allocate_eivec2.html"},{"title":"deallocate_eiqr2 – Example Project","text":"public subroutine deallocate_eiqr2() Arguments None Contents None","tags":"","loc":"proc/deallocate_eiqr2.html"},{"title":"deallocate_eivec2 – Example Project","text":"public subroutine deallocate_eivec2() Arguments None Contents None","tags":"","loc":"proc/deallocate_eivec2.html"},{"title":"allocate_ksubset2 – Example Project","text":"public subroutine allocate_ksubset2(num) Arguments Type Intent Optional Attributes Name integer :: num Contents None","tags":"","loc":"proc/allocate_ksubset2.html"},{"title":"deallocate_ksubset2 – Example Project","text":"public subroutine deallocate_ksubset2() Arguments None Contents None","tags":"","loc":"proc/deallocate_ksubset2.html"},{"title":"allocate_v33_sy – Example Project","text":"public subroutine allocate_v33_sy(n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 Contents None","tags":"","loc":"proc/allocate_v33_sy.html"},{"title":"deallocate_v33_sy – Example Project","text":"public subroutine deallocate_v33_sy() Arguments None Contents None","tags":"","loc":"proc/deallocate_v33_sy.html"},{"title":"allocate_v33_sq – Example Project","text":"public subroutine allocate_v33_sq(n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 Contents None","tags":"","loc":"proc/allocate_v33_sq.html"},{"title":"deallocate_v33_sq – Example Project","text":"public subroutine deallocate_v33_sq() Arguments None Contents None","tags":"","loc":"proc/deallocate_v33_sq.html"},{"title":"allocate_phi3_sy – Example Project","text":"public subroutine allocate_phi3_sy(nk, nl, ni) Arguments Type Intent Optional Attributes Name integer :: nk integer :: nl integer :: ni Contents None","tags":"","loc":"proc/allocate_phi3_sy.html"},{"title":"allocate_iter_kap – Example Project","text":"public subroutine allocate_iter_kap(nk, ndn) Arguments Type Intent Optional Attributes Name integer :: nk integer :: ndn Contents None","tags":"","loc":"proc/allocate_iter_kap.html"},{"title":"allocate_iter0 – Example Project","text":"public subroutine allocate_iter0(ni, nk, ndn) Arguments Type Intent Optional Attributes Name integer :: ni integer :: nk integer :: ndn Contents None","tags":"","loc":"proc/allocate_iter0.html"},{"title":"allocate_iter1 – Example Project","text":"public subroutine allocate_iter1(ni, nk, ndn) Arguments Type Intent Optional Attributes Name integer :: ni integer :: nk integer :: ndn Contents None","tags":"","loc":"proc/allocate_iter1.html"},{"title":"allocate_iter2 – Example Project","text":"public subroutine allocate_iter2(n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 Contents None","tags":"","loc":"proc/allocate_iter2.html"},{"title":"deallocate_iter_kap – Example Project","text":"public subroutine deallocate_iter_kap() Arguments None Contents None","tags":"","loc":"proc/deallocate_iter_kap.html"},{"title":"deallocate_iter0 – Example Project","text":"public subroutine deallocate_iter0() Arguments None Contents None","tags":"","loc":"proc/deallocate_iter0.html"},{"title":"deallocate_iter1 – Example Project","text":"public subroutine deallocate_iter1() Arguments None Contents None","tags":"","loc":"proc/deallocate_iter1.html"},{"title":"deallocate_iter2 – Example Project","text":"public subroutine deallocate_iter2() Arguments None Contents None","tags":"","loc":"proc/deallocate_iter2.html"},{"title":"crossproduct_v – Example Project","text":"public function crossproduct_v(v, w) result(cross) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) Called by proc~~crossproduct_v~~CalledByGraph proc~crossproduct_v crossproduct_v interface~operator(.cross.) operator(.cross.) interface~operator(.cross.)->proc~crossproduct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/crossproduct_v.html"},{"title":"crossproduct_a – Example Project","text":"public function crossproduct_a(v, w) result(cross) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) real(kind=8), intent(in) :: w (3) Return Value real(kind=8)(3) Called by proc~~crossproduct_a~~CalledByGraph proc~crossproduct_a crossproduct_a interface~operator(.cross.) operator(.cross.) interface~operator(.cross.)->proc~crossproduct_a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/crossproduct_a.html"},{"title":"dotproduct_v – Example Project","text":"public function dotproduct_v(v, w) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value real(kind=8) Called by proc~~dotproduct_v~~CalledByGraph proc~dotproduct_v dotproduct_v interface~operator(.dot.) operator(.dot.) interface~operator(.dot.)->proc~dotproduct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dotproduct_v.html"},{"title":"dotproduct_a – Example Project","text":"public function dotproduct_a(v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(in) :: w (:) Return Value real(kind=8) Called by proc~~dotproduct_a~~CalledByGraph proc~dotproduct_a dotproduct_a interface~operator(.dot.) operator(.dot.) interface~operator(.dot.)->proc~dotproduct_a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dotproduct_a.html"},{"title":"dotproduct_av – Example Project","text":"public function dotproduct_av(v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) type( vector ), intent(in) :: w Return Value real(kind=8) Called by proc~~dotproduct_av~~CalledByGraph proc~dotproduct_av dotproduct_av interface~operator(.dot.) operator(.dot.) interface~operator(.dot.)->proc~dotproduct_av Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dotproduct_av.html"},{"title":"dotproduct_va – Example Project","text":"public function dotproduct_va(w, v) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: w real(kind=8), intent(in) :: v (3) Return Value real(kind=8) Called by proc~~dotproduct_va~~CalledByGraph proc~dotproduct_va dotproduct_va interface~operator(.dot.) operator(.dot.) interface~operator(.dot.)->proc~dotproduct_va Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dotproduct_va.html"},{"title":"myequal0 – Example Project","text":"public function myequal0(v, w) result(eq) Uses params proc~~myequal0~~UsesGraph proc~myequal0 myequal0 module~params params proc~myequal0->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical Called by proc~~myequal0~~CalledByGraph proc~myequal0 myequal0 proc~myequal0array myequal0array proc~myequal0array->proc~myequal0 interface~operator(.myeqz.) operator(.myeqz.) interface~operator(.myeqz.)->proc~myequal0 interface~operator(.myeqz.)->proc~myequal0array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequal0.html"},{"title":"myequal – Example Project","text":"public function myequal(v, w) result(eq) Uses params proc~~myequal~~UsesGraph proc~myequal myequal module~params params proc~myequal->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical Called by proc~~myequal~~CalledByGraph proc~myequal myequal proc~myequalarray myequalarray proc~myequalarray->proc~myequal interface~operator(.myeq.) operator(.myeq.) interface~operator(.myeq.)->proc~myequal interface~operator(.myeq.)->proc~myequalarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequal.html"},{"title":"myequal0vector – Example Project","text":"public function myequal0vector(v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical Called by proc~~myequal0vector~~CalledByGraph proc~myequal0vector myequal0vector interface~operator(.myeqz.) operator(.myeqz.) interface~operator(.myeqz.)->proc~myequal0vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequal0vector.html"},{"title":"myequalvector – Example Project","text":"public function myequalvector(v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical Called by proc~~myequalvector~~CalledByGraph proc~myequalvector myequalvector interface~operator(.myeq.) operator(.myeq.) interface~operator(.myeq.)->proc~myequalvector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequalvector.html"},{"title":"myequal0array – Example Project","text":"public function myequal0array(v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical Calls proc~~myequal0array~~CallsGraph proc~myequal0array myequal0array proc~myequal0 myequal0 proc~myequal0array->proc~myequal0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~myequal0array~~CalledByGraph proc~myequal0array myequal0array interface~operator(.myeqz.) operator(.myeqz.) interface~operator(.myeqz.)->proc~myequal0array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequal0array.html"},{"title":"myequalarray – Example Project","text":"public function myequalarray(v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical Calls proc~~myequalarray~~CallsGraph proc~myequalarray myequalarray proc~myequal myequal proc~myequalarray->proc~myequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~myequalarray~~CalledByGraph proc~myequalarray myequalarray interface~operator(.myeq.) operator(.myeq.) interface~operator(.myeq.)->proc~myequalarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/myequalarray.html"},{"title":"addition – Example Project","text":"public function addition(v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) Called by proc~~addition~~CalledByGraph proc~addition addition interface~operator(+) operator(+) interface~operator(+)->proc~addition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addition.html"},{"title":"addition_vav – Example Project","text":"public function addition_vav(v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) Called by proc~~addition_vav~~CalledByGraph proc~addition_vav addition_vav interface~operator(+) operator(+) interface~operator(+)->proc~addition_vav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addition_vav.html"},{"title":"addition_avv – Example Project","text":"public function addition_avv(w, v) result(add) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) Called by proc~~addition_avv~~CalledByGraph proc~addition_avv addition_avv interface~operator(+) operator(+) interface~operator(+)->proc~addition_avv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addition_avv.html"},{"title":"subtraction – Example Project","text":"public function subtraction(v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) Called by proc~~subtraction~~CalledByGraph proc~subtraction subtraction interface~operator(-) operator(-) interface~operator(-)->proc~subtraction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtraction.html"},{"title":"subtraction_va – Example Project","text":"public function subtraction_va(v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) Called by proc~~subtraction_va~~CalledByGraph proc~subtraction_va subtraction_va interface~operator(-) operator(-) interface~operator(-)->proc~subtraction_va Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtraction_va.html"},{"title":"subtraction_av – Example Project","text":"public function subtraction_av(w, v) result(dif) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) Called by proc~~subtraction_av~~CalledByGraph proc~subtraction_av subtraction_av interface~operator(-) operator(-) interface~operator(-)->proc~subtraction_av Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtraction_av.html"},{"title":"multiply_by_integer – Example Project","text":"public function multiply_by_integer(s, v) result(sv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) Called by proc~~multiply_by_integer~~CalledByGraph proc~multiply_by_integer multiply_by_integer interface~operator(ASTERISK) operator(*) interface~operator(ASTERISK)->proc~multiply_by_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiply_by_integer.html"},{"title":"multiply_by_real – Example Project","text":"public function multiply_by_real(s, v) result(sv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) Called by proc~~multiply_by_real~~CalledByGraph proc~multiply_by_real multiply_by_real interface~operator(ASTERISK) operator(*) interface~operator(ASTERISK)->proc~multiply_by_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiply_by_real.html"},{"title":"divide_by_scalar – Example Project","text":"public function divide_by_scalar(v, s) result(sv) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: s Return Value type( vector ) Called by proc~~divide_by_scalar~~CalledByGraph proc~divide_by_scalar divide_by_scalar interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~divide_by_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/divide_by_scalar.html"},{"title":"distance – Example Project","text":"public function distance(v, w) result(d) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: v type( point ), intent(in) :: w Return Value real(kind=8) Contents None","tags":"","loc":"proc/distance.html"},{"title":"vect – Example Project","text":"public function vect(a, b) result(v) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: a type( point ), intent(in) :: b Return Value type( vector ) Contents None","tags":"","loc":"proc/vect.html"},{"title":"lengthv – Example Project","text":"public function lengthv(v) result(l) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v Return Value real(kind=8) Called by proc~~lengthv~~CalledByGraph proc~lengthv lengthv interface~length length interface~length->proc~lengthv proc~write_lat_fc write_lat_fc proc~write_lat_fc->interface~length proc~set_neighbork set_neighbork proc~set_neighbork->interface~length proc~write_correspondance write_correspondance proc~write_correspondance->interface~length proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~length proc~read_crystal read_crystal proc~read_crystal->interface~length proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->interface~length proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->interface~length proc~write_output_fc write_output_fc proc~write_output_fc->interface~length proc~write_output_fc->proc~write_lat_fc proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->interface~length proc~make_sorted_gs make_sorted_gs proc~make_sorted_gs->interface~length program~fc234 FC234 program~fc234->proc~write_lat_fc program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal program~fc234->proc~write_output_fc2 program~fc234->proc~write_correspondance2 proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~write_output_fc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lengthv.html"},{"title":"lengtha – Example Project","text":"public function lengtha(v) result(l) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v Return Value real(kind=8) Called by proc~~lengtha~~CalledByGraph proc~lengtha lengtha interface~length length interface~length->proc~lengtha proc~write_lat_fc write_lat_fc proc~write_lat_fc->interface~length proc~set_neighbork set_neighbork proc~set_neighbork->interface~length proc~write_correspondance write_correspondance proc~write_correspondance->interface~length proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~length proc~read_crystal read_crystal proc~read_crystal->interface~length proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->interface~length proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->interface~length proc~write_output_fc write_output_fc proc~write_output_fc->interface~length proc~write_output_fc->proc~write_lat_fc proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->interface~length proc~make_sorted_gs make_sorted_gs proc~make_sorted_gs->interface~length program~fc234 FC234 program~fc234->proc~write_lat_fc program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal program~fc234->proc~write_output_fc2 program~fc234->proc~write_correspondance2 proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~write_output_fc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lengtha.html"},{"title":"bring_to_cell_dv – Example Project","text":"public function bring_to_cell_dv(v) result(w) Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) Called by proc~~bring_to_cell_dv~~CalledByGraph proc~bring_to_cell_dv bring_to_cell_dv interface~bring_to_cell_d bring_to_cell_d interface~bring_to_cell_d->proc~bring_to_cell_dv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_cell_dv.html"},{"title":"bring_to_cell_da – Example Project","text":"public function bring_to_cell_da(a) result(w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector ) Called by proc~~bring_to_cell_da~~CalledByGraph proc~bring_to_cell_da bring_to_cell_da interface~bring_to_cell_d bring_to_cell_d interface~bring_to_cell_d->proc~bring_to_cell_da Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_cell_da.html"},{"title":"point_eq_array – Example Project","text":"public subroutine point_eq_array(p, a) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p real(kind=8), intent(in) :: a (3) Called by proc~~point_eq_array~~CalledByGraph proc~point_eq_array point_eq_array interface~assignment(=) assignment(=) interface~assignment(=)->proc~point_eq_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/point_eq_array.html"},{"title":"point_eq_vector – Example Project","text":"public subroutine point_eq_vector(p, v) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p type( vector ), intent(in) :: v Called by proc~~point_eq_vector~~CalledByGraph proc~point_eq_vector point_eq_vector interface~assignment(=) assignment(=) interface~assignment(=)->proc~point_eq_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/point_eq_vector.html"},{"title":"vector_eq_point – Example Project","text":"public subroutine vector_eq_point(v, p) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: v type( point ), intent(in) :: p Called by proc~~vector_eq_point~~CalledByGraph proc~vector_eq_point vector_eq_point interface~assignment(=) assignment(=) interface~assignment(=)->proc~vector_eq_point Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vector_eq_point.html"},{"title":"vector_eq_array – Example Project","text":"public subroutine vector_eq_array(vv, aa) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: vv real(kind=8), intent(in) :: aa (3) Called by proc~~vector_eq_array~~CalledByGraph proc~vector_eq_array vector_eq_array interface~assignment(=) assignment(=) interface~assignment(=)->proc~vector_eq_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vector_eq_array.html"},{"title":"array_eq_vector – Example Project","text":"public subroutine array_eq_vector(a, v) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( vector ), intent(in) :: v Called by proc~~array_eq_vector~~CalledByGraph proc~array_eq_vector array_eq_vector interface~assignment(=) assignment(=) interface~assignment(=)->proc~array_eq_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/array_eq_vector.html"},{"title":"array_eq_point – Example Project","text":"public subroutine array_eq_point(a, p) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( point ), intent(in) :: p Called by proc~~array_eq_point~~CalledByGraph proc~array_eq_point array_eq_point interface~assignment(=) assignment(=) interface~assignment(=)->proc~array_eq_point Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/array_eq_point.html"},{"title":"reduce_v – Example Project","text":"public subroutine reduce_v(v, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w Called by proc~~reduce_v~~CalledByGraph proc~reduce_v reduce_v interface~reduce reduce interface~reduce->proc~reduce_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_v.html"},{"title":"reduce_a – Example Project","text":"public subroutine reduce_a(a, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w Called by proc~~reduce_a~~CalledByGraph proc~reduce_a reduce_a interface~reduce reduce interface~reduce->proc~reduce_a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce_a.html"},{"title":"bring_to_cell_ca – Example Project","text":"public subroutine bring_to_cell_ca(a, r1, r2, r3, g1, g2, g3, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: b (3) Called by proc~~bring_to_cell_ca~~CalledByGraph proc~bring_to_cell_ca bring_to_cell_ca interface~bring_to_cell_c bring_to_cell_c interface~bring_to_cell_c->proc~bring_to_cell_ca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_cell_ca.html"},{"title":"bring_to_cell_cv – Example Project","text":"public subroutine bring_to_cell_cv(v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w Called by proc~~bring_to_cell_cv~~CalledByGraph proc~bring_to_cell_cv bring_to_cell_cv interface~bring_to_cell_c bring_to_cell_c interface~bring_to_cell_c->proc~bring_to_cell_cv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_cell_cv.html"},{"title":"bring_to_center_v – Example Project","text":"public subroutine bring_to_center_v(v, r1, r2, r3, g1, g2, g3, w) Uses constants proc~~bring_to_center_v~~UsesGraph proc~bring_to_center_v bring_to_center_v module~constants constants proc~bring_to_center_v->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w Called by proc~~bring_to_center_v~~CalledByGraph proc~bring_to_center_v bring_to_center_v interface~bring_to_center bring_to_center interface~bring_to_center->proc~bring_to_center_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_center_v.html"},{"title":"bring_to_center_a – Example Project","text":"public subroutine bring_to_center_a(v, r1, r2, r3, g1, g2, g3, w) Uses constants proc~~bring_to_center_a~~UsesGraph proc~bring_to_center_a bring_to_center_a module~constants constants proc~bring_to_center_a->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8) :: v (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: w (3) Called by proc~~bring_to_center_a~~CalledByGraph proc~bring_to_center_a bring_to_center_a interface~bring_to_center bring_to_center interface~bring_to_center->proc~bring_to_center_a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bring_to_center_a.html"},{"title":"operator(*) – Example Project","text":"public interface operator(*) Calls interface~~operator(ASTERISK)~~CallsGraph interface~operator(ASTERISK) operator(*) proc~multiply_by_real multiply_by_real interface~operator(ASTERISK)->proc~multiply_by_real proc~multiply_by_integer multiply_by_integer interface~operator(ASTERISK)->proc~multiply_by_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures multiply_by_real multiply_by_integer Module Procedures public function multiply_by_real (s, v) result(sv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) public function multiply_by_integer (s, v) result(sv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector )","tags":"","loc":"interface/operator(ASTERISK).html"},{"title":"operator(/) – Example Project","text":"public interface operator(/) Calls interface~~operator(SLASH)~~CallsGraph interface~operator(SLASH) operator(/) proc~divide_by_scalar divide_by_scalar interface~operator(SLASH)->proc~divide_by_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures divide_by_scalar Module Procedures public function divide_by_scalar (v, s) result(sv) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: s Return Value type( vector )","tags":"","loc":"interface/operator(SLASH).html"},{"title":"assignment(=) – Example Project","text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~point_eq_vector point_eq_vector interface~assignment(=)->proc~point_eq_vector proc~point_eq_array point_eq_array interface~assignment(=)->proc~point_eq_array proc~vector_eq_point vector_eq_point interface~assignment(=)->proc~vector_eq_point proc~vector_eq_array vector_eq_array interface~assignment(=)->proc~vector_eq_array proc~array_eq_vector array_eq_vector interface~assignment(=)->proc~array_eq_vector proc~array_eq_point array_eq_point interface~assignment(=)->proc~array_eq_point Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures array_eq_vector array_eq_point vector_eq_array vector_eq_point point_eq_vector point_eq_array Module Procedures public subroutine array_eq_vector (a, v) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( vector ), intent(in) :: v public subroutine array_eq_point (a, p) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( point ), intent(in) :: p public subroutine vector_eq_array (vv, aa) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: vv real(kind=8), intent(in) :: aa (3) public subroutine vector_eq_point (v, p) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: v type( point ), intent(in) :: p public subroutine point_eq_vector (p, v) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p type( vector ), intent(in) :: v public subroutine point_eq_array (p, a) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p real(kind=8), intent(in) :: a (3)","tags":"","loc":"interface/assignment(=).html"},{"title":"operator(+) – Example Project","text":"public interface operator(+) Calls interface~~operator(+)~~CallsGraph interface~operator(+) operator(+) proc~addition_avv addition_avv interface~operator(+)->proc~addition_avv proc~addition addition interface~operator(+)->proc~addition proc~addition_vav addition_vav interface~operator(+)->proc~addition_vav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures addition_avv addition_vav addition Module Procedures public function addition_avv (w, v) result(add) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function addition_vav (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) public function addition (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector )","tags":"","loc":"interface/operator(+).html"},{"title":"operator(-) – Example Project","text":"public interface operator(-) Calls interface~~operator(-)~~CallsGraph interface~operator(-) operator(-) proc~subtraction_va subtraction_va interface~operator(-)->proc~subtraction_va proc~subtraction_av subtraction_av interface~operator(-)->proc~subtraction_av proc~subtraction subtraction interface~operator(-)->proc~subtraction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures subtraction subtraction_av subtraction_va Module Procedures public function subtraction (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function subtraction_av (w, v) result(dif) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function subtraction_va (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector )","tags":"","loc":"interface/operator(-).html"},{"title":"operator(.dot.) – Example Project","text":"public interface operator(.dot.) Calls interface~~operator(.dot.)~~CallsGraph interface~operator(.dot.) operator(.dot.) proc~dotproduct_a dotproduct_a interface~operator(.dot.)->proc~dotproduct_a proc~dotproduct_av dotproduct_av interface~operator(.dot.)->proc~dotproduct_av proc~dotproduct_v dotproduct_v interface~operator(.dot.)->proc~dotproduct_v proc~dotproduct_va dotproduct_va interface~operator(.dot.)->proc~dotproduct_va Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures dotproduct_v dotproduct_a dotproduct_av dotproduct_va Module Procedures public function dotproduct_v (v, w) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_a (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(in) :: w (:) Return Value real(kind=8) public function dotproduct_av (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_va (w, v) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: w real(kind=8), intent(in) :: v (3) Return Value real(kind=8)","tags":"","loc":"interface/operator(.dot.).html"},{"title":"operator(.cross.) – Example Project","text":"public interface operator(.cross.) Calls interface~~operator(.cross.)~~CallsGraph interface~operator(.cross.) operator(.cross.) proc~crossproduct_a crossproduct_a interface~operator(.cross.)->proc~crossproduct_a proc~crossproduct_v crossproduct_v interface~operator(.cross.)->proc~crossproduct_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures crossproduct_v crossproduct_a Module Procedures public function crossproduct_v (v, w) result(cross) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function crossproduct_a (v, w) result(cross) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) real(kind=8), intent(in) :: w (3) Return Value real(kind=8)(3)","tags":"","loc":"interface/operator(.cross.).html"},{"title":"operator(.myeqz.) – Example Project","text":"public interface operator(.myeqz.) Calls interface~~operator(.myeqz.)~~CallsGraph interface~operator(.myeqz.) operator(.myeqz.) proc~myequal0array myequal0array interface~operator(.myeqz.)->proc~myequal0array proc~myequal0 myequal0 interface~operator(.myeqz.)->proc~myequal0 proc~myequal0vector myequal0vector interface~operator(.myeqz.)->proc~myequal0vector proc~myequal0array->proc~myequal0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures myequal0 myequal0array myequal0vector Module Procedures public function myequal0 (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequal0array (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function myequal0vector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical","tags":"","loc":"interface/operator(.myeqz.).html"},{"title":"operator(.myeq.) – Example Project","text":"public interface operator(.myeq.) Calls interface~~operator(.myeq.)~~CallsGraph interface~operator(.myeq.) operator(.myeq.) proc~myequalvector myequalvector interface~operator(.myeq.)->proc~myequalvector proc~myequalarray myequalarray interface~operator(.myeq.)->proc~myequalarray proc~myequal myequal interface~operator(.myeq.)->proc~myequal proc~myequalarray->proc~myequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures myequal myequalarray myequalvector Module Procedures public function myequal (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequalarray (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function myequalvector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical","tags":"","loc":"interface/operator(.myeq.).html"},{"title":"length – Example Project","text":"public interface length Calls interface~~length~~CallsGraph interface~length length proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~length~~CalledByGraph interface~length length proc~write_lat_fc write_lat_fc proc~write_lat_fc->interface~length proc~set_neighbork set_neighbork proc~set_neighbork->interface~length proc~write_correspondance write_correspondance proc~write_correspondance->interface~length proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~length proc~read_crystal read_crystal proc~read_crystal->interface~length proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->interface~length proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->interface~length proc~write_output_fc write_output_fc proc~write_output_fc->interface~length proc~write_output_fc->proc~write_lat_fc proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->interface~length proc~make_sorted_gs make_sorted_gs proc~make_sorted_gs->interface~length program~fc234 FC234 program~fc234->proc~write_lat_fc program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal program~fc234->proc~write_output_fc2 program~fc234->proc~write_correspondance2 proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->proc~write_output_fc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures lengthv lengtha Module Procedures public function lengthv (v) result(l) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v Return Value real(kind=8) public function lengtha (v) result(l) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v Return Value real(kind=8)","tags":"","loc":"interface/length.html"},{"title":"bring_to_cell_c – Example Project","text":"public interface bring_to_cell_c Calls interface~~bring_to_cell_c~~CallsGraph interface~bring_to_cell_c bring_to_cell_c proc~bring_to_cell_cv bring_to_cell_cv interface~bring_to_cell_c->proc~bring_to_cell_cv proc~bring_to_cell_ca bring_to_cell_ca interface~bring_to_cell_c->proc~bring_to_cell_ca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures bring_to_cell_cv bring_to_cell_ca Module Procedures public subroutine bring_to_cell_cv (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w public subroutine bring_to_cell_ca (a, r1, r2, r3, g1, g2, g3, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: b (3)","tags":"","loc":"interface/bring_to_cell_c.html"},{"title":"bring_to_cell_d – Example Project","text":"public interface bring_to_cell_d Calls interface~~bring_to_cell_d~~CallsGraph interface~bring_to_cell_d bring_to_cell_d proc~bring_to_cell_dv bring_to_cell_dv interface~bring_to_cell_d->proc~bring_to_cell_dv proc~bring_to_cell_da bring_to_cell_da interface~bring_to_cell_d->proc~bring_to_cell_da Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures bring_to_cell_dv bring_to_cell_da Module Procedures public function bring_to_cell_dv (v) result(w) Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) public function bring_to_cell_da (a) result(w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector )","tags":"","loc":"interface/bring_to_cell_d.html"},{"title":"reduce – Example Project","text":"public interface reduce Calls interface~~reduce~~CallsGraph interface~reduce reduce proc~reduce_a reduce_a interface~reduce->proc~reduce_a proc~reduce_v reduce_v interface~reduce->proc~reduce_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures reduce_v reduce_a Module Procedures public subroutine reduce_v (v, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w public subroutine reduce_a (a, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w","tags":"","loc":"interface/reduce.html"},{"title":"bring_to_center – Example Project","text":"public interface bring_to_center Calls interface~~bring_to_center~~CallsGraph interface~bring_to_center bring_to_center proc~bring_to_center_a bring_to_center_a interface~bring_to_center->proc~bring_to_center_a proc~bring_to_center_v bring_to_center_v interface~bring_to_center->proc~bring_to_center_v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures bring_to_center_a bring_to_center_v Module Procedures public subroutine bring_to_center_a (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: v (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: w (3) public subroutine bring_to_center_v (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w","tags":"","loc":"interface/bring_to_center.html"},{"title":"write_outrm – Example Project","text":"public subroutine write_outrm(unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m real(kind=8) :: var (n,m) Calls proc~~write_outrm~~CallsGraph proc~write_outrm write_outrm 99 99 proc~write_outrm->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outrm~~CalledByGraph proc~write_outrm write_outrm interface~write_out write_out interface~write_out->proc~write_outrm proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outrm.html"},{"title":"write_outim – Example Project","text":"public subroutine write_outim(unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m integer :: var (n,m) Calls proc~~write_outim~~CallsGraph proc~write_outim write_outim 99 99 proc~write_outim->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outim~~CalledByGraph proc~write_outim write_outim interface~write_out write_out interface~write_out->proc~write_outim proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outim.html"},{"title":"write_outrv – Example Project","text":"public subroutine write_outrv(unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8), dimension(:) :: var Calls proc~~write_outrv~~CallsGraph proc~write_outrv write_outrv 99 99 proc~write_outrv->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outrv~~CalledByGraph proc~write_outrv write_outrv interface~write_out write_out interface~write_out->proc~write_outrv proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outrv.html"},{"title":"write_outiv – Example Project","text":"public subroutine write_outiv(unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer, dimension(:) :: var Calls proc~~write_outiv~~CallsGraph proc~write_outiv write_outiv 99 99 proc~write_outiv->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outiv~~CalledByGraph proc~write_outiv write_outiv interface~write_out write_out interface~write_out->proc~write_outiv proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outiv.html"},{"title":"write_outr – Example Project","text":"public subroutine write_outr(unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8) :: var Calls proc~~write_outr~~CallsGraph proc~write_outr write_outr 99 99 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outr~~CalledByGraph proc~write_outr write_outr interface~write_out write_out interface~write_out->proc~write_outr proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outr.html"},{"title":"write_outi – Example Project","text":"public subroutine write_outi(unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: var Calls proc~~write_outi~~CallsGraph proc~write_outi write_outi 99 99 proc~write_outi->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outi~~CalledByGraph proc~write_outi write_outi interface~write_out write_out interface~write_out->proc~write_outi proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outi.html"},{"title":"write_outv – Example Project","text":"public subroutine write_outv(unit, string, var) Uses geometry proc~~write_outv~~UsesGraph proc~write_outv write_outv module~geometry geometry proc~write_outv->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string type( vector ) :: var Calls proc~~write_outv~~CallsGraph proc~write_outv write_outv 3 3 proc~write_outv->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_outv~~CalledByGraph proc~write_outv write_outv interface~write_out write_out interface~write_out->proc~write_outv proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_outv.html"},{"title":"write_out – Example Project","text":"public interface write_out Calls interface~~write_out~~CallsGraph interface~write_out write_out proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr 99 99 proc~write_outim->99 proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~write_outi->99 3 3 proc~write_outv->3 proc~write_outr->99 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~write_out~~CalledByGraph interface~write_out write_out proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->interface~write_out proc~read_force_position_data read_force_position_data proc~read_force_position_data->interface~write_out proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->interface~write_out proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->interface~write_out proc~read_crystal read_crystal proc~read_crystal->interface~write_out program~fc234 FC234 program~fc234->interface~write_out program~fc234->proc~read_force_position_data program~fc234->proc~set_translational_inv_constraints program~fc234->proc~read_crystal proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->interface~write_out proc~setup_maps->interface~write_out proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures write_outiv write_outrv write_outim write_outrm write_outi write_outr write_outv Module Procedures public subroutine write_outiv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer, dimension(:) :: var public subroutine write_outrv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8), dimension(:) :: var public subroutine write_outim (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m integer :: var (n,m) public subroutine write_outrm (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m real(kind=8) :: var (n,m) public subroutine write_outi (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: var public subroutine write_outr (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8) :: var public subroutine write_outv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string type( vector ) :: var","tags":"","loc":"interface/write_out.html"},{"title":"allocate_disp_forc – Example Project","text":"public subroutine allocate_disp_forc(n) Arguments Type Intent Optional Attributes Name integer :: n Contents None","tags":"","loc":"proc/allocate_disp_forc.html"},{"title":"allocate_pos – Example Project","text":"public subroutine allocate_pos(n, m) Arguments Type Intent Optional Attributes Name integer :: n integer :: m Called by proc~~allocate_pos~~CalledByGraph proc~allocate_pos allocate_pos proc~read_force_position_data read_force_position_data proc~read_force_position_data->proc~allocate_pos program~fc234 FC234 program~fc234->proc~read_force_position_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_pos.html"},{"title":"allocate_mass – Example Project","text":"public subroutine allocate_mass(n) Arguments Type Intent Optional Attributes Name integer :: n Called by proc~~allocate_mass~~CalledByGraph proc~allocate_mass allocate_mass proc~read_input read_input proc~read_input->proc~allocate_mass program~fc234 FC234 program~fc234->proc~read_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_mass.html"},{"title":"allocate_primcell – Example Project","text":"public subroutine allocate_primcell(n0) Arguments Type Intent Optional Attributes Name integer :: n0 Called by proc~~allocate_primcell~~CalledByGraph proc~allocate_primcell allocate_primcell proc~read_input read_input proc~read_input->proc~allocate_primcell program~fc234 FC234 program~fc234->proc~read_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_primcell.html"},{"title":"allocate_supercell – Example Project","text":"public subroutine allocate_supercell(n) Arguments Type Intent Optional Attributes Name integer :: n Contents None","tags":"","loc":"proc/allocate_supercell.html"},{"title":"set_neighbor_list – Example Project","text":"public subroutine set_neighbor_list() Uses geometry lattice ios force_constants_module params proc~~set_neighbor_list~~UsesGraph proc~set_neighbor_list set_neighbor_list module~force_constants_module force_constants_module proc~set_neighbor_list->module~force_constants_module module~geometry geometry proc~set_neighbor_list->module~geometry module~lattice lattice proc~set_neighbor_list->module~lattice module~ios ios proc~set_neighbor_list->module~ios module~params params proc~set_neighbor_list->module~params module~lattice->module~geometry module~constants constants module~lattice->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~set_neighbor_list~~CallsGraph proc~set_neighbor_list set_neighbor_list proc~sort sort proc~set_neighbor_list->proc~sort 2 2 proc~set_neighbor_list->2 proc~calculate_distance calculate_distance proc~set_neighbor_list->proc~calculate_distance 3 3 proc~set_neighbor_list->3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_neighbor_list~~CalledByGraph proc~set_neighbor_list set_neighbor_list program~fc234 FC234 program~fc234->proc~set_neighbor_list Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_neighbor_list.html"},{"title":"set_maxterms – Example Project","text":"public subroutine set_maxterms() Arguments None Called by proc~~set_maxterms~~CalledByGraph proc~set_maxterms set_maxterms program~fc234 FC234 program~fc234->proc~set_maxterms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_maxterms.html"},{"title":"pre_matrix_elt – Example Project","text":"Contents Variables eiqr2 eivec2 Subroutines allocate_eiqr2 allocate_eivec2 deallocate_eiqr2 deallocate_eivec2 Variables Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: eiqr2 (:,:) complex(kind=8), public, allocatable :: eivec2 (:,:,:,:) Subroutines public subroutine allocate_eiqr2 (num1, num2) Arguments Type Intent Optional Attributes Name integer :: num1 integer :: num2 public subroutine allocate_eivec2 (num1, num3, num4) Arguments Type Intent Optional Attributes Name integer :: num1 integer :: num3 integer :: num4 public subroutine deallocate_eiqr2 () Arguments None public subroutine deallocate_eivec2 () Arguments None","tags":"","loc":"module/pre_matrix_elt.html"},{"title":"mod_ksubset2 – Example Project","text":"Contents Variables num_pfiles ksubset2 Subroutines allocate_ksubset2 deallocate_ksubset2 Variables Type Visibility Attributes Name Initial integer, public :: num_pfiles integer, public, allocatable :: ksubset2 (:,:) Subroutines public subroutine allocate_ksubset2 (num) Arguments Type Intent Optional Attributes Name integer :: num public subroutine deallocate_ksubset2 () Arguments None","tags":"","loc":"module/mod_ksubset2.html"},{"title":"phi3_sy – Example Project","text":"Contents Variables v33_md v33sq1 Subroutines allocate_v33_sy deallocate_v33_sy allocate_v33_sq deallocate_v33_sq allocate_phi3_sy Variables Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: v33_md (:,:,:,:,:) real(kind=8), public, allocatable :: v33sq1 (:,:,:,:,:) Subroutines public subroutine allocate_v33_sy (n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 public subroutine deallocate_v33_sy () Arguments None public subroutine allocate_v33_sq (n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 public subroutine deallocate_v33_sq () Arguments None public subroutine allocate_phi3_sy (nk, nl, ni) Arguments Type Intent Optional Attributes Name integer :: nk integer :: nl integer :: ni","tags":"","loc":"module/phi3_sy.html"},{"title":"exactBTE2 – Example Project","text":"Contents Variables ncol nlin F_RTA F1 F2 Qvalue iselfenergy tau error diff mval qval coll rhs rhsi ne_dist ne_dist_rta Qvalue_N Qvalue_U diff_kap kappa kappa_k kappa_RTA kappa_k_RTA P1 P2 frequency dist Subroutines allocate_iter_kap allocate_iter0 allocate_iter1 allocate_iter2 deallocate_iter_kap deallocate_iter0 deallocate_iter1 deallocate_iter2 Variables Type Visibility Attributes Name Initial integer, public :: ncol integer, public :: nlin real(kind=8), public, allocatable :: F_RTA (:,:,:) real(kind=8), public, allocatable :: F1 (:,:,:) real(kind=8), public, allocatable :: F2 (:,:,:) real(kind=8), public, allocatable :: Qvalue (:,:) real(kind=8), public, allocatable :: iselfenergy (:,:) real(kind=8), public, allocatable :: tau (:,:,:) real(kind=8), public, allocatable :: error (:,:,:) real(kind=8), public, allocatable :: diff (:,:,:) real(kind=8), public, allocatable :: mval (:,:) real(kind=8), public, allocatable :: qval (:) real(kind=8), public, allocatable :: coll (:,:) real(kind=8), public, allocatable :: rhs (:,:) real(kind=8), public, allocatable :: rhsi (:,:) real(kind=8), public, allocatable :: ne_dist (:,:) real(kind=8), public, allocatable :: ne_dist_rta (:,:) real(kind=8), public, allocatable :: Qvalue_N (:,:) real(kind=8), public, allocatable :: Qvalue_U (:,:) real(kind=8), public, allocatable :: diff_kap (:,:,:,:) real(kind=8), public, allocatable :: kappa (:,:,:) real(kind=8), public, allocatable :: kappa_k (:,:,:,:) real(kind=8), public, allocatable :: kappa_RTA (:,:,:) real(kind=8), public, allocatable :: kappa_k_RTA (:,:,:,:) real(kind=8), public, allocatable :: P1 (:,:,:,:,:) real(kind=8), public, allocatable :: P2 (:,:,:,:,:) real(kind=8), public, allocatable :: frequency (:,:) real(kind=8), public, allocatable :: dist (:,:) Subroutines public subroutine allocate_iter_kap (nk, ndn) Arguments Type Intent Optional Attributes Name integer :: nk integer :: ndn public subroutine allocate_iter0 (ni, nk, ndn) Arguments Type Intent Optional Attributes Name integer :: ni integer :: nk integer :: ndn public subroutine allocate_iter1 (ni, nk, ndn) Arguments Type Intent Optional Attributes Name integer :: ni integer :: nk integer :: ndn public subroutine allocate_iter2 (n1, n2, l1, l2, l3) Arguments Type Intent Optional Attributes Name integer :: n1 integer :: n2 integer :: l1 integer :: l2 integer :: l3 public subroutine deallocate_iter_kap () Arguments None public subroutine deallocate_iter0 () Arguments None public subroutine deallocate_iter1 () Arguments None public subroutine deallocate_iter2 () Arguments None","tags":"","loc":"module/exactbte2.html"},{"title":"constants – Example Project","text":"Used by module~~constants~~UsedByGraph module~constants constants proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~constants module~lattice lattice proc~write_lat_fc->module~lattice proc~make_reciprocal_lattice make_reciprocal_lattice proc~make_reciprocal_lattice->module~constants proc~delta delta proc~delta->module~constants proc~delta_l delta_l proc~delta_l->module~constants proc~delta_g delta_g proc~delta_g->module~constants module~lattice->module~constants proc~bring_to_center_a bring_to_center_a proc~bring_to_center_a->module~constants proc~check_inside_fbz check_inside_fbz proc~check_inside_fbz->module~constants proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~constants proc~write_output_fc2->module~lattice proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->module~constants proc~check_inside_irred_fbz check_inside_irred_fbz proc~check_inside_irred_fbz->module~constants proc~check_inside_irred_fbz->module~lattice proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~constants proc~read_output_fc2->module~lattice proc~write_output_fc write_output_fc proc~write_output_fc->module~constants proc~write_output_fc->module~lattice proc~check_inside_irred_fbz2 check_inside_irred_fbz2 proc~check_inside_irred_fbz2->module~constants proc~check_inside_irred_fbz2->module~lattice proc~bring_to_center_v bring_to_center_v proc~bring_to_center_v->module~constants proc~bring_to_prim_cell_caa bring_to_prim_cell_caa proc~bring_to_prim_cell_caa->module~lattice proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_v->module~lattice proc~set_neighbork set_neighbork proc~set_neighbork->module~lattice proc~get_components_g get_components_g proc~get_components_g->module~lattice proc~dir2cart_g dir2cart_g proc~dir2cart_g->module~lattice proc~make_r0g make_r0g proc~make_r0g->module~lattice proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~lattice proc~bring_to_prim_cell_cv bring_to_prim_cell_cv proc~bring_to_prim_cell_cv->module~lattice proc~direct_to_cart_av direct_to_cart_av proc~direct_to_cart_av->module~lattice proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~lattice proc~bring_to_super_cell_cav bring_to_super_cell_cav proc~bring_to_super_cell_cav->module~lattice proc~read_crystal read_crystal proc~read_crystal->module~lattice proc~bring_to_super_cell_cv bring_to_super_cell_cv proc~bring_to_super_cell_cv->module~lattice proc~force_constants_init force_constants_init proc~force_constants_init->module~lattice proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~lattice proc~bring_to_prim_cell_cav bring_to_prim_cell_cav proc~bring_to_prim_cell_cav->module~lattice proc~bring_to_super_cell_caa bring_to_super_cell_caa proc~bring_to_super_cell_caa->module~lattice proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_v->module~lattice proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~lattice proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~lattice proc~cart_to_direct_av cart_to_direct_av proc~cart_to_direct_av->module~lattice proc~get_components_g_centered get_components_g_centered proc~get_components_g_centered->module~lattice proc~send_to_fbz send_to_fbz proc~send_to_fbz->module~lattice proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~lattice proc~findatom_sc findatom_sc proc~findatom_sc->module~lattice proc~cart_to_direct_aa cart_to_direct_aa proc~cart_to_direct_aa->module~lattice proc~read_input read_input proc~read_input->module~lattice proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~lattice proc~write_correspondance write_correspondance proc~write_correspondance->module~lattice proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~lattice program~fc234 FC234 program~fc234->module~lattice proc~direct_to_cart_aa direct_to_cart_aa proc~direct_to_cart_aa->module~lattice proc~select_ibz select_IBZ proc~select_ibz->module~lattice proc~send_to_primcell send_to_primcell proc~send_to_primcell->module~lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi ci h_plank n_avog k_b c_light hbar ee eps0 me uma cnst ryd ab Variables Type Visibility Attributes Name Initial real(kind=8), public :: pi = 3.14159265358979323846d0 complex(kind=8), public :: ci = dcmplx(0d0, 1d0) real(kind=8), public :: h_plank = 6.62606896d-34 real(kind=8), public :: n_avog = 6.023d23 real(kind=8), public :: k_b = 1.3806504d-23 real(kind=8), public :: c_light = 2.99792458d+8 real(kind=8), public :: hbar = 1.054571628d-34 real(kind=8), public :: ee = 1.60217653d-19 real(kind=8), public :: eps0 = 8.854187817d-12 real(kind=8), public :: me = 9.1093826d-31 real(kind=8), public :: uma = 1.66053878d-27 real(kind=8), public :: cnst = 521.1098918 real(kind=8), public :: ryd = 27.2116 real(kind=8), public :: ab = 0.529177","tags":"","loc":"module/constants.html"},{"title":"params – Example Project","text":"Used by module~~params~~UsedByGraph module~params params proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~params proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~params proc~myequal myequal proc~myequal->module~params proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~params proc~check_huang check_huang proc~check_huang->module~params proc~write_neighbors write_neighbors proc~write_neighbors->module~params proc~compare2previous_lines compare2previous_lines proc~compare2previous_lines->module~params proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~params proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~params proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~params proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~params proc~check_zero_column check_zero_column proc~check_zero_column->module~params proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~params proc~read_crystal read_crystal proc~read_crystal->module~params proc~include_constraints include_constraints proc~include_constraints->module~params proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~params proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~params proc~setup_maps setup_maps proc~setup_maps->module~params proc~write_output_fc write_output_fc proc~write_output_fc->module~params proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~params proc~check check proc~check->module~params proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~params proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~params proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~params proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~params proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->module~params proc~myequal0 myequal0 proc~myequal0->module~params proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~params proc~read_input read_input proc~read_input->module~params proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~params proc~write_correspondance write_correspondance proc~write_correspondance->module~params proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~params proc~check_d check_d proc~check_d->module~params program~fc234 FC234 program~fc234->module~params proc~homogeneous_constraints_overlap homogeneous_constraints_overlap proc~homogeneous_constraints_overlap->module~params proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~params proc~remove_zeros remove_zeros proc~remove_zeros->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables tolerance margin scalelengths nconfigs classical ntemp fdfiles cal_cross threemtrx lamin lamax ncpu n_dig_acc isvd nshells include_fc rcut tau0 wshift tmin tmax qcros svdc verbose Variables Type Visibility Attributes Name Initial real(kind=8), public :: tolerance real(kind=8), public :: margin real(kind=8), public :: scalelengths integer, public :: nconfigs integer, public :: classical integer, public :: ntemp integer, public :: fdfiles integer, public :: cal_cross integer, public :: threemtrx integer, public :: lamin integer, public :: lamax integer, public :: ncpu integer, public :: n_dig_acc integer, public :: isvd integer, public :: nshells (4,10) integer, public :: include_fc (4) real(kind=8), public :: rcut (4) real(kind=8), public :: tau0 real(kind=8), public :: wshift (3) real(kind=8), public :: tmin real(kind=8), public :: tmax real(kind=8), public :: qcros (3) real(kind=8), public :: svdc logical, public :: verbose","tags":"","loc":"module/params.html"},{"title":"geometry – Example Project","text":"Used by module~~geometry~~UsedByGraph module~geometry geometry proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~geometry module~atoms_force_constants atoms_force_constants proc~set_force_displacement_matrix->module~atoms_force_constants proc~bring_to_prim_cell_caa bring_to_prim_cell_caa proc~bring_to_prim_cell_caa->module~geometry module~lattice lattice proc~bring_to_prim_cell_caa->module~lattice proc~comp1 comp1 proc~comp1->module~geometry proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_v->module~geometry proc~direct_to_cart_v->module~lattice proc~set_neighbork set_neighbork proc~set_neighbork->module~geometry proc~set_neighbork->module~lattice proc~get_components_g get_components_g proc~get_components_g->module~geometry proc~get_components_g->module~lattice proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~geometry proc~set_rotational_inv_constraints->module~atoms_force_constants proc~dir2cart_g dir2cart_g proc~dir2cart_g->module~geometry proc~dir2cart_g->module~lattice proc~compare2previous_lines compare2previous_lines proc~compare2previous_lines->module~geometry proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~geometry proc~write_correspondance2->module~atoms_force_constants proc~write_correspondance2->module~lattice proc~write_outv write_outv proc~write_outv->module~geometry proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~geometry proc~estimate_inv_constraints->module~atoms_force_constants proc~bring_to_prim_cell_cv bring_to_prim_cell_cv proc~bring_to_prim_cell_cv->module~geometry proc~bring_to_prim_cell_cv->module~lattice proc~direct_to_cart_av direct_to_cart_av proc~direct_to_cart_av->module~geometry proc~direct_to_cart_av->module~lattice proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~geometry proc~identify_atoms_in_supercell->module~atoms_force_constants proc~identify_atoms_in_supercell->module~lattice proc~make_reciprocal_lattice make_reciprocal_lattice proc~make_reciprocal_lattice->module~geometry proc~bring_to_super_cell_cav bring_to_super_cell_cav proc~bring_to_super_cell_cav->module~geometry proc~bring_to_super_cell_cav->module~lattice module~atoms_force_constants->module~geometry proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~geometry proc~set_translational_inv_constraints->module~atoms_force_constants proc~read_crystal read_crystal proc~read_crystal->module~geometry proc~read_crystal->module~atoms_force_constants proc~read_crystal->module~lattice proc~bring_to_super_cell_cv bring_to_super_cell_cv proc~bring_to_super_cell_cv->module~geometry proc~bring_to_super_cell_cv->module~lattice proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->module~geometry proc~get_direct_components get_direct_components proc~get_direct_components->module~geometry proc~setup_maps setup_maps proc~setup_maps->module~geometry proc~setup_maps->module~atoms_force_constants proc~calculate_volume calculate_volume proc~calculate_volume->module~geometry proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~geometry proc~calculate_and_write_displacements->module~atoms_force_constants proc~calculate_and_write_displacements->module~lattice proc~check check proc~check->module~geometry proc~bring_to_prim_cell_cav bring_to_prim_cell_cav proc~bring_to_prim_cell_cav->module~geometry proc~bring_to_prim_cell_cav->module~lattice proc~bring_to_super_cell_caa bring_to_super_cell_caa proc~bring_to_super_cell_caa->module~geometry proc~bring_to_super_cell_caa->module~lattice proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_v->module~geometry proc~cart_to_direct_v->module~lattice proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~geometry proc~read_force_position_data->module~atoms_force_constants proc~read_force_position_data->module~lattice proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~geometry proc~set_neighbor_list->module~lattice module~lattice->module~geometry proc~cart_to_direct_av cart_to_direct_av proc~cart_to_direct_av->module~geometry proc~cart_to_direct_av->module~lattice proc~check_inside_fbz check_inside_fbz proc~check_inside_fbz->module~geometry proc~get_components_g_centered get_components_g_centered proc~get_components_g_centered->module~geometry proc~get_components_g_centered->module~lattice proc~comp_c comp_c proc~comp_c->module~geometry proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~geometry proc~check_input_poscar_consistency_new->module~atoms_force_constants proc~check_input_poscar_consistency_new->module~lattice proc~findatom_sc findatom_sc proc~findatom_sc->module~geometry proc~findatom_sc->module~atoms_force_constants proc~findatom_sc->module~lattice proc~cart_to_direct_aa cart_to_direct_aa proc~cart_to_direct_aa->module~geometry proc~cart_to_direct_aa->module~lattice proc~check_inside_bz check_inside_bz proc~check_inside_bz->module~geometry proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~geometry proc~check_input_poscar_consistency->module~atoms_force_constants proc~check_input_poscar_consistency->module~lattice proc~write_correspondance write_correspondance proc~write_correspondance->module~geometry proc~write_correspondance->module~atoms_force_constants proc~write_correspondance->module~lattice proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~geometry proc~pos_out_consistency->module~atoms_force_constants proc~pos_out_consistency->module~lattice proc~check_d check_d proc~check_d->module~geometry program~fc234 FC234 program~fc234->module~geometry program~fc234->module~atoms_force_constants program~fc234->module~lattice proc~direct_to_cart_aa direct_to_cart_aa proc~direct_to_cart_aa->module~geometry proc~direct_to_cart_aa->module~lattice proc~make_sorted_gs make_sorted_gs proc~make_sorted_gs->module~geometry proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~atoms_force_constants proc~write_lat_fc->module~lattice proc~read_input read_input proc~read_input->module~atoms_force_constants proc~read_input->module~lattice proc~send_to_primcell send_to_primcell proc~send_to_primcell->module~lattice proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~atoms_force_constants proc~check_huang check_huang proc~check_huang->module~atoms_force_constants proc~write_neighbors write_neighbors proc~write_neighbors->module~atoms_force_constants proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~atoms_force_constants proc~write_output_fc2->module~lattice proc~send_to_fbz send_to_fbz proc~send_to_fbz->module~lattice proc~check_inside_irred_fbz check_inside_irred_fbz proc~check_inside_irred_fbz->module~lattice proc~make_r0g make_r0g proc~make_r0g->module~lattice proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~atoms_force_constants proc~read_output_fc2->module~lattice proc~write_output_fc write_output_fc proc~write_output_fc->module~atoms_force_constants proc~write_output_fc->module~lattice proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~atoms_force_constants proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~atoms_force_constants proc~check_inside_irred_fbz2 check_inside_irred_fbz2 proc~check_inside_irred_fbz2->module~lattice proc~select_ibz select_IBZ proc~select_ibz->module~lattice proc~force_constants_init force_constants_init proc~force_constants_init->module~lattice proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~atoms_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces operator(*) operator(/) assignment(=) operator(+) operator(-) operator(.dot.) operator(.cross.) operator(.myeqz.) operator(.myeq.) length bring_to_cell_c bring_to_cell_d reduce bring_to_center Derived Types vector point Functions crossproduct_v crossproduct_a dotproduct_v dotproduct_a dotproduct_av dotproduct_va myequal0 myequal myequal0vector myequalvector myequal0array myequalarray addition addition_vav addition_avv subtraction subtraction_va subtraction_av multiply_by_integer multiply_by_real divide_by_scalar distance vect lengthv lengtha bring_to_cell_dv bring_to_cell_da Subroutines point_eq_array point_eq_vector vector_eq_point vector_eq_array array_eq_vector array_eq_point reduce_v reduce_a bring_to_cell_ca bring_to_cell_cv bring_to_center_v bring_to_center_a Interfaces public interface operator(*) public function multiply_by_real (s, v) result(sv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) public function multiply_by_integer (s, v) result(sv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) public interface operator(/) public function divide_by_scalar (v, s) result(sv) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: s Return Value type( vector ) public interface assignment(=) public subroutine array_eq_vector (a, v) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( vector ), intent(in) :: v public subroutine array_eq_point (a, p) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( point ), intent(in) :: p public subroutine vector_eq_array (vv, aa) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: vv real(kind=8), intent(in) :: aa (3) public subroutine vector_eq_point (v, p) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: v type( point ), intent(in) :: p public subroutine point_eq_vector (p, v) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p type( vector ), intent(in) :: v public subroutine point_eq_array (p, a) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p real(kind=8), intent(in) :: a (3) public interface operator(+) public function addition_avv (w, v) result(add) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function addition_vav (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) public function addition (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public interface operator(-) public function subtraction (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function subtraction_av (w, v) result(dif) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function subtraction_va (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) public interface operator(.dot.) public function dotproduct_v (v, w) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_a (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(in) :: w (:) Return Value real(kind=8) public function dotproduct_av (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_va (w, v) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: w real(kind=8), intent(in) :: v (3) Return Value real(kind=8) public interface operator(.cross.) public function crossproduct_v (v, w) result(cross) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function crossproduct_a (v, w) result(cross) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) real(kind=8), intent(in) :: w (3) Return Value real(kind=8)(3) public interface operator(.myeqz.) public function myequal0 (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequal0array (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function myequal0vector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical public interface operator(.myeq.) public function myequal (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequalarray (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function myequalvector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical public interface length public function lengthv (v) result(l) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v Return Value real(kind=8) public function lengtha (v) result(l) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v Return Value real(kind=8) public interface bring_to_cell_c public subroutine bring_to_cell_cv (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w public subroutine bring_to_cell_ca (a, r1, r2, r3, g1, g2, g3, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: b (3) public interface bring_to_cell_d public function bring_to_cell_dv (v) result(w) Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) public function bring_to_cell_da (a) result(w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector ) public interface reduce public subroutine reduce_v (v, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w public subroutine reduce_a (a, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w public interface bring_to_center public subroutine bring_to_center_a (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: v (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: w (3) public subroutine bring_to_center_v (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w Derived Types type, public :: vector Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y real(kind=8), public :: z type, public :: point Components Type Visibility Attributes Name Initial real(kind=8), public :: x real(kind=8), public :: y real(kind=8), public :: z Functions public function crossproduct_v (v, w) result(cross) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function crossproduct_a (v, w) result(cross) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) real(kind=8), intent(in) :: w (3) Return Value real(kind=8)(3) public function dotproduct_v (v, w) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_a (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(in) :: w (:) Return Value real(kind=8) public function dotproduct_av (v, w) result(dot) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (3) type( vector ), intent(in) :: w Return Value real(kind=8) public function dotproduct_va (w, v) result(dot) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: w real(kind=8), intent(in) :: v (3) Return Value real(kind=8) public function myequal0 (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequal (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v real(kind=8), intent(in) :: w Return Value logical public function myequal0vector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical public function myequalvector (v, w) result(eq) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value logical public function myequal0array (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function myequalarray (v, w) result(eq) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v real(kind=8), intent(in), dimension(:) :: w Return Value logical public function addition (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function addition_vav (v, w) result(add) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) public function addition_avv (w, v) result(add) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function subtraction (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v type( vector ), intent(in) :: w Return Value type( vector ) public function subtraction_va (v, w) result(dif) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: w (3) Return Value type( vector ) public function subtraction_av (w, v) result(dif) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: w (3) type( vector ), intent(in) :: v Return Value type( vector ) public function multiply_by_integer (s, v) result(sv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) public function multiply_by_real (s, v) result(sv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: s type( vector ), intent(in) :: v Return Value type( vector ) public function divide_by_scalar (v, s) result(sv) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v real(kind=8), intent(in) :: s Return Value type( vector ) public function distance (v, w) result(d) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: v type( point ), intent(in) :: w Return Value real(kind=8) public function vect (a, b) result(v) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: a type( point ), intent(in) :: b Return Value type( vector ) public function lengthv (v) result(l) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: v Return Value real(kind=8) public function lengtha (v) result(l) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: v Return Value real(kind=8) public function bring_to_cell_dv (v) result(w) Arguments Type Intent Optional Attributes Name type( vector ) :: v Return Value type( vector ) public function bring_to_cell_da (a) result(w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) Return Value type( vector ) Subroutines public subroutine point_eq_array (p, a) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p real(kind=8), intent(in) :: a (3) public subroutine point_eq_vector (p, v) Arguments Type Intent Optional Attributes Name type( point ), intent(out) :: p type( vector ), intent(in) :: v public subroutine vector_eq_point (v, p) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: v type( point ), intent(in) :: p public subroutine vector_eq_array (vv, aa) Arguments Type Intent Optional Attributes Name type( vector ), intent(out) :: vv real(kind=8), intent(in) :: aa (3) public subroutine array_eq_vector (a, v) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( vector ), intent(in) :: v public subroutine array_eq_point (a, p) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: a (3) type( point ), intent(in) :: p public subroutine reduce_v (v, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w public subroutine reduce_a (a, q1, q2, q3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: q1 type( vector ) :: q2 type( vector ) :: q3 type( vector ) :: w public subroutine bring_to_cell_ca (a, r1, r2, r3, g1, g2, g3, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: b (3) public subroutine bring_to_cell_cv (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w public subroutine bring_to_center_v (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name type( vector ) :: v type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 type( vector ) :: w public subroutine bring_to_center_a (v, r1, r2, r3, g1, g2, g3, w) Arguments Type Intent Optional Attributes Name real(kind=8) :: v (3) type( vector ) :: r1 type( vector ) :: r2 type( vector ) :: r3 type( vector ) :: g1 type( vector ) :: g2 type( vector ) :: g3 real(kind=8) :: w (3)","tags":"","loc":"module/geometry.html"},{"title":"ios – Example Project","text":"Used by module~~ios~~UsedByGraph module~ios ios proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~ios proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~ios proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~ios proc~set_neighbork set_neighbork proc~set_neighbork->module~ios proc~check_huang check_huang proc~check_huang->module~ios proc~write_neighbors write_neighbors proc~write_neighbors->module~ios proc~compare2previous_lines compare2previous_lines proc~compare2previous_lines->module~ios proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~ios proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~ios proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~ios proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~ios proc~make_reciprocal_lattice make_reciprocal_lattice proc~make_reciprocal_lattice->module~ios proc~check_zero_column check_zero_column proc~check_zero_column->module~ios proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~ios proc~read_crystal read_crystal proc~read_crystal->module~ios proc~include_constraints include_constraints proc~include_constraints->module~ios proc~find_t find_t proc~find_t->module~ios proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~ios proc~make_reciprocal_lattice_2pi make_reciprocal_lattice_2pi proc~make_reciprocal_lattice_2pi->module~ios proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~ios proc~write_output_fc write_output_fc proc~write_output_fc->module~ios proc~setup_maps setup_maps proc~setup_maps->module~ios proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~ios proc~check check proc~check->module~ios proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~ios proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~ios proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~ios proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~ios proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->module~ios proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~ios proc~findatom_sc findatom_sc proc~findatom_sc->module~ios proc~read_input read_input proc~read_input->module~ios proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~ios proc~write_correspondance write_correspondance proc~write_correspondance->module~ios proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~ios proc~check_d check_d proc~check_d->module~ios program~fc234 FC234 program~fc234->module~ios proc~homogeneous_constraints_overlap homogeneous_constraints_overlap proc~homogeneous_constraints_overlap->module~ios proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~ios proc~remove_zeros remove_zeros proc~remove_zeros->module~ios Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables ulog uposcar uparams utraj ufco umap umatrx utimes ufc1 ufc2 ufc3 ufc4 ufc ufit1 ufit2 ufit3 ufit4 ucor uborn Interfaces write_out Subroutines write_outrm write_outim write_outrv write_outiv write_outr write_outi write_outv Variables Type Visibility Attributes Name Initial integer, public, parameter :: ulog = 30 integer, public, parameter :: uposcar = 10 integer, public, parameter :: uparams = 11 integer, public, parameter :: utraj = 40 integer, public, parameter :: ufco = 20 integer, public, parameter :: umap = 60 integer, public, parameter :: umatrx = 50 integer, public, parameter :: utimes = 70 integer, public, parameter :: ufc1 = 21 integer, public, parameter :: ufc2 = 22 integer, public, parameter :: ufc3 = 23 integer, public, parameter :: ufc4 = 24 integer, public, parameter :: ufc = 80 integer, public, parameter :: ufit1 = 31 integer, public, parameter :: ufit2 = 32 integer, public, parameter :: ufit3 = 33 integer, public, parameter :: ufit4 = 34 integer, public, parameter :: ucor = 93 integer, public, parameter :: uborn = 12 Interfaces public interface write_out public subroutine write_outiv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer, dimension(:) :: var public subroutine write_outrv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8), dimension(:) :: var public subroutine write_outim (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m integer :: var (n,m) public subroutine write_outrm (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m real(kind=8) :: var (n,m) public subroutine write_outi (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: var public subroutine write_outr (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8) :: var public subroutine write_outv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string type( vector ) :: var Subroutines public subroutine write_outrm (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m real(kind=8) :: var (n,m) public subroutine write_outim (unit, string, n, m, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: n integer :: m integer :: var (n,m) public subroutine write_outrv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8), dimension(:) :: var public subroutine write_outiv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer, dimension(:) :: var public subroutine write_outr (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string real(kind=8) :: var public subroutine write_outi (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string integer :: var public subroutine write_outv (unit, string, var) Arguments Type Intent Optional Attributes Name integer :: unit character(len=*) :: string type( vector ) :: var","tags":"","loc":"module/ios.html"},{"title":"force_constants_module – Example Project","text":"Used by module~~force_constants_module~~UsedByGraph module~force_constants_module force_constants_module proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~force_constants_module module~atoms_force_constants atoms_force_constants proc~write_lat_fc->module~atoms_force_constants proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~force_constants_module proc~set_force_displacement_matrix->module~atoms_force_constants proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~force_constants_module proc~set_rotational_inv_constraints->module~atoms_force_constants proc~findatom findatom proc~findatom->module~force_constants_module proc~check_huang check_huang proc~check_huang->module~force_constants_module proc~check_huang->module~atoms_force_constants proc~write_neighbors write_neighbors proc~write_neighbors->module~force_constants_module proc~write_neighbors->module~atoms_force_constants proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~force_constants_module proc~write_correspondance2->module~atoms_force_constants proc~findatom2 findatom2 proc~findatom2->module~force_constants_module proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~force_constants_module proc~set_huang_inv_constraints->module~atoms_force_constants proc~force_constants force_constants proc~force_constants->module~force_constants_module module~atoms_force_constants->module~force_constants_module proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~force_constants_module proc~set_translational_inv_constraints->module~atoms_force_constants proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~force_constants_module proc~write_output_fc2->module~atoms_force_constants proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~force_constants_module proc~read_output_fc2->module~atoms_force_constants proc~write_output_fc write_output_fc proc~write_output_fc->module~force_constants_module proc~write_output_fc->module~atoms_force_constants proc~force_constants_init force_constants_init proc~force_constants_init->module~force_constants_module proc~collect_force_constants collect_force_constants proc~collect_force_constants->module~force_constants_module proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~force_constants_module proc~unique_force_constant unique_force_constant proc~unique_force_constant->module~force_constants_module proc~getstar getstar proc~getstar->module~force_constants_module proc~read_input read_input proc~read_input->module~force_constants_module proc~read_input->module~atoms_force_constants proc~write_correspondance write_correspondance proc~write_correspondance->module~force_constants_module proc~write_correspondance->module~atoms_force_constants program~fc234 FC234 program~fc234->module~force_constants_module program~fc234->module~atoms_force_constants proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~force_constants_module proc~read_fcs_2->module~atoms_force_constants proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~atoms_force_constants proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~atoms_force_constants proc~findatom_sc findatom_sc proc~findatom_sc->module~atoms_force_constants proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~atoms_force_constants proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~atoms_force_constants proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~atoms_force_constants proc~read_crystal read_crystal proc~read_crystal->module~atoms_force_constants proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~atoms_force_constants proc~setup_maps setup_maps proc~setup_maps->module~atoms_force_constants proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~atoms_force_constants proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~atoms_force_constants proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~atoms_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables maxneighbors maxatoms imaxat op_matrix op_kmatrix lattpgcount isgopcount isgop sgfract iatomop atomopfract natoms0 natoms atompos iatomcell iatomcell0 iatomneighbor Variables Type Visibility Attributes Name Initial integer, public :: maxneighbors integer, public :: maxatoms integer, public :: imaxat double precision, public :: op_matrix (3,3,48) double precision, public :: op_kmatrix (3,3,48) integer, public :: lattpgcount integer, public :: isgopcount integer, public :: isgop (48) double precision, public :: sgfract (3,48) integer, public, allocatable :: iatomop (:,:) double precision, public, allocatable :: atomopfract (:,:,:) integer, public :: natoms0 integer, public :: natoms real(kind=8), public, allocatable :: atompos (:,:) integer, public, allocatable :: iatomcell (:,:) integer, public, allocatable :: iatomcell0 (:) integer, public, allocatable :: iatomneighbor (:,:)","tags":"","loc":"module/force_constants_module.html"},{"title":"lattice – Example Project","text":"Uses geometry constants module~~lattice~~UsesGraph module~lattice lattice module~constants constants module~lattice->module~constants module~geometry geometry module~lattice->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~lattice~~UsedByGraph module~lattice lattice proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~lattice proc~bring_to_prim_cell_caa bring_to_prim_cell_caa proc~bring_to_prim_cell_caa->module~lattice proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_v->module~lattice proc~set_neighbork set_neighbork proc~set_neighbork->module~lattice proc~get_components_g get_components_g proc~get_components_g->module~lattice proc~dir2cart_g dir2cart_g proc~dir2cart_g->module~lattice proc~check_inside_irred_fbz check_inside_irred_fbz proc~check_inside_irred_fbz->module~lattice proc~make_r0g make_r0g proc~make_r0g->module~lattice proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~lattice proc~bring_to_prim_cell_cv bring_to_prim_cell_cv proc~bring_to_prim_cell_cv->module~lattice proc~direct_to_cart_av direct_to_cart_av proc~direct_to_cart_av->module~lattice proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~lattice proc~bring_to_super_cell_cav bring_to_super_cell_cav proc~bring_to_super_cell_cav->module~lattice proc~read_crystal read_crystal proc~read_crystal->module~lattice proc~bring_to_super_cell_cv bring_to_super_cell_cv proc~bring_to_super_cell_cv->module~lattice proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~lattice proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~lattice proc~write_output_fc write_output_fc proc~write_output_fc->module~lattice proc~force_constants_init force_constants_init proc~force_constants_init->module~lattice proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~lattice proc~bring_to_prim_cell_cav bring_to_prim_cell_cav proc~bring_to_prim_cell_cav->module~lattice proc~bring_to_super_cell_caa bring_to_super_cell_caa proc~bring_to_super_cell_caa->module~lattice proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_v->module~lattice proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~lattice proc~set_neighbor_list set_neighbor_list proc~set_neighbor_list->module~lattice proc~cart_to_direct_av cart_to_direct_av proc~cart_to_direct_av->module~lattice proc~get_components_g_centered get_components_g_centered proc~get_components_g_centered->module~lattice proc~send_to_fbz send_to_fbz proc~send_to_fbz->module~lattice proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~lattice proc~findatom_sc findatom_sc proc~findatom_sc->module~lattice proc~cart_to_direct_aa cart_to_direct_aa proc~cart_to_direct_aa->module~lattice proc~read_input read_input proc~read_input->module~lattice proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~lattice proc~write_correspondance write_correspondance proc~write_correspondance->module~lattice proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~lattice program~fc234 FC234 program~fc234->module~lattice proc~direct_to_cart_aa direct_to_cart_aa proc~direct_to_cart_aa->module~lattice proc~check_inside_irred_fbz2 check_inside_irred_fbz2 proc~check_inside_irred_fbz2->module~lattice proc~select_ibz select_IBZ proc~select_ibz->module~lattice proc~send_to_primcell send_to_primcell proc~send_to_primcell->module~lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables r1 r2 r3 g1 g2 g3 rr1 rr2 rr3 r01 r02 r03 g01 g02 g03 volume_r volume_g lattice_parameter latticeparameters primitivelattice box boxg r0g n1min n2min n3min n1max n2max n3max NC NF nr1 nr2 nr3 Variables Type Visibility Attributes Name Initial type( vector ), public :: r1 type( vector ), public :: r2 type( vector ), public :: r3 type( vector ), public :: g1 type( vector ), public :: g2 type( vector ), public :: g3 type( vector ), public :: rr1 type( vector ), public :: rr2 type( vector ), public :: rr3 type( vector ), public :: r01 type( vector ), public :: r02 type( vector ), public :: r03 type( vector ), public :: g01 type( vector ), public :: g02 type( vector ), public :: g03 real(kind=8), public :: volume_r real(kind=8), public :: volume_g real(kind=8), public :: lattice_parameter real(kind=8), public :: latticeparameters (6) real(kind=8), public :: primitivelattice (3,3) real(kind=8), public :: box (3) real(kind=8), public :: boxg (3) real(kind=8), public :: r0g (3,3) integer, public :: n1min integer, public :: n2min integer, public :: n3min integer, public :: n1max integer, public :: n2max integer, public :: n3max integer, public :: NC (3) integer, public :: NF (3) integer, public :: nr1 (3) for a given q-vector, it finds its integer components assuming it was\ncreated as: nk=0 do i=0,N(1)-1 ; do j=0,N(2)-1; do k=0,N(3)-1; nk=nk+1 ;q=i G1/N1+j G2/N2+k*G3/N3\nas the ones created in make_kp_reg with zero shift\nit works even if there's a shift less than 0.5 type(vector) g1,g2,g3,r1,r2,r3 call make_reciprocal_lattice(g1,g2,g3,r1,r2,r3) integer, public :: nr2 (3) for a given q-vector, it finds its integer components assuming it was\ncreated as: nk=0 do i=0,N(1)-1 ; do j=0,N(2)-1; do k=0,N(3)-1; nk=nk+1 ;q=i G1/N1+j G2/N2+k*G3/N3\nas the ones created in make_kp_reg with zero shift\nit works even if there's a shift less than 0.5 type(vector) g1,g2,g3,r1,r2,r3 call make_reciprocal_lattice(g1,g2,g3,r1,r2,r3) integer, public :: nr3 (3) for a given q-vector, it finds its integer components assuming it was\ncreated as: nk=0 do i=0,N(1)-1 ; do j=0,N(2)-1; do k=0,N(3)-1; nk=nk+1 ;q=i G1/N1+j G2/N2+k*G3/N3\nas the ones created in make_kp_reg with zero shift\nit works even if there's a shift less than 0.5 type(vector) g1,g2,g3,r1,r2,r3 call make_reciprocal_lattice(g1,g2,g3,r1,r2,r3)","tags":"","loc":"module/lattice.html"},{"title":"atoms_force_constants – Example Project","text":"Uses geometry force_constants_module module~~atoms_force_constants~~UsesGraph module~atoms_force_constants atoms_force_constants module~geometry geometry module~atoms_force_constants->module~geometry module~force_constants_module force_constants_module module~atoms_force_constants->module~force_constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~atoms_force_constants~~UsedByGraph module~atoms_force_constants atoms_force_constants proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~atoms_force_constants proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~atoms_force_constants proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~atoms_force_constants proc~check_huang check_huang proc~check_huang->module~atoms_force_constants proc~write_neighbors write_neighbors proc~write_neighbors->module~atoms_force_constants proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~atoms_force_constants proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~atoms_force_constants proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~atoms_force_constants proc~identify_atoms_in_supercell identify_atoms_in_supercell proc~identify_atoms_in_supercell->module~atoms_force_constants proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~atoms_force_constants proc~read_crystal read_crystal proc~read_crystal->module~atoms_force_constants proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~atoms_force_constants proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~atoms_force_constants proc~setup_maps setup_maps proc~setup_maps->module~atoms_force_constants proc~write_output_fc write_output_fc proc~write_output_fc->module~atoms_force_constants proc~calculate_and_write_displacements calculate_and_write_displacements proc~calculate_and_write_displacements->module~atoms_force_constants proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~atoms_force_constants proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~atoms_force_constants proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~atoms_force_constants proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~check_input_poscar_consistency_new->module~atoms_force_constants proc~findatom_sc findatom_sc proc~findatom_sc->module~atoms_force_constants proc~read_input read_input proc~read_input->module~atoms_force_constants proc~check_input_poscar_consistency check_input_poscar_consistency proc~check_input_poscar_consistency->module~atoms_force_constants proc~write_correspondance write_correspondance proc~write_correspondance->module~atoms_force_constants proc~pos_out_consistency pos_out_consistency proc~pos_out_consistency->module~atoms_force_constants program~fc234 FC234 program~fc234->module~atoms_force_constants proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~atoms_force_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables natom_prim_cell natom_super_cell maxshells natom_type natom atom_type atompos0 mas force displ forc disp vel cur atname atom0 atom_sc atom_shl Derived Types cell_id shell atomic atom_id0 Subroutines allocate_disp_forc allocate_pos allocate_mass allocate_primcell allocate_supercell set_neighbor_list Variables Type Visibility Attributes Name Initial integer, public :: natom_prim_cell integer, public :: natom_super_cell integer, public :: maxshells integer, public :: natom_type integer, public, allocatable :: natom (:) integer, public, allocatable :: atom_type (:) real(kind=8), public, allocatable :: atompos0 (:,:) real(kind=8), public, allocatable :: mas (:) real(kind=8), public, allocatable :: force (:,:,:) real(kind=8), public, allocatable :: displ (:,:,:) real(kind=8), public, allocatable :: forc (:,:) real(kind=8), public, allocatable :: disp (:,:) real(kind=8), public, allocatable :: vel (:,:) real(kind=8), public, allocatable :: cur (:,:) character(len=2), public, allocatable :: atname (:) type( atom_id0 ), public, allocatable :: atom0 (:) type( atomic ), public, allocatable :: atom_sc (:) type( atomic ), public, allocatable :: atom_shl (:) Derived Types type, public :: cell_id Components Type Visibility Attributes Name Initial integer, public :: n (3) integer, public :: tau type, public :: shell Components Type Visibility Attributes Name Initial integer, public :: no_of_neighbors real(kind=8), public :: rij type( cell_id ), public :: neighbors (296) type, public :: atomic Components Type Visibility Attributes Name Initial type( vector ), public :: equilibrium_pos type( cell_id ), public :: cell integer, public :: at_type real(kind=8), public :: mass type, public :: atom_id0 Components Type Visibility Attributes Name Initial integer, public :: at_type character, public :: name *2 real(kind=8), public :: mass real(kind=8), public :: charge integer, public :: nshells type( vector ), public :: equilibrium_pos type( shell ), public, allocatable :: shells (:) Subroutines public subroutine allocate_disp_forc (n) Arguments Type Intent Optional Attributes Name integer :: n public subroutine allocate_pos (n, m) Arguments Type Intent Optional Attributes Name integer :: n integer :: m public subroutine allocate_mass (n) Arguments Type Intent Optional Attributes Name integer :: n public subroutine allocate_primcell (n0) Arguments Type Intent Optional Attributes Name integer :: n0 public subroutine allocate_supercell (n) Arguments Type Intent Optional Attributes Name integer :: n public subroutine set_neighbor_list () Arguments None","tags":"","loc":"module/atoms_force_constants.html"},{"title":"svd_stuff – Example Project","text":"Used by module~~svd_stuff~~UsedByGraph module~svd_stuff svd_stuff proc~write_lat_fc write_lat_fc proc~write_lat_fc->module~svd_stuff proc~set_force_displacement_matrix set_force_displacement_matrix proc~set_force_displacement_matrix->module~svd_stuff proc~set_rotational_inv_constraints set_rotational_inv_constraints proc~set_rotational_inv_constraints->module~svd_stuff proc~check_huang check_huang proc~check_huang->module~svd_stuff proc~write_correspondance2 write_correspondance2 proc~write_correspondance2->module~svd_stuff proc~estimate_inv_constraints estimate_inv_constraints proc~estimate_inv_constraints->module~svd_stuff proc~set_huang_inv_constraints set_huang_inv_constraints proc~set_huang_inv_constraints->module~svd_stuff proc~check_zero_column check_zero_column proc~check_zero_column->module~svd_stuff proc~set_translational_inv_constraints set_translational_inv_constraints proc~set_translational_inv_constraints->module~svd_stuff proc~include_constraints include_constraints proc~include_constraints->module~svd_stuff proc~find_t find_t proc~find_t->module~svd_stuff proc~write_output_fc2 write_output_fc2 proc~write_output_fc2->module~svd_stuff proc~read_output_fc2 read_output_fc2 proc~read_output_fc2->module~svd_stuff proc~setup_maps setup_maps proc~setup_maps->module~svd_stuff proc~get_dim get_dim proc~get_dim->module~svd_stuff proc~write_output_fc write_output_fc proc~write_output_fc->module~svd_stuff proc~read_force_position_data read_force_position_data proc~read_force_position_data->module~svd_stuff proc~write_independent_fcs_2 write_independent_fcs_2 proc~write_independent_fcs_2->module~svd_stuff proc~write_independent_fcs write_independent_fcs proc~write_independent_fcs->module~svd_stuff proc~eliminate_fcs eliminate_fcs proc~eliminate_fcs->module~svd_stuff proc~read_input read_input proc~read_input->module~svd_stuff proc~write_correspondance write_correspondance proc~write_correspondance->module~svd_stuff program~fc234 FC234 program~fc234->module~svd_stuff proc~homogeneous_constraints_overlap homogeneous_constraints_overlap proc~homogeneous_constraints_overlap->module~svd_stuff proc~read_fcs_2 read_fcs_2 proc~read_fcs_2->module~svd_stuff proc~remove_zeros remove_zeros proc~remove_zeros->module~svd_stuff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables maxrank maxgroups itrans irot ihuang enforce_inv nterms maxterms maxtermsindep ngroups nterm ntermsindep iatomtermindep ixyztermindep iatmtrm ixyztrm mapmat svdcut radius iatomterm_1 ixyzterm_1 igroup_1 map_1 iatomterm_2 ixyzterm_2 igroup_2 map_2 iatomterm_3 ixyzterm_3 igroup_3 map_3 iatomterm_4 ixyzterm_4 igroup_4 map_4 err_1 err_2 err_3 err_4 map ampterm_1 fcs_1 ampterm_2 fcs_2 grun_fc ampterm_3 fcs_3 ampterm_4 fcs_4 amat bmat sigma fcs ahom overl a11ia12 fc1 arot brot atransl ahuang aforce bforce fc_ind inv_constraints force_constraints dim_al dim_ac n_indep newdim_al dim_hom transl_constraints rot_constraints huang_constraints ngr Derived Types groupmatrix fulldmatrix Subroutines set_maxterms Variables Type Visibility Attributes Name Initial integer, public :: maxrank integer, public :: maxgroups integer, public :: itrans integer, public :: irot integer, public :: ihuang integer, public :: enforce_inv integer, public :: nterms (4) integer, public :: maxterms (4) integer, public :: maxtermsindep (4) integer, public :: ngroups (4) integer, public, allocatable :: nterm (:) integer, public, allocatable :: ntermsindep (:) integer, public, allocatable :: iatomtermindep (:,:,:) integer, public, allocatable :: ixyztermindep (:,:,:) integer, public, allocatable :: iatmtrm (:,:,:) integer, public, allocatable :: ixyztrm (:,:,:) real(kind=8), public, allocatable :: mapmat (:,:,:) real(kind=8), public :: svdcut real(kind=8), public :: radius (4) integer, public, allocatable :: iatomterm_1 (:,:) integer, public, allocatable :: ixyzterm_1 (:,:) integer, public, allocatable :: igroup_1 (:) integer, public, allocatable :: map_1 (:) integer, public, allocatable :: iatomterm_2 (:,:) integer, public, allocatable :: ixyzterm_2 (:,:) integer, public, allocatable :: igroup_2 (:) integer, public, allocatable :: map_2 (:) integer, public, allocatable :: iatomterm_3 (:,:) integer, public, allocatable :: ixyzterm_3 (:,:) integer, public, allocatable :: igroup_3 (:) integer, public, allocatable :: map_3 (:) integer, public, allocatable :: iatomterm_4 (:,:) integer, public, allocatable :: ixyzterm_4 (:,:) integer, public, allocatable :: igroup_4 (:) integer, public, allocatable :: map_4 (:) character(len=1), public, allocatable :: err_1 (:) character(len=1), public, allocatable :: err_2 (:) character(len=1), public, allocatable :: err_3 (:) character(len=1), public, allocatable :: err_4 (:) type( fulldmatrix ), public :: map (4) real(kind=8), public, allocatable :: ampterm_1 (:) real(kind=8), public, allocatable :: fcs_1 (:) real(kind=8), public, allocatable :: ampterm_2 (:) real(kind=8), public, allocatable :: fcs_2 (:) real(kind=8), public, allocatable :: grun_fc (:) real(kind=8), public, allocatable :: ampterm_3 (:) real(kind=8), public, allocatable :: fcs_3 (:) real(kind=8), public, allocatable :: ampterm_4 (:) real(kind=8), public, allocatable :: fcs_4 (:) real(kind=8), public, allocatable :: amat (:,:) real(kind=8), public, allocatable :: bmat (:) real(kind=8), public, allocatable :: sigma (:) real(kind=8), public, allocatable :: fcs (:) real(kind=8), public, allocatable :: ahom (:,:) real(kind=8), public, allocatable :: overl (:,:) real(kind=8), public, allocatable :: a11ia12 (:,:) real(kind=8), public, allocatable :: fc1 (:) real(kind=8), public, allocatable :: arot (:,:) real(kind=8), public, allocatable :: brot (:) real(kind=8), public, allocatable :: atransl (:,:) real(kind=8), public, allocatable :: ahuang (:,:) real(kind=8), public, allocatable :: aforce (:,:) real(kind=8), public, allocatable :: bforce (:) real(kind=8), public, allocatable :: fc_ind (:) integer, public :: inv_constraints integer, public :: force_constraints integer, public :: dim_al integer, public :: dim_ac integer, public :: n_indep integer, public :: newdim_al integer, public :: dim_hom integer, public :: transl_constraints integer, public :: rot_constraints integer, public :: huang_constraints integer, public :: ngr Derived Types type, public :: groupmatrix Components Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: mat (:,:) integer, public, allocatable :: iat (:,:) integer, public, allocatable :: ixyz (:,:) integer, public, allocatable :: iatind (:,:) integer, public, allocatable :: ixyzind (:,:) type, public :: fulldmatrix Components Type Visibility Attributes Name Initial type( groupmatrix ), public, allocatable :: gr (:) integer, public, allocatable :: nt (:) integer, public, allocatable :: ntind (:) integer, public, allocatable :: igr (:) character(len=1), public, allocatable :: err (:) integer, public :: ngr integer, public :: ntotind integer, public :: ntot Subroutines public subroutine set_maxterms () Arguments None","tags":"","loc":"module/svd_stuff.html"},{"title":"born – Example Project","text":"Contents Variables epsil zeu rho born_flag Variables Type Visibility Attributes Name Initial real(kind=8), public :: epsil (3,3) real(kind=8), public, allocatable :: zeu (:,:,:) real(kind=8), public :: rho integer, public :: born_flag","tags":"","loc":"module/born.html"},{"title":"FC234 – Example Project","text":"Uses geometry lattice svd_stuff ios force_constants_module params atoms_force_constants program~~fc234~~UsesGraph program~fc234 FC234 module~svd_stuff svd_stuff program~fc234->module~svd_stuff module~force_constants_module force_constants_module program~fc234->module~force_constants_module module~geometry geometry program~fc234->module~geometry module~lattice lattice program~fc234->module~lattice module~atoms_force_constants atoms_force_constants program~fc234->module~atoms_force_constants module~ios ios program~fc234->module~ios module~params params program~fc234->module~params module~lattice->module~geometry module~constants constants module~lattice->module~constants module~atoms_force_constants->module~force_constants_module module~atoms_force_constants->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. call homogeneous_constraints_overlap(n_constr) ! do the SVD of the overlap\n allocate( us(n_constr,ngr),vs(ngr,ngr),ws(ngr) )\n us = ahom\n call svdcmp(us,n_constr,ngr,n_constr,ngr,ws,vs) give warnings if any column in aforce is totally zero do the SVD decomposition Add the correction term to the old solution Calls program~~fc234~~CallsGraph program~fc234 FC234 proc~write_lat_fc write_lat_fc program~fc234->proc~write_lat_fc proc~set_force_displacement_matrix set_force_displacement_matrix program~fc234->proc~set_force_displacement_matrix proc~set_rotational_inv_constraints set_rotational_inv_constraints program~fc234->proc~set_rotational_inv_constraints proc~warn warn program~fc234->proc~warn proc~set_maxterms set_maxterms program~fc234->proc~set_maxterms proc~svd_set svd_set program~fc234->proc~svd_set proc~write_neighbors write_neighbors program~fc234->proc~write_neighbors proc~make_r0g make_r0g program~fc234->proc~make_r0g proc~write_correspondance2 write_correspondance2 program~fc234->proc~write_correspondance2 proc~set_huang_inv_constraints set_huang_inv_constraints program~fc234->proc~set_huang_inv_constraints proc~identify_atoms_in_supercell identify_atoms_in_supercell program~fc234->proc~identify_atoms_in_supercell proc~make_reciprocal_lattice make_reciprocal_lattice program~fc234->proc~make_reciprocal_lattice 2 2 program~fc234->2 proc~check_zero_column check_zero_column program~fc234->proc~check_zero_column proc~set_translational_inv_constraints set_translational_inv_constraints program~fc234->proc~set_translational_inv_constraints proc~read_crystal read_crystal program~fc234->proc~read_crystal proc~include_constraints include_constraints program~fc234->proc~include_constraints proc~write_output_fc2 write_output_fc2 program~fc234->proc~write_output_fc2 proc~setup_maps setup_maps program~fc234->proc~setup_maps proc~force_constants_init force_constants_init program~fc234->proc~force_constants_init proc~calculate_and_write_displacements calculate_and_write_displacements program~fc234->proc~calculate_and_write_displacements 999 999 program~fc234->999 proc~read_force_position_data read_force_position_data program~fc234->proc~read_force_position_data proc~set_neighbor_list set_neighbor_list program~fc234->proc~set_neighbor_list 3 3 program~fc234->3 proc~write_independent_fcs write_independent_fcs program~fc234->proc~write_independent_fcs 9 9 program~fc234->9 proc~read_input read_input program~fc234->proc~read_input 4 4 program~fc234->4 proc~remove_zeros remove_zeros program~fc234->proc~remove_zeros interface~write_out write_out program~fc234->interface~write_out proc~write_lat_fc->3 proc~write_lat_fc->9 proc~write_lat_fc->4 1 1 proc~write_lat_fc->1 interface~length length proc~write_lat_fc->interface~length proc~findatom_sc findatom_sc proc~write_lat_fc->proc~findatom_sc proc~set_force_displacement_matrix->3 proc~set_force_displacement_matrix->4 66 66 proc~set_force_displacement_matrix->66 proc~set_force_displacement_matrix->proc~findatom_sc proc~set_rotational_inv_constraints->4 proc~compare2previous_lines compare2previous_lines proc~set_rotational_inv_constraints->proc~compare2previous_lines proc~set_rotational_inv_constraints->66 proc~svd_set->3 proc~svbksb svbksb proc~svd_set->proc~svbksb 99 99 proc~svd_set->99 proc~svdcmp svdcmp proc~svd_set->proc~svdcmp proc~write_neighbors->3 proc~write_correspondance2->2 proc~write_correspondance2->4 dfloat dfloat proc~write_correspondance2->dfloat proc~write_correspondance2->interface~length proc~write_correspondance2->proc~findatom_sc proc~set_huang_inv_constraints->9 8 8 proc~set_huang_inv_constraints->8 proc~identify_atoms_in_supercell->3 proc~check_input_poscar_consistency_new check_input_poscar_consistency_new proc~identify_atoms_in_supercell->proc~check_input_poscar_consistency_new proc~check_zero_column->proc~warn proc~find_t find_t proc~check_zero_column->proc~find_t proc~set_translational_inv_constraints->interface~write_out proc~set_translational_inv_constraints->proc~compare2previous_lines proc~set_translational_inv_constraints->interface~length proc~read_crystal->proc~make_reciprocal_lattice proc~read_crystal->9 proc~read_crystal->interface~write_out proc~calculate_volume calculate_volume proc~read_crystal->proc~calculate_volume proc~read_crystal->interface~length proc~write_output_fc2->2 proc~write_output_fc2->3 proc~write_output_fc2->4 proc~write_output_fc2->interface~length proc~setup_maps->9 proc~setup_maps->interface~write_out proc~get_dim get_dim proc~setup_maps->proc~get_dim proc~ustring ustring proc~setup_maps->proc~ustring proc~collect_force_constants collect_force_constants proc~setup_maps->proc~collect_force_constants proc~read_fcs_2 read_fcs_2 proc~setup_maps->proc~read_fcs_2 proc~findatom findatom proc~force_constants_init->proc~findatom proc~dlatmat2 dlatmat2 proc~force_constants_init->proc~dlatmat2 proc~unitcell unitcell proc~force_constants_init->proc~unitcell dsind dsind proc~force_constants_init->dsind proc~xmatinv xmatinv proc~force_constants_init->proc~xmatinv proc~bomb bomb proc~force_constants_init->proc~bomb proc~xvmlt xvmlt proc~force_constants_init->proc~xvmlt proc~xvsub xvsub proc~force_constants_init->proc~xvsub proc~xmatmlt xmatmlt proc~force_constants_init->proc~xmatmlt dcosd dcosd proc~force_constants_init->dcosd datan datan proc~force_constants_init->datan proc~calculate_and_write_displacements->2 proc~calculate_and_write_displacements->3 proc~direct_to_cart_aa direct_to_cart_aa proc~calculate_and_write_displacements->proc~direct_to_cart_aa proc~cart_to_direct_aa cart_to_direct_aa proc~calculate_and_write_displacements->proc~cart_to_direct_aa proc~read_force_position_data->interface~write_out proc~findword findword proc~read_force_position_data->proc~findword proc~allocate_pos allocate_pos proc~read_force_position_data->proc~allocate_pos proc~set_neighbor_list->2 proc~set_neighbor_list->3 proc~calculate_distance calculate_distance proc~set_neighbor_list->proc~calculate_distance proc~sort sort proc~set_neighbor_list->proc~sort proc~write_independent_fcs->3 proc~write_independent_fcs->9 proc~allocate_primcell allocate_primcell proc~read_input->proc~allocate_primcell proc~allocate_mass allocate_mass proc~read_input->proc~allocate_mass proc~remove_zeros->4 proc~write_outrm write_outrm interface~write_out->proc~write_outrm proc~write_outrv write_outrv interface~write_out->proc~write_outrv proc~write_outiv write_outiv interface~write_out->proc~write_outiv proc~write_outv write_outv interface~write_out->proc~write_outv proc~write_outr write_outr interface~write_out->proc~write_outr proc~write_outi write_outi interface~write_out->proc~write_outi proc~write_outim write_outim interface~write_out->proc~write_outim proc~write_outrm->99 proc~write_outrv->99 proc~write_outiv->99 proc~dlatmat2->proc~bomb proc~dlatmat2->proc~xvsub proc~compare2previous_lines->99 proc~write_outv->3 proc~unitcell->proc~xmatmlt proc~write_outr->99 proc~write_outi->99 proc~collect_force_constants->proc~findatom proc~collect_force_constants->99 proc~force_constants force_constants proc~collect_force_constants->proc~force_constants proc~unique_force_constant unique_force_constant proc~collect_force_constants->proc~unique_force_constant proc~lengthv lengthv interface~length->proc~lengthv proc~lengtha lengtha interface~length->proc~lengtha proc~lubksb lubksb proc~xmatinv->proc~lubksb proc~ludcmp ludcmp proc~xmatinv->proc~ludcmp proc~findatom_sc->dfloat proc~check_input_poscar_consistency_new->2 proc~check_input_poscar_consistency_new->3 proc~check_input_poscar_consistency_new->9 proc~check_input_poscar_consistency_new->interface~write_out proc~check check proc~check_input_poscar_consistency_new->proc~check proc~write_outim->99 proc~direct_to_cart_v direct_to_cart_v proc~direct_to_cart_aa->proc~direct_to_cart_v proc~cart_to_direct_v cart_to_direct_v proc~cart_to_direct_aa->proc~cart_to_direct_v proc~force_constants->proc~findatom proc~force_constants->proc~xvmlt proc~force_constants->proc~unique_force_constant proc~xrowop2 xrowop2 proc~force_constants->proc~xrowop2 proc~permutations permutations proc~force_constants->proc~permutations proc~findatom2 findatom2 proc~force_constants->proc~findatom2 proc~unique_force_constant->proc~findatom proc~permutations->proc~bomb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j n3 rank iunit tra rot hua eliminate_fc fcalloc xt fn poscar outcar ex newamat newbmat afrc bfrc aux1 frc_constr auxi error ermax sd sig tim now today zone Variables Type Attributes Name Initial integer :: i integer :: j integer :: n3 integer :: rank integer :: iunit integer :: tra integer :: rot integer :: hua integer :: eliminate_fc integer :: fcalloc character :: xt *1 character :: fn *11 character :: poscar *7 character :: outcar *7 logical :: ex real(kind=8), allocatable :: newamat (:,:) real(kind=8), allocatable :: newbmat (:) real(kind=8), allocatable :: afrc (:,:) real(kind=8), allocatable :: bfrc (:) real(kind=8), allocatable :: aux1 (:,:) integer, allocatable :: frc_constr (:) integer, allocatable :: auxi (:,:) real(kind=8) :: error real(kind=8) :: ermax real(kind=8) :: sd (4) real(kind=8) :: sig real :: tim character :: now *10 character :: today *8 character :: zone *5","tags":"","loc":"program/fc234.html"}]}